= Batchrahmen

include::documentation-guide::partial$licence.adoc[]

*Java Bibliothek / IT-System*

[cols="3,1,2",options="header"]
|====
|Name |Art |Version
m|isy-batchrahmen |Bibliothek |v{page-component-version}
|====

Der Batchrahmen ist das Framework, in welches sich die Batchlogik eines konkreten Batches einfügt.
Der Batchrahmen ruft die Batchlogik (anhand einer Konfiguration) auf.
Da ein Batch über Spring verwaltet wird, wird die Batchlogik als Spring-Bean konfiguriert, als sogenannte _Ausführungsbean_.
Diese Bean wiederum ruft die Fachkomponenten des Anwendungskerns auf, welche die Geschäftslogik enthalten.


[[anforderungen]]
== Anforderungen

[[anforderungen-an-den-batchrahmen]]
=== Anforderungen an den Batchrahmen

Für den Batchrahmen selbst gelten folgende Anforderungen:

* Er soll den vorhandenen Nutzungsvorgaben und Querschnitts­konzepten entsprechen.
* Die Spring-Konfiguration für den Batch soll der Konfiguration der Webanwendung möglichst ähnlich sein.
* Er soll möglichst wenige Anforderungen an (bzw.
Annahmen in Bezug auf) die Batchlogik stellen.
* Die Batchlogik soll möglichst einfach implementiert werden können.
* Die Batchrahmen-Implementierung soll programmtechnisch effizient sein.

[[ausgrenzungen]]
== Ausgrenzungen

Der bereitzustellende Batchrahmen soll ein unkompliziertes und einfach zu verwendendes Framework sein.
Seine Funktionalitäten sollen lediglich die Verarbeitung, nicht andere betriebliche Aspekte abdecken.
Explizit ausgegrenzt werden deshalb folgende Themenbereiche:

*Ein explizites Handling von Eingabedateien:* Ein möglicherweise erforderliches Dateihandling übernimmt die spezifische Batchlogik.
Der Batchrahmen soll kein Wissen darüber besitzen.

*Die Terminierung der Verarbeitung:* Der Batch stellt keine direkten Schnittstellen bereit, um ihn während der Verarbeitung zu beenden.
Allerdings muss es möglich sein, einen aktiven Lauf mit dem Signal `kill -15` definiert zu beenden.
Wie die zugehörige Prozess-ID ermittelt wird, ist in den Betriebshandbüchern für die Prozesse zu definieren.
Es ist auch möglich, mit dem „laufzeit“-Parameter eine maximale Laufzeit anzugeben, um den Batch nach Überschreitung der angegebenen Laufzeit sich selbst definiert beenden zu lassen.

*Das Scheduling der Verarbeitung:* Das Scheduling wird nicht durch den Batchrahmen, sondern durch die betriebliche Produktionssteuerung durchgeführt.

*Das Prüfen von Vorbedingungen:* Falls für die Ausführung Vorbedingungen gegeben sein müssen (etwa Dateien in Verzeichnissen vorliegen müssen), so liegt deren Prüfung in der Verantwortung des aufrufenden Skripts.

*Das Warten auf Events:* Der Batchrahmen arbeitet eine Reihe von Datensätzen ab und beendet sich danach.
Er ist kein Serverprozess, welcher auf bestimmte Events (Dateien in Verzeichnissen, Sätze in Datenbank) wartet, diese verarbeitet und daraufhin weiter wartet.

*Keine parallele Verarbeitung innerhalb eines Batches:* Es ist erlaubt, dass mehrere Java-Prozesse mit der gleichen Batch-Implementierung (jedoch verschiedenen BatchIDs) parallel laufen.

NOTE: Siehe Unterschied zwischen _Batch-Implementierung_ und _Batch_, xref:software-technisch/batch/abgrenzungen.adoc#der-unterschied-zwischen-batch-netz-batch-schritt-und-batch-implementierung[Abgrenzungen].
Parallel laufende Batches sind vor allem sinnvoll, wenn sie über einem aufgeteilten Datenbestand arbeiten und ein Batch pro Teil verwendet wird.

Innerhalb einer Verarbeitung wird jedoch stets mit einem Thread gearbeitet.
Multithreading innerhalb eines Batches wird nicht unterstützt.


// TODO in Batchrahmen verschieben?
[[grobe-architektur-des-batchrahmens]]
== Grobe Architektur des Batchrahmens

Für den Batchrahmen wurde folgende grobe Architektur gewählt:

.Grobe Architektur des Batchrahmens
[id="image-GrobArchBatCanv",reftext="{figure-caption} {counter:figures}"]
image::software-technisch/batch/GrobArchBatCanv.png[align="center",width=80%]

Der Batchrahmen besteht aus einem Startprogramm, welches notwendige Initialisierungen vornimmt, und einer Komponente Batchrahmen.
Die Komponente Batchrahmen übernimmt die Steuerung des Batches und den Aufruf der Batchlogik.

Die Komponenten einer Geschäftsanwendung werden für einen Batch, genau wie in der Webanwendung, über das Spring-Framework verwaltet.
Damit die Konfigurationen für die Webanwendung und für die Batch-Implementierungen möglichst gleich sind, werden die Komponenten für den Batchrahmen und die Batchlogik in einer separaten Konfigurationsdatei und einem separaten Spring-Kontext abgelegt.
Dieser Kontext ist ein Kind-Kontext des eigentlichen xref:glossary:glossary:master.adoc#glossar-anwendungskontext[Anwendungskontextes] und kann alle Beans des Anwendungskontextes verwenden.
So kann die Konfiguration der Webanwendung mit minimalen Anpassungen auch für den Batch verwendet werden.

Der Batchrahmen benötigt für die Speicherung des Fortschritts und des Status der Batches eine Datenbankverbindung.
In der Datei werden die vom Batchrahmen benötigten Informationen gespeichert, siehe <<tabellen-des-batchrahmens>>.

Bei Bedarf können in einem Batch auch weitere Datenbankverbindungen genutzt werden.
Die Einbindung weiterer Datenbanken ist in xref:isy-persistence:konzept/vorgaben-konventionen.adoc#nutzung-und-anbindung-einer-zweiten-datenbank[Konzept des Bausteins JPA/Hibernate] beschrieben.

[[checkpoint-restart-logik]]
== Checkpoint / Restart Logik

Da ein Batch in einem Lauf eine große Anzahl an Datensätzen verarbeiten muss, soll seine Verarbeitung nicht in einer Transaktion durchgeführt werden.
Ebenso soll nicht jeder Datensatz in einer eigenen Transaktion verarbeitet werden, wie es die Transaktionssteuerung des Anwendungskerns vorsieht.
Vielmehr wird ein Batch sein Arbeitspaket in mehreren Paketen, und damit auch Transaktionen, abarbeiten.
Bei einem Wiederanlauf nach einem Fehler muss der Batch in der Lage sein, die bis zu seinem letzten Commit verarbeiteten Datensätze zu überlesen und nur die „neuen“ Datensätze zu verarbeiten.
Den Commit einer Transaktion bezeichnet man in diesem Fall als Checkpoint.
Das Überlesen bereits verarbeiteter Datensätze nennt man Checkpoint / Restart Fähigkeit.

Für die Umsetzung der Checkpoint / Restart Fähigkeit muss der Batch in jeder Transaktion speichern, welche Datensätze bis zum Commit verarbeitet wurden. Üblicherweise geschieht das durch die Ablage der Anzahl verarbeiteter Datensätze bis zum Commit.
Abgelegt werden diese Daten in einer Batch-Statustabelle, welche für jeden Batch eine Zeile enthält.



[[der-batchrahmen]]
== Der Batchrahmen



Für eine Beispielanwendung zeigt <<image-BeanGriffBat>> eine Auswahl der vorhandenen Beans.
Wichtig ist ihre Verteilung auf zwei Anwendungskontexte: Der Batchrahmen und die Ausführungsbeans werden in einem eigenen Kontext konfiguriert.
So müssen wenige Anpassungen vorgenommen werden, um aus der Anwendungskontext-Konfiguration als Webanwendung die Konfiguration für den Anwendungskontext im Batchbetrieb zu erhalten.

.Bean-Zugriffe des Batchrahmens
[id="image-BeanGriffBat",reftext="{figure-caption} {counter:figures}"]
image::software-technisch/batch/BeanGriffBat.png[]

Für neue Batch-Implementierungen einer Geschäftsanwendung müssen ggf.
Geschäftsanwendungs-Komponenten angepasst, Ausführungsbeans erstellt und diese im Batch-Springkontext konfiguriert werden.
Die folgenden Abschnitte liefern die zur Entwicklung dieser Beans und zur Verwendung des Batchrahmens notwendigen Informationen.
Im Einzelnen werden die folgenden Aspekte beschrieben:

* Die Konfigurationsmöglichkeiten des Batchrahmens und der Ausführungsbeans.
* Das Transaktions-Handling, die Restart-Funktionalität und die Status-Tabellen des Batchrahmens.
* Die im Batchrahmen enthaltenen Überwachungsmöglichkeiten.
* Die Authentifizierung und Autorisierung einer ClientRegistration.
* Das Deployment der Batches einer Geschäftsanwendung.

[[die-status-und-startarten-des-batchrahmens]]
=== Die Status und Startarten des Batchrahmens

Im Folgenden werden die Status beschrieben, in welchen sich ein Batch laut den Batchrahmen-Tabellen befinden kann.
Zusätzlich werden, basierend auf diesen Status, die Möglichkeiten zum Starten eines Batchlaufs beschrieben.
Diese Informationen werden hier vorgestellt und in den folgenden Abschnitten im Zusammenhang mit den Parametern und
Tabellen des Batchrahmens verwendet.

Ein Batch befindet sich in einem von vier Status, welche in den Tabellen des Batchrahmens gespeichert werden:

* `neu`: Status eines noch nicht gelaufenen Batches.
Existiert kein Eintrag in der Datenbank, dann wird dieser Status implizit verwendet.
Bricht ein noch nicht gelaufener Batch noch in der Initialisierungsphase ab, dann wird dieser Status explizit in die Datenbank geschrieben.
* `laeuft`: Der Batch wurde gestartet und läuft aktuell.
* `abgebrochen`: Der Batch ist
** mit einem Fehler
** durch das Signal `kill -15`
** durch die Überschreitung der konfigurierten maximalen Laufzeit
** oder weil die Grenze der zu verarbeitenden Datensätze erreicht wurde abgebrochen
* `beendet`: Der Batch ist erfolgreich beendet worden.

Je nachdem, in welchem Zustand sich der Batch laut den Tabellen gerade befindet, lässt er sich nur mit bestimmten Startarten starten.
Welche Startart verwendet wird, muss über Parameter definiert werden.
Folgende Startarten sind möglich:

* *Batch im Status `neu` oder `beendet`:*
+
`start`: Der Batch startet und bearbeitet die Eingabedaten ab dem ersten Datensatz.
* *Batch im Status `laeuft`:*
+
`ignoriereLauf`: Der Batch wird gestartet, als wäre er erfolgreich beendet worden.
+
`restart`: Der Batch startet neu und überliest alle bereits verarbeiteten Sätze.
* *Batch im Status `abgebrochen`:*
+
`restart`: Der Batch startet neu und überliest alle bereits verarbeiteten Sätze.
+
`ignoriereRestart`: Der Batch startet neu und beginnt die Verarbeitung mit dem ersten Datensatz.

[[die-konfiguration-des-batchrahmens]]
=== Die Konfiguration des Batchrahmens

[[konfigurationsdatei-und-kommandozeilen-parameter]]
==== Konfigurationsdatei und Kommandozeilen-Parameter

Die Konfiguration des Batchrahmens wird über zwei Arten durchgeführt: über

- Kommandozeilen-Parameter und
- Konfigurationsdateien.

Alle Konfigurationsparameter werden an die Ausführungsbean übergeben und können genutzt werden, um sie zu konfigurieren.

NOTE: Bei der Nutzung von Dateien, egal ob für Kommandozeilenparameter oder für Konfigurationsdateien,
müssen die Dateien mit absoluten Pfaden angegeben werden.

===== Reihenfolge der Auswertung
Konfigurationsparameter werden in der folgenden Reihenfolge im Spring-Kontext angezogen. Gleichnamige Parameter werden in dieser Reihenfolge überschrieben:

. Konfiguration des Betriebssystems / der JVM,
. Konfigurationsdatei,
. Kommandozeilen-Parameter.

==== Kommandozeilen-Parameter
===== Namenskonvention
//tag::namenskonvention[]
.Batches: Konfigurationsparameter Kommandozeile
[id="table-batckonfig-konfigurationsparameter-kommandozeile",reftext="{table-caption} {counter:tables}"]
[cols="1,4",options="header"]
|====
2+|Batches: Konfigurationsparameter Kommandozeile
|*Schema* m|-<Parametername> <Parameterwert>
|*Beispiele* m|-laufzeit 10
|====
//end::namenskonvention[]

===== Standard-Parameter
Vom Batchrahmen werden folgende Kommandozeilen-Parameter interpretiert:

.Kommandozeilen-Parameter des Batchrahmens
[id="table-CLIBATCanv",reftext="{table-caption} {counter:tables}"]
[cols="3,7",options="header"]
|====
|Parameter |Beschreibung
|`-cfg <Dateiname>` |Name einer Property-Datei mit Konfigurationseinträgen.
Der Dateiname wird relativ zum Klassenpfad interpretiert.
|`-start` a|
Starten des Batches und Verarbeitung der Daten ab dem ersten Datensatz. +
Batches im Status „beendet“ _müssen_ über „-start“ gestartet werden. +
Die gleichzeitige Eingabe von „-start“ und „-restart“ führt zum Abbruch des Batches.
|`-restart` a|
Starten des Batches nach einem Fehler-Abbruch: Überlesen der bereits verarbeiteten Datensätze. +
Batches im Status „Abbruch“ müssen mit „-restart“ gestartet werden oder zusätzlich den Parameter -ignoriereRestart enthalten.
|`-ignoriereRestart` |Auch bei Fehlern Start akzeptieren, nicht auf Restart beharren.
|`-ignoriereLauf` |Auch bei Status "laeuft" Start akzeptieren.
|`-testmodus` |Startet den Batch im Testmodus.
Dieser arbeitet analog zum normalen Wirkbetrieb, jedoch werden keine Änderungen an Datenbeständen der Anwendung oder der Nachbarsysteme durchgeführt.
Ein detailliertes Konzept ist in Kapitel <<testmodus>> beschrieben.
|`-laufzeit <Minuten>` |Gibt eine maximale Laufzeit in Minuten an.
Wird die angegebene Zeit überschritten, wird der aktuelle Datensatz zu Ende bearbeitet.
Der Batch bricht vor der Verarbeitung des nächsten Datensatzes mit einem dedizierten Return-Code ab.
|====

===== Weitere Parameter

Es können auch andere Parameter angegeben werden, die der Namenskonvention genügen

==== Konfigurationsdatei(en)
Konfigurationsdateien sind syntaktisch property-Dateien.
Die Konfigurationsdatei mit den unten aufgelisteten Parametern wird als statische Konfiguration im Verzeichnis`resources` abgelegt und
kann daher nicht vom Betrieb angepasst werden.

Betriebliche Konfigurationen müssen wie in Kapitel <<betriebliche-konfiguration-der-ausfuehrungsbean>> beschriebenen
umgesetzt werden.

===== Namenskonvention

.Batches: Benennung Konfigurationsdateien
[id="table-batch-property-files",reftext="{table-caption} {counter:tables}"]
[cols="1,4",options="header"]
|====
2+|Batches: Benennung Konfigurationsdateien (unter resources/resources/batch)
|*Schemata* m|<batchname-des-batches>.properties
|*Beispiele* m|loeschfrist-pruefen.properties +
import-bhknz-liste.properties
|====


//tag::namenskonvention[]
.Batches: Konfigurationsparameter Konfigurationsdatei
[id="table-batckonfig-konfigurationsparameter-konfigurationsdatei",reftext="{table-caption} {counter:tables}"]
[cols="1,4",options="header"]
|====
2+|Batches: Konfigurationsparameter Konfigurationsdatei
|*Schema* m|<Parametername>=<Parameterwert>

<Parametername>.<Parametername>=<Parameterwert>
|*Beispiele* m| BatchName=LoeschBatch

Loeschfunktion.DatumVon=30.11.2019
|====
//end::namenskonvention[]

[[standard-konfigurationsparameter]]
===== Standard-Konfigurationsparameter
Die nachfolgenden Parameter sind in der Batchkomponente als Standard definiert und werden der
Konfiguration in der Property-Datei hinzugefügt.

Aus der Property-Datei werden durch den Batchrahmen folgende Properties gelesen:

.Die Properties des Batchrahmens
[id="table-PropBATCanv",reftext="{table-caption} {counter:tables}"]
[cols="5,4",options="header"]
|====
|Property |Beschreibung
|`Batchrahmen.BeanName` |Name der Batchrahmen-Bean
|`Anwendung.SpringDateien.<N>` |Vollqualifizierte Namen der Spring-Konfigurationsklassen der Geschäftsanwendung
|`Batchrahmen.SpringDateien.<N>` |Vollqualifizierte Namen der Spring-Konfigurationsklassen des Batchrahmens
|`Batchrahmen.CommitIntervall` |Anzahl Satz-Verarbeitungen pro Commit
|`Batchrahmen.ClearIntervall`| Anzahl Satz-Verarbeitungen bis zum Löschen des Hibernate session cache. Dies dient Perfomancegründen und der Vermeidung von out of memory Fehlern.
|`AusfuehrungsBean`|Name der Ausführungsbean für die Batchlogik
|`BatchId` |ID des Batches (ID des Batch-Status-Datensatzes)
|`BatchName` |Name des Batches in der Batch-Statustabelle
|`Batchrahmen.AnzahlZuVerarbeitendeDatensaetze` |Falls nicht die ganze Datei verarbeitet werden soll, sondern nur eine gewisse Anzahl an Datensätzen.
|`Batchrahmen.Ergebnisdatei` |Pfad zur XML-Ergebnisdatei des Batchrahmens (siehe Kapitel <<rueckgabewerte-des-batchrahmens>>)
|====

===== Weitere Parameter
Die Property-Datei darf beliebige weitere Properties enthalten, die der Namenskonvention genügen.

[[betriebliche-konfiguration-der-ausfuehrungsbean]]
==== Betriebliche Konfiguration der Ausführungsbean

Sämtliche obigen Parameter müssen vom Betrieb nicht angepasst werden.
Falls im Ausnahmefall die Batch-ID angepasst werden muss, kann dies über den Kommandozeilen-Parameter –BatchId <BatchId> geschehen.

Falls für die Ausführungsbean eines Batches Konfigurationen notwendig sind, welche durch den Betrieb gepflegt werden müssen, so ist dies auf eine von zwei Arten umzusetzen:

* Die Konfigurationen können der betrieblichen Konfiguration der Geschäftsanwendung hinzugefügt werden. +
+
NOTE: Konfiguration der Geschäftsanwendung: Die im Ordner `config` liegenden, durch den Betrieb pflegbaren Konfigurationsdateien.
+
Die Ausführungsbean kann dann die Geschäftsanwendungs-Konfigurationsbean per Dependency Injection erhalten und sich darüber konfigurieren.
+
Diese Möglichkeit ist zu verwenden, falls nur ein Batch für die Geschäftsanwendung umgesetzt wird.
Falls mehrere Batches umgesetzt werden, ist sie dann zu verwenden, wenn sich die Konfigurationen für die einzelnen Batches nicht widersprechen (also für verschiedene Batches verschiedene Werte für die gleiche Property erwartet werden).

* Die Konfiguration kann in einer neuen Datei abgelegt werden, welche nur für diesen Batch verwendet wird.
Diese Datei kann als Properties-Bean geladen und der Ausführer-Bean per Dependency Injection übergeben werden. +
+
Diese Möglichkeit ist zu verwenden, falls für verschiedene Batches verschiedene Konfigurationsdateien benötigt werden.

[[die-konfiguration-der-spring-kontexte]]
==== Die Konfiguration der Spring-Kontexte

Wie in Kapitel <<grobe-architektur-des-batchrahmens>> beschrieben, werden für einen Batch zwei Spring-Kontexte erzeugt:

* Ein Kontext mit den Beans der eigentlichen Geschäftsanwendung.
* Ein Kontext mit der Batchrahmen-Bean, der Batchrahmen JMX-Bean sowie den Ausführungsbeans für die Batches der Geschäftsanwendung.

Für den Kontext der eigentlichen Geschäftsanwendung können die Spring-Konfigurationsdateien übernommen werden.
In ihnen müssen folgende Anpassungen vorgenommen werden:

* Service-Beans, die für die Batch-Verarbeitung nicht benötigt werden, sollten entfernt werden.
* Damit die Entity-Klassen des Batchrahmens gefunden werden können, muss in der Spring-Konfiguration der Batches ein Entity-Scan hinzugefügt werden:

 @EntityScan("de.bund.bva.isyfact.batchrahmen.persistence.rahmen")

* Das Nachrichten-Resource-Bundle für den Batch muss der `messageSource`-Bean hinzugefügt werden.

Um Beans gezielt aus der Spring-Konfiguration der Anwendung für die Ausführung eines Batches auszuschließen, kann die
Annotation `@ExludeFromBatchContext` verwendet werden.
Damit werden mit `@Component` annotierte Klassen oder `@Bean`-Methoden in `@Configuration`-Klassen annotiert (<<listing-excludefrombatchcontext>>).

.Verwendung der Annotation @ExcludeFromBatchContext
[id="listing-excludefrombatchcontext",reftext="{listing-caption} {counter:listings }"]
[source,java]
----
@Component
@ExcludeFromBatchContext
public class BeispielServiceExceptionFassade { ...


@Configuration
public class ServiceConfig {
    @Bean
    @ExcludeFromBatchContext
    public BeispielServiceExceptionFassade() { ...
----

Die Spring-Konfiguration für den Kontext des Batchrahmens muss neu erstellt werden.
Hierfür werden gesonderte `@Configuration`-Klassen erstellt.

[NOTE]
====
Da `isy-batchrahmen` die JPA-Konfiguration und den PersistenceContext der Anwendung nutzt, muss ggf. ein explizites Object-Relational Mapping (Tabelle &#8660; Java Klasse) definiert werden.

Für Anwendungen, welche die `PhysicalNamingStrategyStandardImpl` und die aktuelle <<image-SchemTabBatStat,BatchStatus-Tabelle>> verwenden, stellt `isy-batchrahmen` explizites ORM bereit, das in der Anwendung wie folgt benutzt werden kann:
[source,properties]
----
spring.jpa.mapping-resources = resources/isy-batchrahmen/hibernate/hibernate-mapping.xml
----

Für Anwendungen, welche die `CamelCaseToUnderscoresNamingStrategy` mit der IsyFact 2 `BatchStatus` Tabelle (ohne Unterstriche) verwenden, stellt `isy-batchrahmen` explizites ORM bereit, das in der Anwendung wie folgt benutzt werden kann:

[source,properties]
----
spring.jpa.mapping-resources = resources/isy-batchrahmen/hibernate/hibernate-mapping-if2.xml
----

Im Nachfolgenden wird die Tabelle `BATCH_STATUS` mit `CamelCaseToUnderscoresNamingStrategy` (Standard aus Spring Boot) verwendet und es ist kein explizites ORM erforderlich.
====

[[tabellen-des-batchrahmens]]
== Tabellen des Batchrahmens

Der Batchrahmen benötigt für seine Checkpoint / Restart Funktionalität die Möglichkeit, bei jedem Commit den aktuellen Stand des Batches in einer Tabelle zu speichern.
Dies wird über die Tabelle `BATCH_STATUS` umgesetzt.

.Schema der Tabelle `BATCH_STATUS`
[[image-SchemTabBatStat]]
image::software-technisch/batch/SchemTabBatStat.dn.png[align="center"]

Die Tabelle `BATCH_STATUS` enthält für jeden Batch eine Zeile.
Ein Batch ist nicht gleichzusetzen mit der Batch-Ausführungsbean.
Für eine Bean darf es mehrere Batches geben, welche die Bean für die Ausführung jeweils anders konfigurieren.
Für einen Batch werden folgende Informationen verwendet:

.Das Schema der Tabelle BATCH_STATUS
[id="table-SchemTabBatStat2",reftext="{table-caption} {counter:tables}"]
[cols="3m,7",options="header"]
|====
|Spalte
|Beschreibung

|BATCH_ID
|Der Schlüssel für den Batch.
Die ID sollte aus einem gemeinsamen Präfix für das Backend, gefolgt von einem Suffix für den konkreten Batch, bestehen.

|BATCH_NAME
|Ein kurzer informativer Name des Batches.

|BATCH_STATUS
a| Einer der folgenden Werte:

* `laeuft`: Der Batch wurde gestartet und läuft aktuell.
* `abgebrochen`: Der Batch ist abgebrochen und sollte per `RESTART` neu gestartet werden.
* `beendet`: Der Batch ist erfolgreich beendet worden.

|SATZ_NUMMER_LETZTES_COMMIT
|Die Anzahl an Sätzen, welche beim letzten Commit verarbeitet worden sind.
Dies wird für die Umsetzung der Restart-Funktionalität verwendet.

|SCHLUESSEL_LETZTES_COMMIT
|Der letzte Datenbank-Schlüssel des Datensatzes, der vor dem Commit bearbeitet wurde.
Dies wird für die Umsetzung der Restart-Funktionalität verwendet.
Falls der Schlüssel ein zusammengesetzter Schlüssel ist, müssen sämtliche Schlüsselteile (durch Trennzeichen getrennt) in dieses Feld geschrieben werden.

|DATUM_LETZTER_START
|Das Datum des Starts des aktuellen Batchlaufs, falls der Status `laeuft` ist, bzw. des letzten Laufes.

|DATUM_LETZTER_ABBRUCH
|Das Datum des letzten fehlerhaften Abbruchs des Batches.

|DATUM_LETZTER_ERFOLG
|Das Datum des letzten erfolgreichen Abschlusses des Batches.
|====

Die Tabelle liegt im Datenbankschema des zugehörigen Backends.
Es darf keine übergreifenden Tabellen oder ein übergreifendes Datenbankschema für alle Batches geben.

[[verwaltung-der-tabelle]]
=== Verwaltung der Tabelle

Die Tabelle dient nicht der Steuerung des Batches über den Betrieb, sondern nur der Ablage von Informationen zwischen zwei Batch-Läufen.
Die Befüllung der Tabelle wird deshalb komplett über den Batchrahmen durchgeführt: Es müssen keine Datensätze manuell befüllt werden: Ist ein Datensatz für einen Batch noch nicht vorhanden, wird er angelegt.

Üblicherweise ist das Locking-Verhalten in Geschäftsanwendungen optimistisch: Datensätze werden nicht explizit gelockt.
Stattdessen wird über Versions-Attribute zum Commit-Zeitpunkt geprüft, ob der Datensatz innerhalb der Transaktion verändert wurde.
Für die Tabelle des Batchrahmens wird _nicht_ optimistisch, sondern pessimistisch gelockt.
Zusätzlich wird als Hibernate Locking-Strategie `LOCK_NOWAIT` verwendet: Falls auf einen Datensatz zugegriffen wird, welcher gerade gelockt ist, wird nicht bis zur Freigabe gewartet, sondern eine Exception geworfen.
Die parallele Ausführung zweier Batches mit gleicher Batch-ID ist nicht erlaubt und soll zum Fehler führen.

[[die-transaktionssteuerung]]
=== Die Transaktionssteuerung

In der Property-Datei des Batchrahmens wird die Commit-Rate für den Batch über eine Property konfiguriert.
Die Transaktionssteuerung für einen Batch arbeitet daraufhin folgendermaßen:

* Die Klasse `BatchLauncher` liest die Kommandozeile ein, interpretiert die Parameter und erzeugt alle notwendigen Spring-Kontexte.
Dies geschieht außerhalb einer Transaktion.
Danach gibt die Klasse die Kontrolle an die Batchrahmen-Bean weiter.
* Die Batchrahmen-Bean startet eine erste Transaktion.
Sie aktualisiert die Batchrahmen-Tabellen und initialisiert die Ausführungsbean in dieser Transaktion.
Die Ausführungsbean führt im Rahmen dieser Transaktion das "Vorlesen" bis zum letzten Checkpoint sowie ggf. nötige Initialisierungen durch.
Die Transaktion wird beendet.
Danach beginnt die Satz-Verarbeitung.
* Für die Satz-Verarbeitung wird eine neue Transaktion gestartet.
Die einzelnen Datensätze werden verarbeitet.
Bei Erreichung eines Checkpoints wird die Status-Tabelle aktualisiert, die Transaktion abgeschlossen (Commit) und eine neue gestartet.
* Sobald der letzte Datensatz verarbeitet wurde, wird in einer letzten Transaktion die Status-Tabelle aktualisiert, auf der Ausführungsbean eine Shutdown-Methode aufgerufen und die Transaktion abgeschlossen.

Das Verhalten in Fehlerfällen ist zu jedem Zeitpunkt während der Verarbeitung gleich: Der Fehler wird geloggt und die Transaktion zurückgerollt.
Danach wird versucht, eine neue Transaktion zu starten, um die Status-Tabelle zu aktualisieren: Der Status wird auf `abgebrochen` gesetzt und die Spalte `DatumLetzterAbbruch` auf den aktuellen Zeitpunkt.
Daraufhin wird versucht, diese Transaktion abzuschließen.

WARNING: Schlägt diese Transaktion fehl, kann der Batchrahmen den Abbruch nicht persistent speichern.
Der nächste Lauf muss dann mit dem Parameter `-ignoriereLauf` gestartet werden.

[[die-restart-funktionalitaet]]
=== Die Restart-Funktionalität

Falls ein Batch durch einen Fehler oder durch das Erreichen der Anzahl zu verarbeitender Datensätze abgebrochen ist, muss ein Restart für ihn durchgeführt werden.
In diesem Fall müssen alle bereits verarbeiteten Datensätze übersprungen werden.
Ebenso wird die Wiederanlauffähigkeit nach manuellem Terminieren durch das Signal `kill -15` sichergestellt.

[[die-konfiguration-im-restart-fall]]
==== Die Konfiguration im Restart-Fall

Im Restart-Fall wird nicht überprüft, dass die übergebenen Parameter denen entsprechen, die im ursprünglichen Lauf übergeben wurden.
Es muss daher bei einem Restart manuell darauf geachtet werden, dass die gleichen Parameter übergeben werden.

[[beenden-eines-laufs-mit-kill--15-und-wiederanlauf]]
==== Beenden eines Laufs mit `kill -15` und Wiederanlauf

Durch Senden des Signals `kill -15` kann ein aktiver Batchlauf beendet werden.
Beim Empfang des Signals wird der aktuelle Datensatz zu Ende bearbeitet und der Batch terminiert im wohldefinierten Zustand.
In der Statustabelle ist dann der Status `abgebrochen` vermerkt und der Batchlauf kann mit dem Parameter `-restart` wieder aufgesetzt werden.

[[wiederanlauf-nach-abbruch-durch-die-ueberschreitung-der-maximalen-laufzeit]]
==== Wiederanlauf nach Abbruch durch die Überschreitung der maximalen Laufzeit

Falls der Batch mit dem Parameter `laufzeit` gestartet wurde, wird nach Überschreitung der angegebenen maximalen Laufzeit der aktuelle Datensatz zu Ende bearbeitet und der Batch terminiert im wohldefinierten Zustand.
In der Statustabelle ist dann der Status `abgebrochen`  vermerkt und der Batchlauf kann mit dem Parameter `-restart` wieder aufgesetzt werden.

[[wiederanlauf-nach-abbruch-durch-kill--9]]
==== Wiederanlauf nach Abbruch durch `kill -9`

Durch Senden des Signals `kill -9` wird der aktive Batch-Prozess von Betriebssystemseite beendet.
Dabei wird der Java-Prozess direkt entfernt ohne die Möglichkeit, den Batchrahmen definiert zu terminieren.
Dies ist daher nur in Ausnahmesituationen vom Betrieb durchzuführen.
Da der Batchrahmen in dieser Situation kein Status-Update mehr schreiben kann, befindet sich der Eintrag `läuft` in der Statustabelle.
Ein Wiederanlauf in dieser Situation ist mit dem Parameter `-restart` möglich.

[[das-vorlesen-durch-die-ausfuehrungsbean]]
==== Das Vorlesen durch die Ausführungsbean

Um den Batch nach einem Fehler zum nächsten zu bearbeiteten Datensatz "vorlesen" zu lassen, muss dieser Datensatz identifiziert werden.
Dies geschieht zum einen durch den Batchrahmen selbst, welcher die Anzahl der bereits verarbeiteten Datensätze speichert.
Bei auf Datenbank-Queries basierenden Batches kann diese Anzahl jedoch ggf. nicht verwendet werden, da sie sich im Laufe der Zeit ändert.
Hier ist es notwendig, die zu verarbeitenden Sätze nach ihrem Schlüssel zu sortieren und den als letztes bearbeiteten Schlüssel zu speichern.

Die Batchrahmen Status-Tabelle enthält deshalb zwei Felder: Ein Feld für die Anzahl verarbeiteter Sätze und ein Feld für den Schlüssel des letzten verarbeiteten Datensatzes.
Dieser Schlüssel wird von der Ausführungsbean nach der Verarbeitung eines Satzes zurückgegeben.

Bei einem Restart wird der Ausführungsbean in der Initialisierungsmethode übermittelt, ob es sich um einen Restart handelt und welche Werte für den Schlüssel und die Satznummer in der Datenbank stehen.
Der Bean ist es überlassen, das Vorlesen effizient durchzuführen (etwa durch die Aufnahme des Schlüssels in das Selektionskriterium einer Query).

[[die-ueberwachungs-funktionalitaet]]
=== Die Überwachungs-Funktionalität

Die Verarbeitung eines Batches soll überwacht und nachverfolgt werden können.
Für die Nachverfolgung können durch die Ausführungsbean zu verschiedenen Zeitpunkten Log-, Statistik- oder Protokoll-Einträge erstellt werden:

* zu Beginn des Batches, während der Initialisierung der Ausführungsbean,
* nach dem Schreiben jedes Checkpoints,
* bei der erfolgreichen Beendigung des Batches.

Jeder Log-Eintrag eines Batches, insbesondere die Aufrufe der Fachkomponenten, enthält pro Satz eine eindeutige Korrelations-ID.
Damit können Log-Einträge nicht nur einem Batchlauf, sondern den einzelnen Sätzen eindeutig zugeordnet werden.

Für die Überwachung wird durch den Batchrahmen eine JMX-Bean bereitgestellt.
Über folgende Konfiguration wird ein JMX-Agent erzeugt, welcher die Bean nach außen zugreifbar macht:

[[jmx-parameter]]
.JMX-Parameter
[source]
----
  -Dcom.sun.management.jmxremote
  -Dcom.sun.management.jmxremote.port=<PortNummer>
  -Dcom.sun.management.jmxremote.ssl=false
  -Dcom.sun.management.jmxremote.authenticate=true
----
Über die Java Management Console kann man danach auf die Daten zugreifen.

Bereitgestellt werden folgende Informationen:

[[table-JMXAttr]]
.JMX-Attribute
[cols="1m,2",options="header"]
|====
|Property
|Beschreibung

|SaetzeGesamt
|Die Gesamtanzahl der zu bearbeitenden Sätze. Falls diese nicht bekannt ist: -1

|SaetzeVerarbeitet
|Die Anzahl bereits verarbeiteter Sätze.

|SchluesselLetzterSatz
|Schlüssel des letzten verarbeiteten Satzes.

|ZeitSeitLetztemSatz
|Zeitraum in Millisekunden, der bereits für den aktuellen Satz benötigt wurde.

|BatchId
|Die ID des aktuellen Batches

|BatchName
|Name des aktuellen Batches
|====

Zur Erhöhung der Sicherheit in der Betriebsumgebung muss eine Absicherung der RMI-Schnittstelle für JMX per Benutzername und Passwort erfolgen (siehe <<jmx-parameter>>).
Hierzu sind die JMX-Benutzer und Passwörter entweder direkt in der Datei `JRE_HOME/lib/management/jmxremote.password` zu konfigurieren, oder der Ort dieser Datei ist über den JVM-Parameter `com.sun.management.jmxremote.password.file` anzugeben.
Die Datei benötigt einen Eintrag für die Rolle `controlRole` oder für eine beliebige Rolle, für welche in
Datei `JRE_HOME/lib/management/jmxremote.access` der Zugriff `readwrite` erlaubt ist.

[[authentifizierung-und-autorisierung]]
=== Authentifizierung und Autorisierung

Zur Authentifizierung verwendet der Batch die Benutzerkennung eines technischen Benutzers "internes System", die in seiner Startkonfiguration (als Konfigurationsdatei) hinterlegt und im Benutzerverzeichnis vorhanden ist.

Der Batchrahmen verwendet den Baustein `isy-security`, um den in der Batch-Konfiguration via `oauth2ClientRegistrationId` definierten Benutzer über einen der Authentifizierungswege `Client Credential` oder `Ressource Owner Password Credential` (deprecated) zu authentifizieren.

Im Zuge des Batchlaufs können nun über den Baustein `isy-security` Berechtigungsprüfungen (z.B. im Anwendungskern) stattfinden.

Nach der initialen Authentifizierung eines Benutzers führt der Batch vor jedem Verarbeitungsschritt eine Prüfung durch, ob das Authentifizierungstoken erneuert werden muss.
Eine erneute Authentifizierung wird dann vorgenommen, wenn das Token als abgelaufen gilt.
Ein Token gilt als abgelaufen, wenn es weniger als die via `oauth2MinimumTokenValidity` angegebenen Sekunden vor dem Ablauf steht oder im Token kein Wert für den Ablaufzeitpunkt angegeben ist.

Folgende Informationen zum Benutzer sind anzugeben

.Eigenschaften des Batchbenutzers
[[table-CharBatUse]]
[cols="2,2,8a",options="header"]
|====
|Property
|Default
|Beschreibung

|`oauth2ClientRegistrationId`
|null
|Die ID der OAuth 2.0 Client Registration aus `isy-security`, die zur Authentifizierung genutzt wird.
Die notwendigen Properties die für eine gültige `ClientRegistration` definiert werden müssen, sind in den Nutzungsvorgaben der Komponente `isy-security` beschrieben.

|`oauth2MinimumTokenValidity` +
(optional)
|60
|Die Zeit in Sekunden, die ein Token mindestens weiterhin gültig sein muss, um nicht erneuert zu werden.
Steht ein Token weniger als die über die Property angegebenen Sekunden vor dem Ablauf, so wird eine erneute Authentifizierung vorgenommen. +
[NOTE]
Abhängig vom gewählten Grant-Type wird eine erneute Authentifizierung gegebenenfalls nur dann durchgeführt, wenn ein durch die Spring-Implementierung vorgegebener Zeitraum vor dem Ablauf des Tokens überschritten wird (siehe xref:isy-security:nutzungsvorgaben/master.adoc#authentifizierungsmanager-authentifiziere-method-grant-type-note[Hinweis zur Methode `authentifiziere`]).
|====

In der Regel wird der Benutzer aus der betrieblichen Konfiguration der Anwendung oder alternativ aus den Aufrufparametern beim Start des Batches gelesen.

In Ausnahmefällen ist es auch möglich, einen Batch zu implementieren, der ohne Benutzer laufen soll.
Dies ist nur möglich, wenn bei Aufrufen des Anwendungskerns keine Autorisierungsprüfungen stattfinden und auch keine Nachbarsystemschnittstellen aufgerufen werden.

Enthält eine Anwendung mehrere Batches, so enthält sie auch mehrere BatchKonfigurationen und kann jeden Batch mit einer eigenen `oauth2ClientRegistrationId` und `oauth2MinimumTokenValidity` ausstatten.

[[das-deployment-eines-batches]]
=== Das Deployment eines Batches

Die Batches werden nicht einzeln deployt.
Stattdessen wird ein Paket angeboten, welches sämtliche Batches eines Backends enthält.

Das erstellte Paket enthält den Code des Batchrahmens sowie den Code der eigentlichen Geschäftsanwendung inklusive der Batch-Ausführungsklassen und der benötigten nicht-betrieblichen Batch-Konfigurationsdateien.
Für jeden Batch wird ein Shellskript zum Start bereitgestellt.

Für die Shellskripte existieren keine Vorgaben.
Falls vor der Ausführung des Batches Vorbedingungen gelten müssen (etwa Dateien in Verzeichnissen vorliegen sollen), so können sie in diesen Skripten geprüft werden.
Beispiele für Aufruf-Skripte von Batches befinden sich https://github.com/IsyFact/isyfact-standards/tree/master/isy-batchrahmen/src/main/skripte/bin[in der Bibliothek `isy-batchrahmen`].

Eine sinnvolle Aufteilung bei den Shellskripten ist es, ein technisches Startskript zu erstellen, was von den eigentlichen Batch-Shellskripten zum Aufruf genutzt wird.
Beispiel für ein solches Startskript befinden sich ebenfalls https://github.com/IsyFact/isyfact-standards/blob/master/isy-batchrahmen/src/main/skripte/bin/batch-ausfuehren.sh[in der Bibliothek `isy-batchrahmen`].

Dieses Startskript soll in der Batch-Anwendung unter `<batch-projekt>/src/main/resources/bin` übernommen und mit der richtigen Java-Version versehen werden.

Ein beispielhaftes Shellskript zum Aufruf eines Batches kann dieses Skript dann nutzen und folgendermaßen aussehen:

[[listing-BSPStartBAT]]
.Beispielhaftes Startskript für einen Batch
[source,bash]
----
#!/bin/bash
#
# Parameter für den Erinnerung-Batch
#
# -Testmodus <true|false> Flag ob nur simuliert wird oder nicht (optionaler Parameter)
#

BATCH_DIR=`dirname $0`
$BATCH_DIR/batch-ausfuehren.sh -start -cfg /resources/batch/batch-erinnerung-config.properties -Batchrahmen.Ergebnisdatei /tmp/erinnerung_out.xml $1 $2
----

Bei der betrieblichen Konfiguration wird nicht zwischen dem Deployment als Web-Anwendung und dem Deployment als Batch unterschieden: Es werden jeweils dieselben betrieblichen Konfigurationsdateien verwendet.
Damit der Betrieb Anpassungen dieser Dateien nicht zweimal durchführen muss, wird die betriebliche Konfiguration mit der Web-Anwendung deployt.
Vor dem Deployment des Batch-Pakets muss die Web-Anwendung deployt sein.
Falls der Batch nicht auf dem Server der Web-Anwendung läuft, muss die Konfigurationsdatei der Web-Anwendung vor der Installation des Batches auch auf diesem Server verfügbar gemacht (z.B. gemountet oder kopiert) werden.
Beim Deployment des Batch-Pakets werden über symbolische Links diese betriebliche Konfigurationsdatei referenziert.

[[rueckgabewerte-des-batchrahmens]]
=== Rückgabewerte des Batchrahmens

Der Batchrahmen endet mit einem Return-Code und erzeugt optional zusätzlich noch ein ausführliches Verarbeitungsergebnis in Form einer Ergebnisdatei im XML-Format.
Die Ergebnisdatei ist eine *fachliche Datei*, sie enthält keine betrieblichen Informationen.
Alle betrieblichen Informationen über Ausführung des Batches werden in die Logdatei geschrieben, sodass der Betrieb nur diese Datei betrachten muss.
Es gibt keine weiteren betriebsrelevanten Dateien neben der Logdatei.

Der Pfad der Ergebnisdatei wird über einen Konfigurationsparameter des Batches festgelegt (siehe
Kapitel <<konfigurationsdatei-und-kommandozeilen-parameter>>). Ist dieser Parameter nicht vorhanden, so wird auch keine Ergebnisdatei geschrieben.
Die Ergebnisdatei hat den folgenden Aufbau:

[[table-FormAusDat]]
.Format der Ergebnisdatei
[cols="4m,2m,1,6",options="header"]
|====
|XML-Pfad |Attribut |Typ |Bedeutung
|Batch-Ergebnis | | |Root-Tag des Batch-Ergebnisses
|Batch-Ergebnis / Start |Datum |Text |Datum des Starts des Batchlaufs
|Batch-Ergebnis / Start |Uhrzeit |Text |Uhrzeit des Starts des Batchlaufs
|Batch-Ergebnis / Start |BatchID |Text |Die Batch-ID des Batchlaufs
|Batch-Ergebnis / Start |Parameter |Text |Die Parameter des Batchlaufs
|Batch-Ergebnis / Meldungen | | |Liste von Meldungen (Fehler, Warnungen oder Informationen)
|Batch-Ergebnis / Meldungen / Meldung |ID |Text |ID des Eintrags (z.B. Fehlernummer)
|Batch-Ergebnis / Meldungen / Meldung |Typ |Text |Typ des Eintrags: F, W, I
|Batch-Ergebnis / Meldungen / Meldung |Text |Text |Text des Eintrags, z.B. Fehlertext
|Batch-Ergebnis / Meldungen / Meldung |Satz |Text a|
Der fachliche Schlüssel des Hauptsatzes, dessen Verarbeitung diese Meldung verursacht hat.
Es ist zu beachten, dass ein technischer Schlüssel an dieser Stelle nicht ausreichend ist, da der Fachbereich und der Betrieb
mit diesem technischen Schlüssel nichts anfangen können.

Falls es nicht möglich ist, den fachlichen Schlüssel des Hauptsatzes an dieser Stelle zu ermitteln bzw.
wenn dies nur auf Kosten der Laufzeit möglich ist, dann ist mit dem Fachbereich und dem Betrieb frühzeitig zu klären,
ob an dieser Stelle ein anderer Schlüssel ausgegeben werden kann.
|Batch-Ergebnis / Statistik | | |Liste von statistischen Daten, die während des Batchlaufs ermittelt wurden.
|Batch-Ergebnis / Statistik / Statistik-Eintrag |ID |Text |ID des Statistik-Eintrags
|Batch-Ergebnis / Statistik / Statistik-Eintrag |Text |Text |Klartext des Eintrags, z. B. „Anzahl gelöschter Datensätze“
|Batch-Ergebnis / Statistik / Statistik-Eintrag |Wert |Text |Statistischer Wert, z. B. Anzahl der gelöschten Datensätze
|Batch-Ergebnis / Ende |Datum |Text |Datum des Endes des Batchlaufs
|Batch-Ergebnis / Ende |Uhrzeit |Text |Uhrzeit des Endes des Batchlaufs
|Batch-Ergebnis / Return-Code |RC |Text |Return-Code der Batch-Verarbeitung
|Batch-Ergebnis / Return-Code |Text |Text |Den Return-Code zugeordneter Text
|====

Beispiel für ein Batch-Protokoll:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<Batch-Ergebnis>
    <Start BatchID="GenerischeAnwendungLoeschBatch" Datum="2017-01-30" Uhrzeit="09:33:53" Parameter="-start -cfg /resources/batch/batch-loeschen-config.properties -Batchrahmen.Ergebnisdatei loeschen-batch_out.xml"/>
    <Meldungen>
        <Meldung ID="COMMIT" Typ="I" Text="Checkpoint geschrieben."/>
        <Meldung ID="ENDE" Typ="I" Text="Batch beendet."/>
    </Meldungen>
    <Statistik>
        <Statistik-Eintrag ID="ANZAHL_GELOESCHT" Text="Anzahl gelöschter generischer Anwendungen" Wert="5"/>
    </Statistik>
    <Ende Datum="2017-01-30" Uhrzeit="09:33:58"/>
    <Return-Code RC="0" Text="Verarbeitung ohne Fehler durchgeführt."/>
</Batch-Ergebnis>
----

Zur Auswertung der Ergebnisdatei können XSLT-Stylesheets verwendet werden, die die Ergebnisdatei in eine Textdatei bzw.
in HTML umwandeln.
Es handelt sich hierbei um eine fachliche Transformation der Daten mit dem Ziel, diese für den Fachbereich zu filtern,
zu aggregieren oder in einem bestimmten Format zu Weiterverarbeitung bereitzustellen.

Wenn die Verarbeitung erfolgreich beendet wurde, endet der Batchrahmen mit dem Return-Code 0. Er endet mit einem anderen
Return-Code, falls der Batch mit einem Fehler beendet wurde oder gar nicht gestartet werden konnte.
Bei Fehlern in den "Ausführungsbeans" kann der zurückzugebende Return-Code über die aufgetretenen Exceptions bestimmt
werden (siehe Kapitel <<informationen-zum-batch-benutzer-bereitstellen>>).

Pro Batch müssen die möglichen Rückgabewerte definiert werden.
Die folgenden Werte sind reserviert und müssen von jedem Batch zurückgegeben werden, wenn das entsprechende
Ereignis eingetreten ist:

[[table-GenRetCodeBatCanv]]
.Allgemeine Return-Codes des Batchrahmens
[cols=">1,5",options="header"]
|====
|Return-Code |Bedeutung
|0 |Verarbeitung ohne Fehler durchgeführt
|1 |Verarbeitung mit Fehlern durchgeführt
|2 |Verarbeitung mit Fehlern abgebrochen
|3 |Batch konnte wegen Fehlern in den Aufrufparametern nicht gestartet werden
|4 |Batch konnte wegen Fehlern in der Batch-Konfiguration nicht gestartet werden
|143 |Batch wurde vom Benutzer abgebrochen.
|144 |Batch wurde durch die Überschreitung der konfigurierten maximalen Laufzeit abgebrochen.
|====

[[testmodus]]
=== Testmodus

Der Batch im Testmodus arbeitet analog zum normalen Wirkbetrieb, jedoch werden keine Änderungen an Datenbeständen der Anwendung oder der Nachbarsysteme durchgeführt.
Der Testmodus ist für den Betrieb wichtig, um Abschätzungen der Laufzeit durchführen zu können und somit den Batchbetrieb planen können.
Weiter ist der Testlauf für Bereinigungsläufe wichtig, da so der Fachbereich sehen kann, welche Änderungen durch den Bereinigungslauf ausgeführt werden würden.

In diesem Kapitel werden Architekturmuster zur Umsetzung des Testmodus beschrieben:

* Der Batch arbeitet wie im Wirkbetrieb und statt der Commits findet immer ein Datenbank-Rollback statt (siehe
Kapitel <<testmodus-mit-rollback>>).
* Die Batch-Logik wird ausgeführt, jedoch finden keine Schreiboperationen in der Datenbank oder Aufrufe von
Nachbarsystemen statt, welche Änderungen in deren Datenbestand zur Folge hätten (siehe
Kapitel <<testmodus-ohne-schreiboperationen>>).

[[testmodus-mit-rollback]]
==== Testmodus mit Rollback

Dieses Muster sieht vor, dass bei der Batchverarbeitung statt eines Commits ein Rollback ausgeführt wird, sodass die Änderungen, die durch den Batch erzeugt werden, nicht in die Datenbank geschrieben werden.
Das Muster ist für datenbankorientierte Batches gut geeignet, die keine Änderungen an Nachbarsystemen erfordern.

Einige Batches vermerken ihren Arbeitsfortschritt in der Datenbank.
Damit der Batch trotz Rollback nicht in eine Endlosschleife gerät, darf diese Änderung nicht zurückgerollt werden.
Dies kann wie folgt umgesetzt werden:

Der Batch schreibt zu Beginn die IDs aller zu verarbeitenden Sätze in eine gesonderte „Task“-Tabelle.
In jedem Schritt ermittelt der Batch einen Satz aus der Task-Tabelle, löscht diesen und verarbeitet den zugehörigen Datensatz.
Im Testmodus wird das Löschen des Tasks in einer separaten Transaktion durchgeführt und so nicht zurückgerollt.

Folgendes Code-Beispiel demonstriert dieses Muster:

[source,java]
----
public VerarbeitungsErgebnis verarbeiteSatz() throws BatchAusfuehrungsException {
    MeinBatchTask task = meinBatchTaskDao.leseEintrag();
    meinBatchTaskDao.loesche(task);

     // Wenn Testmodus, neue Transaktion starten
    TransactionStatus txStatus = null;
    if (testmodus) {
        txStatus = transactionManager.getTransaction(
            new DefaultTransactionDefinition(TransactionDefinition.PROPAGATION_REQUIRES_NEW));
        txStatus.setRollbackOnly();
    }

    fristenkontrolle.pruefeFrist(task.getSatznummer());

    // Wenn Testmodus, Transaktion zurücksetzen
    if (testmodus) {
        transactionManager.rollback(txStatus);
    }
}
----

Die Umsetzung des Testmodus mit einem Datenbank-Rollback eignet sich vor allem zur Überprüfung der fehlerfreien Durchführung
und bei der Bestimmung der Laufzeit eines Batches.
Zusätzlich ist bei einer entsprechenden Protokollierung nachvollziehbar, welche Datensätze der Batch verarbeitet hat.

[[testmodus-ohne-schreiboperationen]]
==== Testmodus ohne Schreiboperationen

Ein weiteres Konzept für die Umsetzung des Testmodus sieht vor, dass ändernde Operationen in der Datenbank unterbunden werden. Änderungen in der Datenbank oder in Nachbarsystemen werden durch entsprechende If-Abfragen abgefangen.

Dieses Muster ist dann einzusetzen, wenn die Realisierung durch ein Rollback nicht möglich oder angemessen ist.
Durch Tests muss sichergestellt werden, dass nicht trotz Testmodus versehentlich Änderungen durchgeführt werden.

Das Muster ist geeignet, um im Testmodus durch die Auswertung der Batch-Protokolle und Logs die Auswirkungen bzw.
durchgeführten Änderungen eines Batches vorab zu überprüfen.
Es ist nicht geeignet zur Bestimmung der Laufzeit oder für die vollständige Sicherstellung der fehlerfreien Batchausführung, da Fehler bei Schreiboperationen in die Datenbank oder dem Aufruf von Nachbarsystemen nicht auftreten können.

[[ausfuehrungsbeans]]
== Ausführungsbeans

In diesem Kapitel werden Vorgaben für die Ausführungsbeans definiert.

//tag::namenskonvention[]

Analog zu den Anwendungsfällen werden Batch-Klassen mit dem Präfix `Bat` gekennzeichnet.

.Batches: Klassen
[id="table-batclass2",reftext="{table-caption} {counter:tables}"]
[cols="1s,4m",options="header"]
|====
2+|Batches: Klassen
|Schema
|Bat<Batchname>

|Beispiele
|BatLoeschfristPruefen +
BatSendenAllerInformationen
|====

//end::namenskonvention[]

[[keine-transaktionssteuerung-in-einer-ausfuehrungsbean]]
=== Keine Transaktionssteuerung in einer Ausführungsbean

Eine Ausführungsbean darf keine Transaktionen starten oder beenden.
Sämtliche vom Batchrahmen aufgerufenen Operationen (des Interfaces `BatchAusfuehrungsBean`) werden innerhalb einer Transaktion aufgerufen.
Die Ausführungsbean muss sich hiermit nicht befassen.

[[logging-protokollierung-und-statistik-aufrufe-implementieren]]
=== Logging, Protokollierung und Statistik-Aufrufe implementieren

Der Batchrahmen führt Logging nur im Fehlerfall durch.
Die restlichen Informationen müssen durch die Ausführungsbean geloggt, protokolliert oder einer Statistik-Komponente übergeben.

Dazu wird die Ausführungsbean bei allen wichtigen Ereignissen aufgerufen:

* beim Start des Batches,
* beim Schreiben eines Checkpoints,
* beim Beenden des Batches,
* bei der Verarbeitung eines Satzes.

Jeder Batch erhält eine eigene Korrelations-ID.

WARNING: In älteren Versionen des Batchrahmens handelte es sich bei der Korrelations-ID für Batches um die ID des Batches.
Mittlerweile wurde diese durch eine UUID ersetzt.

Zusätzlich erhält jeder zu verarbeitende Satz auch eine eigene Korrelations-ID, welche an die Korrelations-ID des Batches angehängt wird. Die entstehende Korrelations-ID Kette wird dann dem xref:isy-logging:nutzungsvorgaben/master.adoc#mdchelper[MDC] hinzugefügt.

[[fachliche-logik-in-den-komponenten-der-geschaeftsanwendung-implementieren]]
=== Geschäftslogik in den Komponenten der Geschäftsanwendung implementieren

Falls für die Verarbeitung im Batch Geschäftslogik benötigt wird, welche für die Webanwendung nicht benötigt wird, ist diese trotzdem den Fachkomponenten im Anwendungskern hinzuzufügen.
Die Ausführungsbean ruft die Geschäftslogik dort auf.

Auch wenn in Sonderfällen Datenbank-Aufrufe direkt durch die Ausführungsbean ausgeführt werden müssen, ist die sonstige Geschäftslogik an die Fachkomponenten der Geschäftsanwendung zu delegieren.

[[plausibilitaetspruefung-in-der-initialisierung]]
=== Plausibilitätsprüfung in der Initialisierung

Im Rahmen der Initialisierung hat die Ausführungsbean unter anderem die Aufgabe, die Konsistenz und Korrektheit der Eingabedaten zu prüfen.
Dies kann beispielsweise ein erstes Durchlaufen der zu verarbeitenden Datei beinhalten.
Werden hierbei Fehler erkannt, muss ein entsprechender Fehler geworfen werden.

[[in-initialisierung-schluessel-lesen-satz-verarbeitung-ueber-lookups]]
=== In Initialisierung Schlüssel lesen, Satz-Verarbeitung über Lookups

Falls die zu verarbeitenden Sätze eines Batches das Ergebnis einer Datenbank-Query sind, ist folgendermaßen vorzugehen:

* In Rahmen der Initialisierung ist die Query über eine Fachkomponente abzusetzen.
Diese Query soll die (fachlichen) Schlüssel von Entitäten, nicht die Entitäten selbst auslesen.
* Die zurückgegebenen Schlüssel sind in einer Liste zu speichern und die Query ist zu schließen.
* Beim Aufruf für eine Satzverarbeitung ist die Entität über ihren Schlüssel aus der Datenbank auszulesen und die Verarbeitung durchzuführen.

Dies bietet gegenüber dem Auslesen von Entitäten in der Query folgende Vorteile:

* Würden Entitäten ausgelesen, wären diese nach einem Commit während der Verarbeitung nicht mehr mit einer Transaktion
verbunden. +
Hibernate liest Entitäten bereits bei der `hasNext()`-Abfrage eines Resultset-Iterators ab.
So kommt es bei Checkpoints zwangsläufig zu toten Entitäten.
+
NOTE: Falls (in einem ungewöhnlichen Sonderfall) mit `ResultSet`-Iteratoren gearbeitet werden muss, so sollte https://docs.jboss.org/hibernate/stable/orm/userguide/html_single/Hibernate_User_Guide.html#hql-api-incremental[mit
`ScrollableResults` gearbeitet werden].
+
* Durch das Ablegen der Schlüssel in einer Liste ist die Gesamtanzahl der Datensätze bekannt.

[[informationen-zum-batch-benutzer-bereitstellen]]
=== Informationen zur Authentifizierung bereitstellen

Batches müssen beim Start authentifiziert und autorisiert werden, bevor der fachliche Teil der Batchverarbeitung starten kann.
Der Batchrahmen fordert, dass in der BatchKonfiguration zur Batch spezifischen `Batch-ID` das neue Property `oauth2ClientRegistrationId` hinzugefügt wird, dessen Wert als Indirektion auf eine `ClientRegistration` führt, um den Batch über den Baustein `isy-security` zu authentifizieren.

[[fehlerbehandlung-in-ausfuehrungsbeans-durchfuehren]]
=== Fehlerbehandlung in Ausführungsbeans durchführen

Die Batches sind möglichst robust zu konstruieren: Falls auf ein fachliches Problem in der Ausführungsbean reagiert werden kann, sollte dies getan werden.

Der Batchrahmen unterstützt beispielsweise _nicht_ das Auslassen von Datensätzen im Fehlerfall (etwa für eine Verarbeitung im nächsten Batch). Falls dies umgesetzt werden soll, ist eine entsprechende Verarbeitung in der Ausführungsbean zu implementieren.

Wenn eine Ausführungsbean einen Fehler wirft, so muss dies eine `BeanAusfuehrungsException` oder ein davon erbender Fehler sein.
In diesen Exceptions ist es möglich, den Return-Code des Batches zu definieren.
Die Return-Codes sind für den konkreten Batch zu konfigurieren und müssen den Vorgaben in
Abschnitt <<rueckgabewerte-des-batchrahmens>> entsprechen.

Wichtig ist, dass ein Batch bei einem Fehler, den der Batch nicht behandeln kann, abbricht und nicht endlos weiter läuft.
Dieses Vorgehen ermöglicht es dem Betrieb, die Ursache des Fehlers zu korrigieren und den Batch neu zu starten.

[[beispiele-satzverarbeitung]]
=== Beispiele Satzverarbeitung

Abschließend ist in die beispielhafte Satzverarbeitung in einer Batch-Ausführungsbean zu sehen.
Die gezeigte Satzverarbeitung setzt den Testmodus um, die Anwendungslogik ist weiterhin im Anwendungskern umgesetzt und sie übernimmt Logging, Protokollierung und Statistik-Zählung.

.Beispiel: Satzverarbeitung
[source,java]
----
@Override
public VerarbeitungsErgebnis verarbeiteSatz() throws BatchAusfuehrungsException {
    // Hole nächsten Task, wenn vorhanden.
    if (CollectionUtils._isEmpty_(vorgangsIds)) {
        return new VerarbeitungsErgebnis(null, true);
    }
    int vorgangsId = vorgangsIds.remove(vorgangsIds.size() - 1);

    // Wenn Testmodus, neue Transaktion starten
    TransactionStatus txStatus = pruefeStartSimulation();

    // Laden des Vorgangs und Aufruf der AWK Komponente
    // zum Versenden der Mitteilung
    VorgangRo vorgang = vorgangsverwaltung.leseVorgang(vorgangsId);
    Antragsnummer antragsnummer = vorgang.getAntragsnummer();
    log.debug("Versende Erinnerung zur Anfrage für Antragsnummer: " + antragsnummer + ".");

    // Versende Erinnerung
    try {
        xxxBeteiligung.versendeErinnerungsnachricht(antragsnummer, vorgangsId);
        getBatchProtokoll().ergaenzeMeldung(
            new VerarbeitungsMeldung(String._valueOf_(vorgangsId), antragsnummer.toString(),
                MeldungTyp._INFO_, "Antragsnummer: " + antragsnummer));
        statistikErinnerungVersendet.erhoeheWert();
    } catch (AkteGesperrtException e) {
        getBatchProtokoll().ergaenzeMeldung(
            new VerarbeitungsMeldung(String._valueOf_(vorgangsId), antragsnummer.toString(),
                MeldungTyp._WARNUNG_, e.getFehlertext()));
    }

    // Wenn Testmodus, Transaktion zurücksetzen
    pruefeEndeSimulation(txStatus);
    return new VerarbeitungsErgebnis(String._valueOf_(vorgangsId), false);
}
----

[[sonderfall-blockloeschung]]
==== Sonderfall Blocklöschung

Es ist nicht zwingend erforderlich, dass in einem Satz nur eine einzelne Aktion (beispielsweise eine Löschung) durchgeführt wird.
Bei großen Datenmengen kann es durchaus Sinn sinnvoll sein, pro Satz eine bestimmte Anzahl Datensätze auf einmal zu verarbeiten, wie im folgenden Codebeispiel zu sehen ist.
Die Variable `blockgroesse` ist dabei konfigurativ zu setzen.

Wichtig ist in so einem Sonderfall, dass das <<standard-konfigurationsparameter,Commit-Intervall>> des Batches entsprechend niedrig eingestellt ist, da ansonsten (_Blockgröße_ * _Commit-Intervall_) Datensätze mit einer Transaktion verarbeitet werden.

.Beispiel: Sonderfall Blocklöschung
[source,java]
----
@Override
public VerarbeitungsErgebnis verarbeiteSatz() throws BatchAusfuehrungsException {
    log.debug("Lösche Nachrichten vor " + fristdatum + " (Blockgröße " + blockgroesse + ").");

    // Wenn Testmodus, neue Transaktion starten
    TransactionStatus txStatus = pruefeStartSimulation();
    int anzahlGeloeschterEintraege =
        nachrichtenverwaltung.loescheNachrichtenOhneAkte(fristdatum, blockgroesse);
    log.debug(anzahlGeloeschterEintraege + " Nachrichten gelöscht.");
    geloeschteNachrichtenStatistik.setWert(
        geloeschteNachrichtenStatistik.getWert() + anzahlGeloeschterEintraege);

    // Wenn Testmodus, Transaktion zurücksetzen
    pruefeEndeSimulation(txStatus);
    return new VerarbeitungsErgebnis(null, anzahlGeloeschterEintraege < blockgroesse);
}
----

[[sonderfall-eigenstaendige-transaktionssteuerung]]
==== Sonderfall eigenständige Transaktionssteuerung

Unter bestimmten Umständen kann es notwendig sein, die Transaktionssteuerung des Batchrahmens zu umgehen.
Dies ist beispielsweise der Fall, wenn ein in der Persistenzschicht auftretender Fehler aus der Datenbank ignoriert werden soll.
Das Auftreten einer solchen Exception führt dazu, dass die Transaktion nur noch zurückgerollt werden kann, selbst wenn die Exception gefangen und ignoriert wird.

Um dieser Problematik zu begegnen, kann in der Satzverarbeitung selbst die Transaktionsklammer nur für einen Satz geöffnet und nach der Verarbeitung entweder committed oder zurückgerollt werden.

In diesem Fall sollte das <<standard-konfigurationsparameter,Commit-Intervall>> des Batchrahmens entsprechend hoch konfiguriert werden, um unnötige Commits zu vermeiden, auch wenn in dieser Transaktion nichts passiert.
