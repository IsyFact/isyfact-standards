= Services

include::documentation-guide::partial$licence.adoc[]

IT-Systeme kommunizieren auf Basis von Services.
Wenn ausschließlich IT-Systeme innerhalb der Systemlandschaft miteinander kommunizieren, spricht die Referenzarchitektur von *interner Servicekommunikation*.
Wenn die Kommunikation auch Systeme einschließt, die außerhalb liegen, verwendet die Referenzarchitektur den Begriff *externe Servicekommunikation*.

[[servicekommunikation-intern-extern]]
.Interne und externe Servicekommunikation
image::software-technisch/servicekommunikation.dn.svg[]

IT-Systeme tauschen in der Kommunikation untereinander Daten aus.
Diese lassen sich in Metadaten und Nutzdaten unterteilen.

*Metadaten* können technischer oder fachlicher Natur sein.
Sie sind nicht mit einer konkreten Anfrage verknüpft und werden in der Regel mit jedem Aufruf einer Schnittstelle übertragen.
Zu den Metadaten gehören u.a.:

* Daten zu übergreifenden Aspekten der Servicekommunikation wie z.B. Caching oder das Aushandeln von Formaten,
* IDs zum Tracing von Service-Aufrufen,
* Daten zur Authentifizierung und Autorisierung, oder
* Metadaten dritter Systeme, die durchgeschleift werden.

Metadaten werden in der Regel in Klartext übertragen und nicht verschlüsselt oder anderweitig kodiert.

[IMPORTANT]
====
Die Verwendung von externen Standards bleibt davon unberührt.
So überträgt der Standard OAuth 2 beispielsweise Informationen zur Autorisierung einer Anfrage BASE64-kodiert.
====

Die Übertragung von Metadaten geschieht in der Regel über Schlüssel-Wert-Paare (_key-value pairs_), z.B. in HTTP-Headern oder JMS-Properties.

.icon:university[title=Architekturregel] Benennung von Metadaten
****
Metadaten sind, egal über welches Protokoll sie übertragen werden, *einheitlich benannt*.
Gibt es eine durch einen Standard vorgegebene Benennung, ist diese zu verwenden.
****

Die <<standardisierte-metadaten,folgende Tabelle>> zeigt, welche Metadaten in der IsyFact standardisiert übertragen werden.

[[standardisierte-metadaten]]
.Benennung standardisierter Metadaten
[cols="1s,1m,2",options="header"]
|===
|Metadaten|Benennung|Herleitung

//|Korrelations-ID
//|X-Trace-ID
//|Neue Benennung in Vorbereitung zur Nutzung eines Standardprodukts für Tracing.

|Korrelations-ID +
//(deprecated)
|X-Correlation-Id
|ID zur Nachverfolgung von Aufrufen innerhalb einer Anwendungslandschaft.
//Alte Benennung. +
//*Wichtig:* Anwendungen müssen in der Übergangszeit beide Namen auflösen können.

|Bearer Token
|Authorization
|Vorgabe des Standards OAuth 2.0.
|===

*Nutzdaten* auf der anderen Seite beinhalten alle Daten, die zur Verarbeitung eines konkreten Service-Aufrufs benötigt werden.
Sie bilden die eigentliche, fachliche Schnittstelle und beschreiben sowohl die Daten der Anfrage sowie der Antwort.

Die IsyFact standardisiert die Art und Weise, wie Nutzdaten spezifiziert, dokumentiert und technisch verarbeitet werden.

[[kommunikationsarten]]
== Kommunikationsarten

IT-Systemen stehen mit der IsyFact drei Kommunikationsarten zur Verfügung: synchrone Service-Aufrufe, asynchrone Service-Aufrufe und Service-Aufrufe über Queues.


[[synchrone-service-aufrufe]]
=== Synchrone Service-Aufrufe

Synchrone Service-Aufrufe bieten die Möglichkeit der direkten Kommunikation zwischen zwei IT-Systemen.
Hierbei schickt der Sender eine Anfrage (englisch: _request_) an den Empfänger.
Der Empfänger bearbeitet die Anfrage und schickt eine Antwort (englisch: _response_) an den Sender zurück.
Der Sender wartet auf die Antwort, bevor er seine Verarbeitung fortsetzt.

[[service-aufruf-synchron]]
.Ablauf eines synchronen Service-Aufrufs
image::software-technisch/synchroner-service-aufruf.dn.svg[]

Deswegen sind synchrone Service-Aufrufe in der Regel eine vergleichsweise zeitintensive Operation.
Häufig ist es sinnvoll, Service-Aufrufe nach Möglichkeit einzusparen.
Das Sparen von Aufrufen kann jedoch auch Nachteile in Bezug auf Wartbarkeit bedeuten, wenn beispielsweise Redundanzen oder komplexe Caches implementiert werden müssen.
Die Abwägung darüber muss während der Erstellung des Systementwurfs geschehen.

.icon:university[title=Architekturregel] Verwendung von HTTP für Service-Aufrufe
****
Synchrone Service-Aufrufe finden über das Protokoll *HTTP* statt und werden sowohl zur internen als auch externen Servicekommunikation genutzt.
HTTP-Anfragen bzw. HTTP-Antworten erlauben es an drei Stellen, anwendungsspezifische Daten zu übertragen: in der URL, in den Headern sowie im Body.

[[http-message-aufbau]]
.Aufbau von HTTP-Anfragen bzw. HTTP-Antworten
image::referenzarchitektur:software-technisch/http-messages-aufbau.dn.svg[]
Header enthalten Metadaten.
Der Body enthält Nutzdaten.
Bei Anfragen mittels `GET` und `DELETE`, die keinen Body erwarten, enthalten URL-Parameter Nutzdaten.
****

Allerdings gilt zu beachten, dass URLs (und damit auch die URL-Parameter) an vielen Stellen aufgezeichnet und in Logs geschrieben oder in Caches gehalten werden.
Hierbei sind z.B. datenschutzrechtliche Aspekte zu prüfen, wenn URL-Parameter personenbezogene Daten enthalten.
Im Zweifelsfall ist die Methode `POST` die empfohlene Alternative, um solche Nutzdaten im Body zu übertragen.

[[asynchrone-service-aufrufe]]
=== Asynchrone Service-Aufrufe

Für asynchrone Service-Aufrufe gelten dieselben Vorgaben wie für <<synchrone-service-aufrufe,synchrone Service-Aufrufe>>.
Sie unterscheiden sich im Ablauf dahingehend, dass der Sender nicht aktiv auf die Antwort des Empfängers wartet.
Stattdessen wird die Verarbeitung erst durch die Antwort des Empfängers wieder aufgenommen, z.B. in Form eines Callbacks.

[[service-aufruf-asynchron]]
.Ablauf eines asynchronen Service-Aufrufs
image::software-technisch/asynchroner-service-aufruf.dn.svg[]

Asynchrone Service-Aufrufe können z.B. dann eingesetzt werden, wenn eine länger dauernde Verarbeitung durch den Empfänger eine direkte Rückmeldung unmöglich macht.

[[queueing]]
=== Queueing

Beim Queueing baut ein Message-Broker eine Punkt-zu-Punkt-Verbindung zwischen zwei IT-Systemen auf.
Dies geschieht in Form einer Queue.
Ein IT-System tritt fest als Sender auf, eines als Empfänger.
Der Sender ist nun in der Lage, dem Empfänger über die Queue Nachrichten zu schicken.
Die Nachrichten sind anhand eines zentral definierten Formats strukturiert.
Der Sender enthält keine direkte Antwort vom Empfänger.

[[service-aufruf-queueing]]
.Ablauf der Kommunikation beim Queueing
image::software-technisch/queueing.dn.svg[]

Für das Queueing infrage kommende Message-Broker müssen *JMS* (Jakarta Messaging, ehemals _Java Message Service_) unterstützen.
Queueing wird ausschließlich in der internen Servicekommunikation eingesetzt.

JMS-Nachrichten bestehen aus Header, Properties und einem Body.
Die Properties unterteilen sich noch einmal in applikationsspezifische Properties, die nur für Publisher und Subscriber Bedeutung haben, sowie provider-spezifische und Standard-Properties, die zur Verarbeitung der JMS-Nachrichten durch den Message-Broker gedacht sind.

[[jms-message-aufbau]]
.Aufbau einer JMS-Nachricht
image::software-technisch/jms-message-aufbau.dn.svg[]

Applikationsspezifische Properties enthalten Metadaten.
Der Body enthält Nutzdaten.
Nutzdaten werden im XML-Format übertragen und mittels XSD spezifiziert.

Diese Vorgabe steht vollständig in Einklang mit der JMS-Spezifikation.
Für die Übertragung von Nutzdaten sieht die JMS-Spezifikation fünf Formate vor.
Die Architekturvorgabe sieht die alleinige Nutzung der Ausprägung `TextMessage` vor, die Nutzdaten als Zeichenkette erwartet.

[NOTE]
====
Weitere Details zu JMS-Nachrichten finden sich in der JMS-Spezifikation im Kapitel https://jakarta.ee/specifications/messaging/3.0/jakarta-messaging-spec-3.0.html#jakarta-messaging-message-model[3. Jakarta Messaging message model].
Besonders relevant für die Referenzarchitektur sind die Abschnitte https://jakarta.ee/specifications/messaging/3.0/jakarta-messaging-spec-3.0.html#jakarta-messaging-messages[3.3. Jakarta Messaging messages] sowie https://jakarta.ee/specifications/messaging/3.0/jakarta-messaging-spec-3.0.html#jakarta-messaging-message-body[3.11. Jakarta Messaging message body].
====

== Kommunikation mit externen Systemen

Die Kommunikation mit xref:glossary::terms-definitions.adoc#externes-system[externen Systemen] basiert auf Web-Services.
Wird ein Service von einem externen System angeboten, wird er als *externer Service* bezeichnet.
Im Folgenden werden zwei Szenarien betrachtet:

*Aufruf von Services der Systemlandschaft*: Durch die Systemlandschaft wird externen Systemen die Schnittstelle eines Backends in Form eines Web-Services zur Verfügung gestellt.
Hierbei definiert das Backend selbst keinen Web-Service.
Vielmehr definiert das Backend, wie bei der internen Kommunikation auch, eine Schnittstelle.
Diese Schnittstelle wird dann durch ein eigenständiges IT-System als Web-Service exportiert.
Dieses IT-System wird als *Service-Provider* bezeichnet.
Für jede Schnittstelle, die als Web-Services exportiert werden soll, muss ein eigener Service-Provider definiert werden.

*Nutzung von externen Services*: Ähnlich wie im vorigen Fall ruft das interne IT-System den externen Service nicht direkt auf.
Es ruft ein eigenständiges IT-System auf, welches den externen Service als Schnittstelle in die Systemlandschaft importiert.
Dieses IT-System wird als *Service-Consumer* bezeichnet.
Das interne IT-System ruft dann lediglich die Schnittstelle des Service-Consumers auf.
Für das interne IT-System ist dieser Aufruf nicht von einem Aufruf zu einem anderen internen IT-System zu unterscheiden.
Für jeden Web-Service, der in die Systemlandschaft importiert werden soll, muss ein eigener Service-Consumer definiert werden.

Die Gesamtheit aller Service-Provider und Service-Consumer wird als xref:glossary::terms-definitions.adoc#glossar-service-gateway[Service-Gateway] bezeichnet.
Die Service-Gateways stellen somit die zentrale Schnittstelle einer IsyFact-Systemlandschaft zur Außenwelt dar.

.Nutzung von Service Gateways zur Kommunikation mit externen Systemen
image::software-technisch/services/kommunikation-externe-systeme.dn.svg[]

Ein Service-Consumer macht diesen "externen Service" als "inneren Service" der Systemlandschaft verfügbar.
Wird ein Service von einem Backend angeboten, so ist das ebenfalls ein "innerer Service".
Wenn ein Service-Provider diesen "inneren Service" einer Anwendung außerhalb der Plattform zugänglich macht, ist dies ein "äußerer Service" der Systemlandschaft.
Die Unterscheidung zwischen "innere" und "äußere" ist analog für die Begriffe "Request" und "Response" zu verwenden.

[[versionierung]]
== Versionierung

Sowie IT-Systeme im Laufe ihres Betriebes Änderungen und Anpassungen durch versionierte Releases erfahren, so unterliegen auch die Services eines IT-Systems den Änderungen und Anpassungen und werden ebenfalls dahingend pro Service versioniert.
Die Versionierung wird auf der Ebene von Services, nicht Service-Operationen ausgeführt, da diese Ebene von ihrer Granularität zu den üblichen fachlichen Änderungen passt.
Für die Versionierung werden Major- und Minor-Versionen genutzt.

Es kann die Notwendigkeit bestehen, Services auch in mehreren Versionen parallel anzubieten, da bei einer Vielzahl an Service-Nutzern nicht alle zeitgleich auf die neue Version eines Service umschalten können.

Es kann vorkommen, dass in _einem_ Systemrelease neue Versionen von _mehreren_ Services ausgeliefert werden.

[[architektur]]
=== Architektur

Backends bieten pro Service-Version eine eigene Service-Schnittstelle an.
Die unterschiedlichen Versionen des Service verwenden alle denselben xref:referenzarchitektur:software-technisch/backend/anwendungskern.adoc[Anwendungskern].
Die für die Versionierung notwendigen Transformationen sind Teil des jeweiligen Services (z.B. das Einfügen eines Standardwerts für neu hinzugefügte Attribute).

Für jede neu bereitgestellte Version eines Services im Backend muss eine neue Schnittstellen-Beschreibung erstellt werden, die dem Anwender:

* alle Änderungen in der neuen Service-Version beschreibt.
Die Beschreibung beinhaltet dabei eine vollständige Liste aller Service-Änderungen mit konkreten Details, wie zum Beispiel welche Service-Operationen neu hinzukamen, entfallen sind oder geändert (z.B. Anpassung von Eingabe- und Ausgabeparameter) wurden.
Dies muss so beschrieben sein, dass der Leser sich ein genaues Bild der Versionsänderungen machen kann, um seine Anwendung und Implementierung zur Nutzung der verschiedenen Service-Versionen anzupassen.

* die Unterscheidung von kompatiblen Änderungen zu inkompatiblen Änderungen zur Vorgänger-Version verdeutlicht, um eine bessere versionsbezogene Einschätzung der Service-Nutzung und die ggf. damit einhergehenden Anpassungen des Service-Consumers machen zu können.

** Als kompatible Änderungen bezüglich der Vorgängerversion wird das Hinzufügen neuer Servicemethoden, neuer optionaler Attribute, geänderte Default-Werte, o.ä. eingestuft.
Eine neue Service-Version mit ausschließlich kompatiblen Änderungen, bedarf nur einer neuen Minor-Version und kann direkt vom Aufrufer ohne Anpassungen verwendet werden.

** Als inkompatible Änderungen bezüglich der Vorgängerversion wird das Löschen und Umbennen von Servicemethoden oder Attributen, das Ändern von Attributen von optional auf mandatorisch, die Änderung von Attribut-Datentypen bzw. -Datenstrukturen, o.ä. gewertet.
Eine neue Service-Version mit mindestens einer inkompatiblen Änderung, bedarf einer neuen Major-Version und erfordert Anpassungen auf Seiten des Aufrufers.

Diese Unterscheidung zwischen kompatibler und inkompatibler Änderungen ist notwendig, damit der Nutzer für sich entscheiden kann, ob er anhand der Versionsunterschiede ein Upgrade auf die neue Version für seine Nutzung durchführen muss oder ob er die Nutzung der alten Version bei für ihn rein kompatiblen Änderungen beibehalten kann.

Führen Service-Änderungen und den damit einhergehenden Schnittstellenänderungen zu einer komplexen Transformationslogik, um zwischen alter Version und neuer Version eine Kompatibilität herzustellen, dann kann es auch notwendig sein, das Backend vor dem Anwendungskern mit der Fachkomponente um zusätzliche Komponenten pro Version in der Serviceschicht so zu erweitern (siehe xref:image-archversServ[]), dass die gesamt Logik der komplexen Transformationen nur dort enthalten sind.

Die Entscheidung dafür ist im Systementwurf zu dokumentieren.

Externe Services werden durch Service-Gateways bereitgestellt.
Die Versionierung eines Service muss also auch auf Ebene des Service-Gateways durchgeführt werden.
Ein Service-Gateway ist ein rein technischer Protokoll-Wandler, der Web-Services in interne Schnittstellen konvertiert.
Im Service-Gateway erfolgt daher immer nur ein einfaches Mapping auf die entsprechenden Service-Schnittstellen-Version der angebundenen Backend-Komponenten in der Service-Schicht.
Der Ausgleich der Versionsunterschiede erfolgt ausschließlich im Backend - sprich Service-Schicht und/oder Anwendungskern - und nicht im Service-Gateway.
Es ist möglich, pro Service-Version ein eigenes Service-Gateway zu erstellen.

[[image-archversServ]]
.Architektur versionierter Services
image::referenzarchitektur:software-technisch/services/versionierung.dn.svg[]

[[abwaertskompatible-erweiterung]]
=== Abwärtskompatible Erweiterung eines Services

Erfährt ein Service in der Version 1.0 nur abwärtskompatible Änderungen, wie neu hinzugekommene Servicemethoden, zusätzliche Attribute, o.ä., dann wird dies über eine neue Minor-Version (1.1) bei gleichbleibender Major-Version des Service bewerkstelligt.
Das Backend bietet im Anwendungskern als Fachkomponente dafür aber anstatt zwei parallel betriebene Serviceversionen 1.0 und 1.1 lediglich die eine neue Version an, die die Logik für Version 1.0 inklusive der Änderungen für Version 1.1 beinhaltet.
Denn bei rein abwärtskompatiblen Änderungen einer Serviceversion muss diese neue Version sicherstellen, dass Service-Consumer, die den Service allein auf Basis der Major-Versionsangabe - hier Version 1 - auswählen und aufrufen, auch mit einem Aufruf der Service-Version 1.0 fehlerfrei arbeiten.

[[image-minorversServ]]
.Beispiel minor versionierter Service
image::referenzarchitektur:software-technisch/services/minor-versionierung.dn.svg[]

Das bedeutet zum Beispiel in einem Service wird mit Version 1.1 ein zusätzliches Attribut für MethodeA eingeführt gegenüber der Version 1.0.

Wenn nun ein Service-Consumer die Service-MethodeA gemäß Major-Version 1 aufruft und dabei aber die Servicesignatur von Version 1.0 erfüllt, dann ist das neu hinzugekommene Attribut gemäß Version 1.1 nicht in dem Aufruf des Clients enthalten.
Die Versions-Transformation in der Service-Komponente eines Aufrufs der Service-MethodeA gemäß Version 1.0 muss nun das fehlende Attribut ergänzen und mit einem Default-Wert initialisieren, bevor die Verarbeitung in der Fachkomponente mit Version 1.1 im Anwendungskern stattfindet.

Werden die beiden Service-Versionen durch ein Service-Gateway nach außen verfügbar gemacht, existiert dort ein Service-Gateway zur Major-Version V1 mit einem Mapping auf die Service-Komponente V1.1 der Serviceschicht.
Eingehende Aufrufe mit passender Signatur zur Version 1.0 und V1.1 werden vom Service-Gateway zur Service-Komponente der Version 1.1 geroutet.
In dieser Service-Komponente erfolgt die Versionstransformation für einen Aufruf der Fachkomponente mit Version 1.1 im Anwendungskern.
Innerhalb des Service-Gateways existiert keine Transformationslogik, d.h. die Abbildung von Version 1.0 auf 1.1 findet erst im Backend in der Service-Schicht statt.

[[inkompatible-veraenderung]]
=== Inkompatible Veränderung eines Services

Bei inkompatiblen Veränderungen eines Service, zum Beispiel durch Wegfall von Servicemethoden, Änderung von Parameterdatentypen in einer bestehenden Servicemethoden Signatur, o.ä. ist es notwendig eine neue Major-Version des Service bereit zu stellen - siehe xref:image-major1versServ[].

[[image-major1versServ]]
.Beispiel major versionierter Service
image::referenzarchitektur:software-technisch/services/major-versionierung-1.dn.svg[]

Da nicht alle Clients gleichzeitig ihre Anpassungen an eine neu bereitgestellte Service-Version durchführen können, oder weil die Änderungen im Service zum Beispiel ein vollständiger Technologie-Wechsel beinhalten, bedarf es der Notwendigkeit mehrere Service-Major-Versionen parallel im Backend in allen drei Schichten zu betreiben.

Daraus erwächst die Anforderung, dass ein Client die von ihm aufzurufende Service-Version auswählen können muss.
Dies geschieht im Allgemeinen dadurch, dass im Backend die Major-Versionsangabe im Namen des Service-Moduls, in den Servicemethoden als Prefix bzw. im Pfad des Service-Endpunktes enthalten ist.
Mit Angabe der Service-Version beim Aufruf im Client wird die Wahl der gewünschten Service-Version getroffen, die im Backend ausgeführt werden soll.

Ruft ein Client nun einen Service mit einer Version auf, die im Backend nicht mehr zur Verfügung steht - zum Beispiel Wegfall von V1 wie in xref:image-major2versServ[] gezeigt, so bekommt der Client eine Fehlermeldung, dass dieser Service mit der gewünschten Version V1 nicht mehr erreichbar ist.

[[image-major2versServ]]
.Beispiel Wegfall major versionierter Service
image::referenzarchitektur:software-technisch/services/major-versionierung-2.dn.svg[]

Auch bei komplexeren Anforderungen kann es passieren, dass Services im Anwendungskern so umgestaltet werden müssen, dass unterschiedliche Versions-Aufrufe nicht mehr aufeinander abgebildet werden können.
In solchen Fällen wird eine neue Service-Version eingeführt, während die alte Service-Version noch verfügbar bleiben muss, um die inkompatiblen Verarbeitungslogiken im Anwendungskern parallel zu unterstützen.
Auch hier enthält das Service-Gateway keine Geschäftslogik.

IMPORTANT: Eine Versionierung ist nur dann sinnvoll, wenn kleine Änderungen an der Schnittstelle zwischen den Versionen auftreten.
Für den Fall, dass sich die Schnittstelle sowohl syntaktisch als auch semantisch grundlegend ändert, sollte anstatt einer neuen Version besser eine eigenständige, neue Schnittstelle entstehen.

