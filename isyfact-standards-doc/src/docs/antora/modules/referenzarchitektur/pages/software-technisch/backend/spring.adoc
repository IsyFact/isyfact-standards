= Verwendung von Spring

include::documentation-guide::partial$licence.adoc[]

Das Spring-Framework ist ein leichtgewichtiges Java Framework, welches sehr verständlich und leicht zu verwenden ist.
Zu den Kernkonzepten von Spring gehören Inversion of Control (IoC) und Dependency Injection (DI).

IoC ist ein Umsetzungsparadigma und bedeutet Steuerungsumkehr. Im Kontext des Spring Frameworks versteht man darunter, dass das Framework die Erstellung des Objektnetzes (_Spring-Beans_) anstelle des Entwicklers übernimmt.

_Spring-Beans_ sind Java Objekte, die durch den Spring IoC Container instanziiert und verwaltet werden. Der IoC Container erstellt _Spring-Beans_ anhand einer Bean Definition, die der Entwickler in Form von Annotationen oder xml Konfiguration bereitstellt.

Die folgenden Inhalte beschreiben die Nutzung von Spring für die allgemeine Umsetzung von Backends.
Die Nutzung spezifischer Features von Spring sind Bestandteile der folgenden Bausteine:

* Konfiguration der Persistenzschicht: beschrieben in den xref:isy-persistence:nutzungsvorgaben/umsetzung-persistenzschicht.adoc[Nutzungsvorgaben JPA/Hibernate],
* Konfiguration des Logging: beschrieben in den xref:isy-logging:nutzungsvorgaben/master.adoc[],
* Bereitstellung von Metriken zur Überwachung: beschrieben im xref:isy-ueberwachung:konzept/master.adoc[].

[[konfiguration-von-spring]]
== Vorgaben zur Konfiguration mit Spring
Das Prinzip „Convention over Configuration“ in Spring Boot vereinfacht die Einrichtung und Entwicklung durch sinnvolle Voreinstellungen.

Spring Boot vereinfacht die Konfiguration durch:

* https://docs.spring.io/spring-boot/reference/using/auto-configuration.html[*Auto-Konfiguration*]: Spring Boot konfiguriert die Anwendung automatisch auf der Grundlage der hinzugefügten Jar-Abhängigkeiten.
* https://docs.spring.io/spring-boot/how-to/webserver.html[*Eingebetteter Server*]: Spring Boot wird mit einem eingebetteten Server (wie Tomcat) geliefert, der keine explizite Einrichtung erfordert.
* https://docs.spring.io/spring-boot/how-to/properties-and-configuration.html[*Property-Dateien*]: Es verwendet application.properties oder application.yml für externalisierte Konfigurationen.
* https://docs.spring.io/spring-boot/reference/using/build-systems.html#using.build-systems.starters[*Starter POMs*]: Vereinfachte Verwaltung von Abhängigkeiten.

[[Konfiguration-der-Applikationsklasse]]
=== Konfiguration der Applikationsklasse

Der zentrale Ausgangspunkt für die Spring-Konfiguration ist die Applikationsklasse.

Diese wird im Package des Backends (`<org>.<domäne>.<anwendung>.<backend>`) erstellt.

==== Spring Boot @SpringBootApplication Annotation
Die Spring Boot-Annotation @SpringBootApplication wird verwendet, um eine Konfigurationsklasse zu markieren, die eine oder mehrere @Bean-Methoden deklariert und außerdem die automatische Konfiguration und das Scannen von Komponenten auslöst.
Diese Annotation ist äquivalent zur gleichzeitigen Nutzung der Annotationen  '@Configuration', '@EnableAutoConfiguration' und '@ComponentScan'.

==== Spring Boot SpringApplication Klasse
Die Spring Boot SpringApplication-Klasse wird verwendet, um eine Spring-Anwendung aus einer Java-Hauptmethode zu booten und zu starten. Diese Klasse erstellt automatisch den https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html[ApplicationContext] aus dem Klassenpfad, scannt die Konfigurationsklassen und startet die Anwendung.

[[listing-applikationsklasse-mit-springbootapplication-annotation]]
.Applikationsklasse mit `@SpringBootApplication`
[source, java]
----
package de.beispiel.ifanwendung;

@SpringBootApplication // same as @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan
public class IsyFactApplication {

    public static void main(String[] args) {
		SpringApplication.run(IsyFactApplication.class, args);
	}
}
----

Ist eine feinere Kontrolle gewünscht, so können mit `exclude`-Attributen Komponenten von der automatischen Konfiguration https://docs.spring.io/spring-boot/reference/using/auto-configuration.html#using.auto-configuration.disabling-specific[ausgeschlossen] werden.

==== Spring Boot @Configuration Annotation
Die Annotation Spring '@Configuration' zeigt an, dass die Klasse @Bean-Definitionsmethoden hat. So kann der Spring-Container die Klasse verarbeiten und Spring-Beans erzeugen, die in der Anwendung verwendet werden.

==== SpringBoot Konfigurationsklasse
Für jede Schicht wird im Package der Schicht (`<org>.<domäne>.<anwendung>.<schicht>`) parallel zu den Interfaces der Komponentenschnittstellen eine mit `@Configuration` annotierte <<listing-konfigurationsklasse,Konfigurationsklasse>> erstellt.

Externe Spring-Beans, die nicht annotiert werden können, werden in der Konfigurationsklasse der Schicht per `@Bean`-Methoden konfiguriert.


[[listing-konfigurationsklasse]]
.Konfigurationsklasse des Anwendungskerns
[source,java]
----
package de.beispiel.if2anwendung.core;

@Configuration
public class CoreConfig {
    @Bean
    public BeispielBean beispielBean() {
        // ...
    }
}
----

[[konfiguration-von-spring-beans]]
=== Konfiguration von Komponenten
Die Spring-Beans der Komponenten werden mit der Annotation `@Component` bzw. deren Spezialisierungen (`@Repository`, `@Service`, `@Controller` etc.) versehen.

==== Spring Boot @Component Annotation
@Component ist die generische Annotation, die verwendet wird, um eine Klasse als Spring-Bean zu markieren.
Sie wird für jede Klasse verwendet, die als Spring-Bean verwaltet werden soll, unabhängig von ihrer Funktion oder Verantwortung.
Es ist eine allgemeine Annotation und vermittelt keine spezifische Bedeutung über die Rolle oder Funktion der bean.

Obwohl die @Component Annotationen dazu dient, Klassen als Spring-Beans zu kennzeichnen, ist es eine gute Praxis, spezifische Ableitungen für Komponenten zu verwenden, um Ihre Absicht klarer auszudrücken und die Codebasis besser zu organisieren.

Generell gilt, dass jede zentrale und wichtige Klasse als Spring-Bean konfiguriert werden sollte.

==== Spring Boot @Service Annotation
Die Annotation @Service ist eine spezielle Form von @Component. Es ist eine semantische Annotation, die verwendet wird, um Klassen zu kennzeichne die Geschäftsfunktionen implementieren.

Die Komponenten des Anwendungskerns werden mit der Annotation @Service ausgezeichnet.

==== Spring Boot @Controller und @RestController Annotation
Die Annotation Spring Controller ist eine Spezialisierung der Annotation @Component. Die Spring Controller-Annotation wird typischerweise in Kombination mit annotierten Handler-Methoden verwendet, die auf der RequestMapping-Annotation basieren.

===== Spring Controller
Die Spring Controller-Annotation kann nur auf Klassen angewendet werden. Sie wird verwendet, um eine Klasse als Web-Request-Handler zu markieren. Sie wird meist bei Spring MVC-Anwendungen verwendet.

===== Spring RestController
Spring @RestController ist eine Komfort-Annotation, die selbst mit @Controller und @ResponseBody annotiert ist. Diese Annotation wird verwendet, um eine Klasse als Request-Handler für RESTful Web Services zu kennzeichnen.

Die Komponenten der Serviceschicht werden mit den Annotationen @Controller und @RestController ausgezeichnet.

==== Spring Boot @Repository Annotation
Die Spring Repository-Annotation ist eine Spezialisierung der @Component-Annotation.
Die Spring @Repository-Annotation wird verwendet, um anzuzeigen, dass die Klasse einen Mechanismus für Speicherung, Abruf, Suche, Aktualisierung und Löschung von Objekten bereitstellt.

Die Komponenten der Persistenzschicht werden mit den Annotationen @Repository ausgezeichnet.

[[bean-scopes]]
=== Spring-Bean Scopes
Der Bean-Scope definiert den Lebenszyklus und die Sichtbarkeit einer Bean innerhalb des Containers. Er teilt Spring mit, wie viele Instanzen einer bestimmten Bean erstellt werden sollen und wie lange sie verfügbar sein sollen.

SpringBoot bietet mehrere Bean-Scopes, darunter:

* Singleton: Eine Singleton-Bean wird nur einmal erstellt, und
dieselbe Instanz wird für alle Anfragen freigegeben. Sie verbleibt im Kontext der Anwendung, bis die Anwendung heruntergefahren wird. Der Singleton scope ist der Default-Scope in Spring.
* Prototyp: Eine neue Instanz der Prototyp-Bean wird jedes Mal erstellt, wenn sie angefordert wird. Sie ermöglicht die Koexistenz mehrerer Instanzen derselben Bean innerhalb der Anwendung.
* Request: Für jede HTTP-Anfrage wird eine neue Instanz der request-scoped Bean erstellt. Sie ist nützlich, wenn Sie Daten speichern wollen, die für eine einzelne Anfrage spezifisch sind, wie z.B. Informationen zur Benutzersitzung.

Session: Eine neue Instanz der Session-scoped Bean wird für jede Benutzersitzung erstellt. Sie bewahrt den für die Benutzersitzung spezifischen Zustand über mehrere Anfragen hinweg.

Application : Eine neue Instanz der Application-scoped Bean wird einmal
für die gesamte Anwendung erstellt. Sie wird für alle Anfragen und Sitzungen gemeinsam genutzt.

[[beans-standardmaessig-als-singletons-definieren]]
==== Beans standardmäßig als Singletons definieren

Die Spring-Beans einer Anwendung sollen zustandslos sein und werden als Singleton-Beans erzeugt.
Wo technisch erforderlich können auch andere Scopes verwendet werden.

NOTE: Eine genaue Beschreibung der Scopes bietet die https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html[offizielle Spring-Dokumentation].


[[direkte-verwendung-des-spring-frameworks]]
== Vorgaben zur direkten Verwendung von Spring

Neben der Konfiguration der Spring-Beans enthält eine Anwendung in der Regel kaum Abhängigkeiten zu Spring.
Da die benötigten Objekte per Dependency Injection konfiguriert werden, müssen diese nach ihrer Konfiguration lediglich verwendet werden.

In einigen Fällen existieren jedoch weitere Abhängigkeiten:

* Spring-Beans werden per Namen aus dem Anwendungskontext ausgelesen.
* Spring-Beans werden nicht per Dependency Injection, sondern über statische Methoden bereitgestellt.
Hierüber entstehen Abhängigkeiten zur Instanziierungsreihenfolge der Spring-Beans durch Spring.

Für diese Aspekte werden im folgenden Vorgaben aufgestellt.

[[keine-beans-per-namen-auslesen]]
=== Keine Spring-Beans per Namen auslesen

Über den Anwendungskontext könnten Spring-Beans explizit per Namen ausgelesen werden.
Dies ist mit einer Ausnahme verboten: Die Namen von Spring-Beans sollen nicht im Anwendungscode verwendet werden.
Die Ausnahme gilt für den Zugriff von einem Anwendungskontext auf einen anderen (in Zusammenhang mit dem DispatcherServlet).
In diesem Fall ist ein explizites Auslesen nicht zu vermeiden.
Auszulesen ist in diesem Fall keine Komponente des Anwendungskerns, sondern eine weitere Schnittstellen-Bean, welche nur für diesen Zweck verwendet wird.

[[aspektorientierte-programmierung-in-spring]]
== Vorgaben zur aspektorientierte Programmierung in Spring

Es ist möglich, für Spring-Beans Funktionalität in Form von Aspekten zu definieren.
Ihr Einsatz kann über _Pointcuts_ konfiguriert werden.
Pointcuts definieren (etwa über reguläre Ausdrücke) Klassen und Methoden, welche um den Aspekt erweitert werden.

Zu intensive Nutzung kann leicht zu einem schwer durchschaubaren Programmfluss führen.
Deshalb soll AOP nur für folgende Bereichen genutzt werden: die Steuerung von Transaktionen, die Überwachung und die Berechtigungsprüfung.

Explizit nicht benutzt werden soll AOP für die Fehlerbehandlung.

Die Verwendung von AOP für andere Zwecke ist nur in begründeten Ausnahmefällen erlaubt.

[[aop-fuer-transaktionssteuerung-verwenden]]
=== AOP für Transaktionssteuerung verwenden

Für die Transaktionssteuerung ist Spring-AOP mit den dafür vorgesehenen Klassen von Spring einzusetzen.
Die Umsetzung geschieht im xref:software-technisch/backend/anwendungskern.adoc#transaktionssteuerung[Anwendungskern] oder in der xref:software-technisch/backend/serviceschicht.adoc#transaktionssteuerung[Serviceschicht].
Zusammengefasst gilt:

* Instrumentiert werden alle Schnittstellenmethoden des Anwendungskerns.
* Für jeden Aufruf des Anwendungskerns wird eine Transaktion gestartet.
* Falls kein Fehler auftritt, wird die Transaktion abgeschlossen (Commit), sonst zurückgerollt (Rollback).

[[aop-fuer-berechtigungspruefungen-verwenden]]
=== AOP für Berechtigungsprüfungen verwenden

Die Berechtigungsprüfung wird über Spring-AOP mit den vom xref:isy-security:nutzungsvorgaben/master.adoc[Baustein Security] angebotenen Annotationen umgesetzt.

[[aop-nicht-fuer-das-logging-von-exceptions-verwenden]]
=== AOP nicht für das Logging von Exceptions verwenden

Sämtliche in einem Backend geworfenen und nicht behandelten Ausnahmen müssen inklusive ihrer Stack-Traces geloggt werden.
Geloggt wird dies in den Methoden der Schnittstellen-Beans der Serviceschicht.
Hierfür soll Spring-AOP nicht verwendet werden.

Schnittstellen-Beans transformieren die Geschäftsobjekte des Anwendungskerns in Transportobjekte der Schnittstelle.
Die Stack-Traces der Exceptions werden dabei nicht übertragen, da diese internen Informationen dem Aufrufer keinen Mehrwert bieten.
Für das Logging des Backends selbst sind sie jedoch wertvoll.
Statt AOP ist das in der Serviceschicht beheimatete Konstrukt der xref:software-technisch/backend/serviceschicht.adoc#exception-fassade[Exception-Fassade] zu verwenden.

[[dependency-injection]]
== Vorgaben zur Dependency Injection

Um im Anwendungskern das Single-Responsibility-Prinzip umzusetzen, wird auf das Entwurfsmuster _Dependency Injection_ zurückgegriffen.
Dabei werden die Verantwortlichkeiten für den Aufbau des Abhängigkeitsnetzes zwischen den Objekten aus den einzelnen Klassen in eine zentrale Komponente überführt.
Anders als bei der herkömmlichen Vorgehensweise in der objektorientierten Programmierung ist bei der _Dependency Injection_ nicht jedes Objekt selbst dafür zuständig, seine Abhängigkeiten (benötigte Objekte und Ressourcen) zu verwalten.

Die <<table-vergleich-verfahren-dependency-injection,verschiedenen Verfahren der _Dependency Injection_>> sowie ihre Einsatzszenarien verdeutlicht folgende Übersicht:

[[table-vergleich-verfahren-dependency-injection]]
.Vergleich der Verfahren zur Dependency Injection
|===
|DI-Methode |Einsatzszenario |Bemerkung

|Constructor-Injection
|Für alle Spring-Beans, welche keine dynamische Anpassung zur Laufzeit benötigen.
|Kann in Produktiv-Code eingesetzt werden und ist der Standard von Spring.

|Field-Injection
|Vermeidung von Boilerplate-Code
|Darf nicht in Produktiv-Code verwendet werden.

|Method-Injection (Setter-Injection)
|Flexibles Austauschen von Spring-Beans zur Laufzeit
|Nicht immutable. Sollte nur eingesetzt werden, wenn diese Eigenschaft benötigt wird.
|===

[TIP]
====
Da die _Constructor Injection_ diverse Vorteile gegenüber den beiden anderen Techniken liefert, empfiehlt die IsyFact die Verwendung von  <<constructor-injection,_Constructor Injection_>>.
====

[[constructor-injection]]
=== Verwendung von Constructor Injection

Bei der _Constructor Injection_ werden alle Abhängigkeiten einer Klasse über die Konstruktoren von außen injiziert.
Dadurch werden automatisch auch die benötigten Abhängigkeiten definiert, welche der Erzeuger des Objektes zur Verfügung stellen muss.
Dieses Vorgehen hat den Vorteil, dass alle benötigten Abhängigkeiten in der Initialisierungsphase des Objektes zur Verfügung stehen.
Zusätzlich werden durch dieses Verfahren Überprüfungen auf `null` und die Behandlung von nicht aufgelösten Abhängigkeiten unnötig, da die Abhängigkeiten vorhanden sein müssen.

_Constructor Injector_ hilft ebenfalls bei dem Identifizieren von zu vielen Abhängigkeiten zu einem Objekt.
Wenn ein Konstruktor zu viele Argumente aufweist, kann dies ein Zeichen für eine zu große Verantwortlichkeit des Objektes sein.
Ist dies der Fall, sollte an dieser Stelle über ein Refactoring nachgedacht werden.

Ein weiterer Vorteil von _Constructor Injection_ ist, dass die injizierten Abhängigkeiten während der Laufzeit nicht veränderbar sind und so Nebenläufigkeiten und Seiteneffekte vermieden werden.

[[listing-constructor-injection]]
.Verwendung von Constructor Injection
[source,java]
----
@Component
public class SomeBean {

  private final AnotherBean anotherBean;

  public SomeBean(AnotherBean anotherBean) {
    this.anotherBean = anotherBean;
  }

  AnotherBean getAnotherBean() {
    return anotherBean;
  }

}
----
