= Konzept REST-Services: Inhalt


// tag::inhalt[]

[[grundlagen]]
== Grundlagen

REST steht für Representational State Transfer und ist ein Paradigma für die Softwarearchitektur von verteilten Systemen, insbesondere für Webservices (Wikipedia).
Roy Fielding hat in seiner Dissertation die Grundlagen von REST-Services definiert.
Diese lauten wie folgt:

Client-Server::
REST-Services besitzen die Eigenschaften einer Client-Server-Architektur und folgen diesem Architekturstil.

Zustandslosigkeit::
Ein REST-Service speichert zwischen zwei Anfragen keinerlei Zustandsinformationen.
Jede Ressource muss alle Informationen enthalten, die für den Server bzw. Client notwendig sind, um sie verarbeiten zu können.

Caching::
REST-Nachrichten sollen, entweder explizit oder implizit, angeben, ob sie sich für einen Cache eignen oder nicht.

Einheitliche Schnittstelle::
REST-Schnittstellen besitzen vier Eigenschaften, um einheitlich beschaffen und leicht nutzbar zu sein.
+
Jede Ressource ist über einen URI *eindeutig adressierbar*.
Damit geschieht der Zugriff für jeden Client eindeutig und für alle nachvollziehbar.
+
REST-Services können an ihre Clients unterschiedliche *Repräsentationen der Ressourcen* ausliefern, z. B. in verschiedenen Sprachen oder Formaten.
Die Veränderung einer Ressource erfolgt nur über eine dieser Repräsentationen.
+
Jede Anfrage muss alle Informationen zu ihrer Verarbeitung mitliefern, also *selbstbeschreibend* sein.
Beispiele dazu sind das explizite Kennzeichnen des übertragenen Formats oder die Verwendung von HTTP-Methoden.
+
*Hypermedia as the Engine of Application State (HATEOAS)*:
REST-Services dürfen bei ihren Clients nur minimale Kenntnisse der Schnittstelle voraussetzen.
Insbesondere das Navigieren zwischen Ressourcen sollte über Links geschehen, die Teil vorausgehender Ressourcen sind.
Die Umsetzung von HATEOAS erzeugt so eine Navigation zwischen Ressourcen ähnlich zur Navigation zwischen Webseiten über Hyperlinks.

Mehrschichtige Systeme::
Für Aufrufer von REST-Services muss es transparent sein, welche Systeme zwischen dem Client und dem Server oder hinter der Schnittstelle liegen.
Aufrufe ändern sich nicht durch Änderungen an der Infrastruktur (z. B. durch Maßnahmen zur Skalierung) oder durch technische Änderungen, welche nicht den REST-Service selbst betreffen.

[NOTE]
====
Einen guten Überblick und Verweise auf detailliertere Beschreibungen bietet die https://de.wikipedia.org/wiki/Representational_State_Transfer[Wikipedia-Seite zu REST].
Für einen tiefen Einstieg in die Grundlagen bietet sich die https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation_2up.pdf[Dissertation von Roy Fielding icon:file-pdf-o[]] an.
====

Das Reifegradmodell von Leonard Richardson (*Richardson Maturity Model*, s. <<image-richard-maturity-model>>) ordnet diese Eigenschaften vier Reifegraden zu.

.Richardson Maturity Model
[id="image-richard-maturity-model", reftext = "{figure-caption} {counter:figures}"]
image::isy-service-rest:konzept/richard-maturity-model.dn.svg[align = center, title-align=center]

Die IsyFact zielt auf eine möglichst vollständige Umsetzung der Eigenschaften und peilt daher einen hohen Reifegrad für ihre REST-Services an.

.icon:university[title=Architekturregel] Maturity Level zwei Vorgabe
****
Ein auf der IsyFact basierendes Backend muss seine REST-Services mindestens anhand Stufe zwei des Richardson Maturity Models umsetzen.
****

Konkret stellt Stufe 2 des Richardson Maturity Models folgende Anforderungen:

* Ressourcen werden über einen eindeutigen URI angesprochen.
* Ressourcen werden über HTTP-Methoden angesprochen und je nach HTTP-Methode abgefragt oder verändert.
* Ressourcen melden ihren Status durch eine Abfrage oder Veränderung über HTTP-Statuscodes zurück.

Stufe 3 des Richardson Maturity Models stellt darüber hinaus weitere Anforderungen:

* Ressourcen enthalten Verweise auf URIs, mit denen weitere Anfragen im Kontext der Ressource möglich sind.

Diese grundlegende Festlegung hat große Auswirkungen auf die einzelnen Aspekte der Ausgestaltung der REST-Webservices.
Diese werden in den folgenden Kapiteln beschrieben und konkretisiert.

[[ausnahmen]]
=== Ausnahmen (Erlaubte Abweichungen zum Reifegradmodell)

In Ausnahmefällen kann auf die Einhaltung der Vorgabe zum Reifegrad (mindestens Level 2) verzichtet werden.

[[prozessorientierte-aufrufe]]
*Prozessorientierte Aufrufe - Geschäftsvorfälle*

Ein Ausnahmefall stellt die Abbildung von prozessorientierten Aufrufen dar, die häufig durch die Migration von bestehenden prozessorientierten Schnittstellen (z.B. RPC) entstanden sind.
Die Abbildung auf eine ressourcenorientierte REST-Schnittstelle ist i.d.R. mit einer Neukonzeption der Anwendung unter einer ressourcenorientierten Denkweise verbunden.
Der Aufwand für die Neukonzeption steht oft nicht im Verhältnis zum tatsächlichen (fachlichen) Nutzen.
Aus diesem Grund dürfen prozessorientierte Aufrufe über einfache http-Aufrufe realisiert werden, die bis auf die Ressourcenorientierung und Verwendung der http-Verben, den übrigen Vorgaben des REST-Konzepts folgen.
Diese http-Aufrufe entsprechen zwar nicht dem Reifegradmodell (Level 2), sind aber in diesem Ausnahmefall IsyFact-konform.

Wird über die Schnittstelle ein Geschäftsvorfall angestoßen, ist der Geschäftsvorfall in der URI zu adressieren:

// tag::namenskonvention[]

[[namenskonvention-prozessorientierte-uris]]
.Namenskonvention prozessorientierter URIs
[cols="1s,4",options="header"]
|====
2+|Prozessorientierte URIs
|Schema |`+/{geschaeftsvorfall}/{geschaeftsprozess}+`
|Beispiele |`/auskunft/personaliensuche`

`/auskunft/dokumentensuche`

`/auskunft/schluesselsuche`

`/meldung/erstmeldung`

`/meldung/aenderung`
|====

// end::namenskonvention[]

[[eigenschaften-rest-schnittstellen]]
== Eigenschaften von REST-Schnittstellen

[[aufbau-ressourcen-uris]]
=== Aufbau der Ressourcen-URIs

Jede Ressource eines REST-Services ist über einen URI eindeutig adressierbar.
Dieser Abschnitt legt Konventionen für den Aufbau der URIs fest.

[NOTE]
====
Dieses Konzept empfiehlt die Nutzung von <<hateoas>>.
====

Ressourcen repräsentieren Objekte und werden deshalb als Substantiv beschrieben.
Die Bezeichnung muss möglichst einfach gewählt werden (z. B. der Name der Entität oder die Aufgabe der Ressource).
Repräsentiert die Ressource eine Menge von Objekten, wird der Plural verwendet.

Der hierarchische Aufbau von Ressourcen ist explizit erwünscht:

// tag::namenskonvention[]

[[namenskonvention-ressourcen-uris]]
.Namenskonvention Ressourcen-URIs
[cols="1s,4",options="header"]
|====
2+|Ressourcen-URIs
|Schema |`+/{ressource}/{id}/{ressource}/{id}/{...}+`
|Regeln | Die Bezeichnung der Ressource beinhaltet ausschließlich Kleinbuchstaben.

Zwischen Teilen zusammengesetzter Begriffe steht jeweils ein Bindestrich.

Beinhaltet die Bezeichnung Sonderzeichen, müssen sie gemäß üblicher Transkriptionsregeln ersetzt werden (z. B. "ae" statt "ä").
|Beispiele |`/kunden/12345/bestellungen/123/artikel`

`/nachrichten`

Beispiele für eine Menge von Objekten.

Die Ressource liefert alle Objekte zurück.

`+/nachrichten/{id}+`

Beispiel für ein einzelnes Objekt.
Die Ressource liefert ein eindeutig identifizierbares Objekt zurück.

`/eingehende-nachrichten/`

Beispiel für zusammengesetzte Begriffe.

`/vertraege/`

Beispiel für die Ersetzung von Sonderzeichen.
|====

// end::namenskonvention[]

[[beziehungen-zwischen-ressourcen]]
==== Beziehungen zwischen Ressourcen

Beziehungen zwischen Ressourcen können entweder über <<hateoas,HATEOAS>> (vgl.
Stufe 3 in <<image-richard-maturity-model>>) oder über die URI selber abgebildet werden.

// tag::namenskonvention[]

[[namenskonvention-beziehungen-zwischen-ressourcen]]
.Namenskonvention Beziehungen zwischen Ressourcen
[cols="1s,4",options="header"]
|====
2+|Beziehungen zwischen Ressourcen
|Schema |`+/{ressourcen A}/{id von einer Ressource A}/{ressource(n) B}/{...}+`
|Hinweis| Enthält eine Ressource wiederum mehrere Ressourcen, wird wieder der Plural verwendet.
|Beispiele |`+/nachrichten/{id}/absender+`

adressiert den Absender einer bestimmten Nachricht.

`+/nachrichten/{id_n}/cc/{id_e}+`

adressiert den bestimmten CC-Empfänger (mit der Id `id_e`) einer bestimmten Nachricht (mit der Id `id_n`).
|====

// end::namenskonvention[]

[[adressierung-mehrerer-ressourcen]]
==== Adressierung von mehreren Ressourcen

Der Zugriff auf mehrere Ressourcen aus einer Menge erfolgt über eine kommaseparierte Liste von IDs.

// tag::namenskonvention[]

[[namenskonvention-addressierung-mehrerer-ressourcen]]
.Namenskonvention Adressierung von mehreren Ressourcen
[cols="1s,4",options="header"]
|====
2+|Adressierung von mehreren Ressourcen
|Schema |`+/{ressourcen}/{id1},{id2}+`
|Beispiele |`+/nachrichten/{id1},{id2}+`
|====

// end::namenskonvention[]

[[query-parameter]]
==== Query Parameter

Query Parameter werden ausschließlich für das *Sortieren*, *Paginierung* und *Filtern* von Ressourcen verwendet.



*Beispiel Sortierung:*

----
/nachrichten?sort=timestamp,ASC
----

*Beispiel Filter:*

----
/nachrichten?timestamp=2020-08-23&land=deutschland
----

*Beispiel Paginierung:*

----
/nachrichten?page=5&pageSize=15
----

.icon:university[title=Architekturregel] Datenschutzrichtlinien bei Query Parametern beachten
****
Es dürfen nur nicht datenschutzrelevante Informationen in Query Parametern verwendet werden, um das Loggen von datenschutzrelevanten Daten zu verhindern.
****

Für alle anderen Suchen sind POST-Requests zu verwenden, siehe <<post-suche-filterung>>.

[[http-methoden]]
=== Verwendung von HTTP-Methoden

Die folgenden Kapitel beschreiben, welche HTTP-Methoden zu unterstützen sind und welche Funktion sie besitzen.
Die übrigen HTTP-Methoden werden nicht verwendet.

*GET* wird verwendet, um eine Ressource zu lesen.
Die Ressource wird dabei nicht verändert, wodurch diese Methode idempotent ist.

Idempotenz beschreibt die Möglichkeit, den gleichen HTTP-Request mehrfach an die Schnittstelle senden zu können, ohne dass ein anderes Ergebnis erzielt wird als bei einem einzelnen Request.

.Beispiele für GET-Anfrage
[id="listing-get-anfrage-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
GET /kunden/1234 HTTP/1.1
accept: text/html, application/json, application/xhtml+xml, application/xml;q=0.9, */*;
charset=utf-8
HOST: xx.yy.zz
ACCEPT-ENCODING: gzip, deflate, br
----

.Beispiele für GET-Antwort
[id="listing-get-antwort-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
{
    "id":1234,
    "name":"Mustermensch",
    "adresse":"Musterstraße 1",
    "ort":"Musterstadt"
}
----


*POST* wird verwendet, um eine neue Subressource innerhalb einer Ressource anzulegen.
Es ist beim Erstellen von Datensätzen in den meisten Fällen das Mittel der Wahl, da das Backend hierbei die ID vergibt.
Dadurch, dass die Datensätze mit neuen IDs angelegt werden, wird bei jedem weiteren senden des Requests ein neuer Datensatz angelegt und die Methode ist nicht idempotent.
Des Weiteren muss POST für komplexe Suchen und Suchen mit datenschutzrelevanten Informationen verwendet werden, siehe <<post-suche-filterung>>.

.Beispiele für POST-Anfrage
[id="listing-post-anfrage-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
POST /kunden HTTP/1.1
HOST: xx.yy.zz
Content-Type: application/json; charset=utf-8
{
    "name":"Mustermensch",
    "adresse":"Musterstraße 1",
    "ort":"Musterstadt"
}
----

.Beispiele für POST-Antwort
[id="listing-post-antwort-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
{
    "id":1234,
    "name":"Mustermensch",
    "adresse":"Musterstraße 1",
    "ort":"Musterstadt"
}
----


.icon:university[title=Architekturregel] Verwendung von POST
****
POST wird auch für fachliche Operationen genutzt, die keiner der anderen HTTP-Methoden zugeordnet werden können (z. B. Verifikation eines Antrags).
****

*PUT* wird verwendet, um eine Ressource zu ändern oder zu erstellen.
Beim Ändern wird die gesamte Ressource mitgesendet und nicht nur der zu ändernde Teil wie bei PATCH.
Ist die Ressource mit der gesendeten ID noch nicht vorhanden, wird diese durch PUT erstellt.
Dies ist aber zu vermeiden, da der Client keine IDs vergeben soll.
PUT ist, da immer die gesamte Ressource geändert wird, bzw. die ID beim Erstellen schon vorgegeben ist, idempotent.
Deshalb ist PUT PATCH beim Aktualisieren vorzuziehen.
In Abhängigkeit davon, ob eine Ressource geändert oder neu erstellt wurde, wird der entsprechende Response Code (200 OK bzw. 201 Created) zurückgegeben.

.Beispiele für PUT-Anfrage
[id="listing-put-anfrage-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
PUT /kunden/1234 HTTP/1.1
HOST: xx.yy.zz
Content-Type: application/json; charset=utf-8
{
    "name":"Mustermensch",
    "adresse":"Musterstraße 1",
    "ort":"Beispielort"
}
----

.Beispiele für PUT-Antwort
[id="listing-put-antwort-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
{
    "id":1234,
    "name":"Mustermensch",
    "adresse":"Musterstraße 1",
    "ort":"Beispielort"
}
----

*PATCH* wird verwendet, um eine Ressource mit einer bestimmten ID zu ändern.
Hierbei werden nur die Felder gesendet, die geändert werden sollen und nicht die ganze Ressource.
Das kann bei Ressourcen mit beispielsweise einem Auto-Increment Feld dazu führen, dass bei mehreren Patches unterschiedliche Ergebnisse erzielt werden.
Deswegen kann Patch idempotent sein, muss aber nicht.

.Beispiele für PATCH-Anfrage
[id="listing-patch-anfrage-beispiele",reftext = "{listing-caption} {counter:listings}"]
[source,http]
----
PATCH /kunden/1234 HTTP/1.1
HOST: xx.yy.zz
Content-Type: application/json; charset=utf-8
{
    "adresse":"Neue Straße 2"
}
----

.Beispiele für PATCH-Antwort
[id="listing-patch-antwort-beispiele",reftext = "{listing-caption} {counter:listings}"]

[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
{
    "id":1234,
    "name":"Mustermensch",
    "adresse":"Neue Straße 2",
    "ort":"Beispielort"
}
----

.icon:university[title=Architekturregel] Verwendung von PATCH
****
PATCH ist nur zu verwenden, wenn PUT aus triftigen Gründen nicht funktioniert.
****

*DELETE* wird verwendet zum Löschen einer Ressource.
Da jede Ressource nur einmal gelöscht werden kann, ist diese Methode idempotent.
----
DELETE /kunden/1234
----

*HEAD* wird verwendet, um Meta-Informationen einer Ressource zu erhalten.
Es gibt die gleichen Daten zurück wie GET nur ohne Response-Body und ist damit idempotent.
----
HEAD /kunden/1234
----

*OPTIONS* wird verwendet, um die von einer Ressource unterstützten Methoden anzuzeigen.
Es ist idempotent, da nichts verändert wird.
----
OPTIONS /kunden
----

NOTE: Eine Übersicht über die HTTP-Methoden und ihre Eigenschaften findet sich in xref:konzept/master.adoc#anhang-http-methoden[Anhang: http-Methoden]

[[post-suche-filterung]]
==== Suche und Filterung mittels POST

Eine Filterung und Suche sollte im Regelfall über Query Parameter einer Anfrage mit dem HTTP-Methoden "GET" geschehen.
Einige Abfragen sind jedoch zu komplex, um sie über HTTP GET abzubilden.
Aspekte, die für eine Verwendung von POST statt GET sprechen sind folgende (ohne Anspruch auf Vollständigkeit):

* Query Parameter sind zu lang und es besteht die Gefahr, dass so die gesamte URL zu lang ist und vom Provider nicht verarbeitet werden kann.
* Query Parameter enthalten datenschutzrelevante Informationen, die aufgrund der Aufzeichnung von URLs in Logs o. ä. nicht in der URL übertragen werden dürfen.
* Die Suche ist eine unscharfe Suche, bzw. sucht nicht nach Gleichheit, wie beispielsweise Timestamp größer als.
* Die Abfrageparameter sind nicht über ein logisches UND verknüpft, sondern z. B. über ein logisches ODER.

In diesen Fällen muss die HTTP-Methode "POST" verwendet werden.
Die Filter- und Suchkriterien werden in den Body der Anfrage aufgenommen.


[[verwendung-http-statuscodes]]
=== Verwendung von HTTP-Statuscodes

Im Folgenden werden die HTTP-Statuscodes dargestellt, die zu verwenden sind.
Weitere Statuscodes sind in Abhängigkeit vom Fachverfahren möglich.


[cols="1,1,2"]
|===
|HTTP-Statuscode |Nachricht |Erläuterung

|200 |OK |Wird als Ergebnis eines erfolgreichen HTTP-Requests zurückgeliefert.
|201 |Created |Wird als Ergebnis eines erfolgreichen HTTP-Requests zurückgeliefert, wenn eine neue Ressource angelegt wurde.
|202 |Accepted | Die Anfrage wurde empfangen und verstanden , aber wird noch asynchron bearbeitet. Die Anfrage ist zum Zeitpunkt der Antwort möglicherweise noch nicht abgeschlossen, aber der Server hat sie zur weiteren Bearbeitung angenommen.
|204 |No Content |Wird als Ergebnis eines erfolgreichen HTTP-Requests zurückgeliefert, wenn der Request keinen Response-Body liefert.
|304 |Not Modified |Wird beim Caching eingesetzt und sagt dem Client, dass seine Ressource noch aktuell ist.
|400 |Bad Request |Der HTTP-Request enthält fehlerhafte Daten, z. B. XML nicht Schema-konform, es wurde ein Virus gefunden, die Anfrage enthält fachliche Fehler, etc.
|401 |Unauthorized |Es ist ein Fehler bei der Authentifizierung aufgetreten, z. B. falscher Benutzername/Passwort.
|403 |Forbidden |Der Benutzer hat nicht die erforderlichen Rechte.
|404 |Not found |Die angeforderte Ressource existiert nicht.
|405 |Method not allowed |Die aktuelle Operation ist auf der Ressource nicht erlaubt (beispielsweise PUT auf einer read-only Ressource).
|406 |Not Acceptable |Die Content Negotiation ist fehlgeschlagen.
|409 |Conflict |Die Ressource wurde zwischenzeitlich geändert.
|500 |Internal Server Error |Es ist ein interner Fehler bei der Bearbeitung der Anfrage aufgetreten.
|===

[NOTE]
====
Für die Auswahl weiterer Statuscodes bietet die entsprechende https://de.wikipedia.org/wiki/HTTP-Statuscode[Wikipedia-Seite zu HTTP-Statuscodes] einen guten Startpunkt.
Empfehlenswert ist außerdem diese gut strukturierte Übersicht von https://www.restapitutorial.com/httpstatuscodes.html[openapi-generator.tech], die Informationen von Wikipedia und des IETF übersichtlich aufbereitet.
====

[[repraesentationen]]
=== Repräsentationen

REST-Services können verschiedene Repräsentationen derselben Ressource anbieten.
Diese Repräsentationen sind entweder textbasiert oder binär.

Liegt eine Ressource textbasiert vor, müssen ihre Repräsentationen, z. B. durch ein Schema, validierbar sein.
Ebenso muss jede Repräsentation den gleichen, fachlichen Inhalt umfassen.

Liegt eine Ressource binär vor, muss sie bei direkten Abfragen (über `GET`) binär ohne weitere Veränderungen (z. B. Einbettung in eine textbasierte Form oder zusätzliche Encodings) zurückgegeben werden.
Nicht erlaubt ist eine Einbettung einer binären Ressource in eine textbasierte Repräsentation (z. B. ein BASE64-encodiertes Bild in einem dafür geschaffenen JSON- oder XML-Dokument).
Ist eine binäre Ressource Teil einer textbasierten Ressource, so wird eine Einbettung ebenfalls nicht empfohlen.
Stattdessen sollte der URI der binären Ressource in der textbasierten Ressource enthalten sein, um sie bei Bedarf direkt abzufragen.


.icon:university[title=Architekturregel] Repräsentationsform der kommunizierten Daten
****
Alle REST-Services innerhalb einer Systemlandschaft nutzen eine einheitliche, textbasierte Repräsentationsform.
Binäre Daten werden über direkte Anfragen binär ohne Transformation zurückgeliefert.
****

Diese Regel reduziert die Komplexität der internen Services und erhöht die Homogenität der Systemlandschaft.
Ebenso fällt der Aufwand zur Pflege mehrerer, inhaltlich identischer Repräsentationsformen weg.

Die Kommunikation mit IT-Systemen außerhalb der Systemlandschaft sollte ebenfalls über eine festgelegte textbasierte Repräsentation geschehen.
Hier sind jedoch gesetzliche Vorgaben, Rahmenbedingungen und die Anforderungen der externen Kommunikationspartner zu berücksichtigen.

[NOTE]
====
Ein typisches Beispiel ist eine Systemlandschaft, die intern JSON als Repräsentation nutzt, nach außen hin aber XÖV-konforme Nachrichten schicken muss und daher teilweise XML als Repräsentation nutzt.
====

[[content-negotiation]]
==== Content Negotiation

Liegen Ressourcen in mehreren Repräsentationen vor (z. B. als JSON- und XML-Dokumente oder Medien in Form von komprimierten Daten oder Rohdaten), geschieht die Auslieferung einer konkreten Repräsentation über HTTP Content Negotiation.

[NOTE]
====
Weitere Details zu Content Negotiation bietet die entsprechende https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/content-negotiation.html[Spring Dokumentation].
====

REST-Services setzen in ihren Antworten einen fest definierten Inhaltstyp pro Repräsentation.
Wenn für eine Repräsentation mehr als ein Inhaltstyp üblich ist, reagiert ein REST-Service auf eine Anfrage tolerant. D. h. er liefert auch dann die gewünschte Ziel-Repräsentation der angeforderten Ressource aus, falls in der Anfrage ein anderer MIME-Type mit dem gleichen inhaltlichen Ziel-Format angefordert wurde.


Anfragen geben ihre inhaltlichen Präferenzen im HTTP-Header `Accept` mit.
Der REST-Service setzt den Inhaltstyp der Antworten im HTTP-Header `Content-Type`.
Für die häufigsten Repräsentationen legt xref:konzept/master.adoc#anhang-content-types[Anhang: Content types] die erwarteten und zurückgegebenen Inhaltstypen fest.

[[metadaten]]
=== Metadaten

Der Bereich Metadaten kann optional implementiert werden.

Zum Erhalten von Metadaten wird die HEAD-Methode verwendet.
Die HEAD-Methode ist identisch zu GET, außer, dass sie keinen Response-Body zurückgibt.
//HEAD Aufruf

[[caching]]
=== Caching

Caching ist eine optionale Technik.

Wenn Caching eingesetzt werden soll, ist der Einsatz von ETags das Mittel der Wahl.
ETags beschreiben die Version der Ressource, die angefragt wird.
Ist der ETag im Header der Anfrage der gleiche, wie der ETag der gespeicherten Ressource, wird als Statuscode 304 zurückgegeben.


Zur Implementation wird in Spring der `ShallowEtagHeaderFilter` verwendet.
Dieser reduziert allerdings nur die genutzte Netzwerk-Kommunikation, nicht aber die Rechenzeit im Server, da zum Vergleichen der ETags die Ressource geladen werden muss.

Weitere Caching-Methoden, die auch die Serverlast reduzieren, sind möglich.

NOTE: Eine Übersicht, welche HTTP-Methoden Caching-Fähig sind, findet sich unter xref:konzept/master.adoc#anhang-http-methoden[Anhang: http-Methoden]

[[hateoas]]
=== HATEOAS

Nach dem HATEOAS-Paradigma soll eine zurückgelieferte Ressourcen weiterführende URLs (vergleichbar mit HTML-Links) zu verwandten Ressourcen enthalten, anstelle die verwandten Ressourcen mit der angefragten Ressource zusammengeführt zu übermitteln.

.Beispiel für eine HATEOAS-konforme Resource mit URIs zu weiterer Resource
[id="listing-hateoas-beispiel",reftext = "{listing-caption} {counter:listings}"]
[source,json]
----
{
    "kunde":"Alex Mustermensch",
    "kontostand":30,
    "vertrag":"https://base.url/kunde/1234/vertrag",
}
----
Folgende Vorteile ergeben sich daraus:

* Der Client benötigt nur minimales Wissen über die Struktur der Services und der Datenstrukturen: Änderungen können somit leichter realisiert werden.
* Der Server hat die Möglichkeit in Abhängigkeit vom Client Optionen auszublenden, indem z. B. einfach der Link nicht enthalten ist.
* Die Bearbeitung der Anfrage auf der Serverseite ist kostengünstiger und performanter zu realisieren, da Daten nicht "zusammengesucht und -gesetzt" werden müssen.
* Es muss in der Regel eine kleinere Nachricht übertragen werden.

Die letzten beiden Punkte führen direkt zu Fragestellungen des Schnittstellen- bzw. API-Designs:

Die letzten zwei Vorteile ergeben sich vor allem aus der Voraussetzung, dass der Client in der Regel die "zusätzlichen Daten" nicht benötigt, die nur über die URI als Referenz übermittelt werden.
Werden diese zusätzlichen Daten nach jedem Aufruf der übergeordneten Ressource angefordert, werden zusätzliche technische Verarbeitungsschritte nötig (Client: Request für die neuen Daten aufbauen, versenden. Server: Anfrage & Berechtigung prüfen, Daten suchen, ggf. konvertieren, versenden,…).

Bei häufigen, parallelen Anfragen würde dieses Szenario dann einen hohen Overhead generieren. Hier ist im Einzelfall die Schnittstelle entsprechend dem gewünschten Trade-Off zu modellieren.




[[festlegung-umsetzung]]
== Festlegungen zur Umsetzung

[[technologieauswahl]]
=== Technologieauswahl

Die IsyFact legt folgende Technologien für die Umsetzung von REST-Schnittstellen (vgl. <<table-frameworks>>) fest.

.Frameworks für die Umsetzung
[id="table-frameworks",reftext = "{table-caption} {counter:tables}"]
[cols="2,2,3",options="header"]
|===
|Framework |Technologie-Stack |Beschreibung

|Spring Webflux
|Java/Spring
|Umsetzung von REST-Clients

(unter Nutzung von Apache HTTPComponents)

|Spring MVC
|Java/Spring
|Umsetzung von REST-Services

(zur Nutzung mit Tomcat)

|Angular Framework Modul: @angular/common/http
|TypeScript/Angular
|Umsetzung von REST-Clients

|OpenAPI
|technologie-unabhängig
|Dokumentation der Service Schnittstelle und Erzeugung von Service und Client

|===
////
|OpenAPI Generator
|diverse Technologien werden unterstützt, darunter Java/Spring und Angular. Eine vollständige Liste ist unter https://openapi-generator.tech/docs/generators/[openapi-generator.tech] verfügbar.
|Code Generator (Client/Server)
////

[[spring-mvc-vergleich-webflux]]
=== Spring MVC im Vergleich zu Spring Webflux

Das Spring Framework stellt seit Version 5 Spring Webflux als reaktive Alternative zu Spring MVC bereit.

Mit Webflux ist es möglich, reaktive REST APIs zu implementieren.
Beim reaktiven Programmierparadigma geht es um die Reaktion auf Veränderungen (Observer Pattern), im Fall von REST APIs um die Reaktion auf gesendete Daten.
Das ist hilfreich, wenn man große Datenmengen (z. B. Mediendateien oder größere Ergebnismengen aus einer Datenbankabfrage) über das REST API übertragen möchte.
Die Daten werden dann in mehreren Paketen gesendet, der Empfänger reagiert jeweils auf den Erhalt eines Pakets.

Der Hauptvorteil von Webflux liegt aber im geringeren Ressourcenverbrauch auf der Server Seite.
Webflux basiert auf einem Event-Loop Mechanismus, während Spring MVC auf Thread Pools basiert.
Der Performance Vorteil von Webflux macht sich insbesondere bei vielen gleichzeiten Service-Aufrufen und/oder der Übertragung größerer Datenmengen bei einem Service-Aufruf bemerkbar.

Trotzdem empfiehlt die IsyFact grundsätzlich, Spring MVC für die Umsetzung von REST-Services einzusetzen.
Die Vorteile des reaktiven Programmierparadigmas erfüllen sich nur, wenn alle Teile der Umsetzung entsprechend gestaltet sind.
Dies ist aktuell nicht der Fall.

Für REST-Clients wiederum empfiehlt die IsyFact die Verwendung des `WebClient` anstatt des `RestTemplate`, da letzteres nicht mehr aktiv weiterentwickelt wird.

Für die Anbindung von Angular-Clients enthält der Baustein Angular eine entsprechende Komponente.

[[schnittstellendokumentation]]
=== Schnittstellendokumentation

Alle auf IsyFact basierten Anwendungen müssen ihre REST-Schnittstellen mit der _OpenAPI 3.0_ Spezifikation beschreiben.
Sowohl YAML als auch JSON sind als Format der Schnittstellendokumentation zulässig.
Für die Erstellung der Schnittstellendokumentation ist grundsätzlich kein besonderes Tool erforderlich, ein Texteditor ist ausreichend.
Das OpenAPI Format wird jedoch von diversen Entwicklungsumgebungen (z. B. IntelliJ) unterstützt, was die Bearbeitung erleichtert.
//Alternativ kann auch der Editor unter https://openapi-generator.tech/docs/generators/[openapi-generator.tech] verwendet werden, _OpenAPI 3.x_ wird hier ebenfalls unterstützt.
//Die Schnittstellendokumentation wird im zugehörigen Projekt im Ressources-Verzeichnis abgelegt.

[[code-generierung]]
==== Code-Generierung

Bei der Erstellung von REST-APIs gibt es grundsätzlich 2 Ansätze: _Contract/API First_ oder _Code First_.
Bei _Contract/API First_ wird zunächst die Schnittstellenbeschreibung erstellt und daraus der Code (Server und Client) generiert.
Bei _Code First_ wird zuerst die API implementiert und mit Annotationen für die Schnittstellenbeschreibung versehen.
Aus den Annotationen wird dann die Schnittstellenbeschreibung generiert.

Die IsyFact empfiehlt den _Contract/API First_ Ansatz.

Für die Generierung des Codes von Server und Client sind die Standards von OpenApi 3.x zu beachten.
//Für die Generierung des Codes wird das Tool _OpenAPI Generator_ verwendet.
//Es kann sowohl server- als auch client-seitiger Code generiert werden.
//Dabei werden diverse Plattformen und Programmiersprachen unterstützt, darunter Java/Spring und Angular.
//Eine vollständige Liste ist unter https://openapi-generator.tech/docs/generators verfügbar.
//
//Da der _OpenAPI Generator_ auf Maven basiert, erfolgt die Generierung eines neuen APIs/Clients über das Erstellen eines neuen Maven-Projektverzeichnisses, das ausschließlich die Maven-POM und die Schnittstellenbeschreibung enthält.
//Die Generierung wird dann über `mvn clean package` gestartet, der generierte Code liegt anschließend im target-Verzeichnis des Projekts.
//Detaillierte Informationen zur Verwendung des Generators sind unter https://github.com/OpenAPITools/openapi-generator zu finden.
//
//
//====
//Bei der Generierung von server-seitigem Java/Spring-Code wird standardmäßig Spring MVC als Basis des generierten Codes verwendet.
//Da in der IsyFact aber Webflux als Framework vorgesehen ist, muss für die Generierung der Parameter _reactive_ auf true gesetzt werden innerhalb der configOptions des Generator PlugIns.
//Beispiel:
//
//[source, xml]
//....
//<build>
//   <plugins>
//      <plugin>
//         <groupId>org.openapitools</groupId>
//         <artifactId>openapi-generator-maven-plugin</artifactId>
//         <version>4.3.1</version>
//         <executions>
//            <execution>
//               <goals>
//                  <goal>generate</goal>
//               </goals>
//               <configuration>
//                  <inputSpec>
//                     ${project.basedir}/src/main/resources/api.yaml
//                  </inputSpec>
//                  <language>spring</language>
//                  <configOptions>
//                     <sourceFolder>src/main/java</sourceFolder>
//                     <library>spring-boot</library>
//                     <reactive>true</reactive>
//                      ...
//                  </configOptions>
//               </configuration>
//            </execution>
//         </executions>
//      </plugin>
//       ...
//   </plugins>
//</build>
//....
//====

[[bereitstellen-generierte-clients]]
==== Bereitstellen von generierten Clients

Wie beschrieben können aus der OpenAPI Schnittstellenbeschreibung Services und Clients für diverse Plattformen generiert werden.
Aus Convenience-Gründen wird empfohlen, dass Anbieter von Schnittstellen fertig generierte Clients für die gängigen Plattformen zur Verfügung stellen.
Gängige Clients im Kontext der IsyFact sind Java (Spring) und Javascript (Angular).

[[verwendung-transportobjekte]]
=== Verwendung von Transportobjekten

.icon:university[title=Architekturregel] Verwendung von Transferobjekten
****
REST-Schnittstellen verwenden ausschließlich Transferobjekte (Data Transfer Objects, DTOs).
****

Die DTOs werden ebenfalls innerhalb der Schnittstellenbeschreibung schematisch beschrieben.

Der Code für die DTOs wird daraus generiert.

Innerhalb der Schnittstellenbeschreibung des Service werden die Schemata der DTOs üblicherweise als Referenz mittels `#ref` eingebunden.
Die Referenz kann sich dabei auf eine Beschreibung innerhalb derselben Datei beziehen oder auch auf eine externe Datei.
Die Datei kann dabei sowohl über einen Dateipfad als auch über eine URL adressiert werden.

Beispiel aus Swagger Petstore:

....
requestBody:
   content:
      application/json:
         schema:
            $ref: '#/components/schemas/Pet'

...

components:
   schemas:
      Pet:
         name:
            type: string
            example: doggie
....

[[querschnittliche-konzepte]]
== Querschnittliche Konzepte


[[validierung-von-anfragen]]
=== Validierung von Anfragen

Wie bereits gesagt muss die formale Validierung der Daten vor der inhaltlichen Validierung im Anwendungskern stattfinden.
Genau genommen müssen die Daten formal korrekt sein, bevor sie überhaupt in irgendeiner Weise weiter verarbeitet werden können.
Daher ist die formale Prüfung der erste Schritt in der Verarbeitung von Daten und komplett unabhängig von der weiteren Verarbeitung.

Eine geeignete Methode zur Prüfung der Daten auf formale Korrektheit ist die Validierung gegen das vorhandene Schema der Schnittstellenbeschreibung.
Atlassian bietet den Swagger Request Validator als freie Software an (Apache 2.0 Lizenz).
Damit lassen sich HTTP Requests und Responses gegen eine OpenAPI bzw. Swagger Spezifikation prüfen, OpenAPI v3 wird dabei bereits unterstützt.
Der https://bitbucket.org/atlassian/swagger-request-validator[Swagger Request Validator] hat keine weiteren Abhängigkeiten und kann somit unabhängig von HTTP APIs oder Frameworks verwendet werden.

[[fehlerbehandlung]]
=== Fehlerbehandlung

In diesem Abschnitt werden alle Aspekte zur Fehlerbehandlung in REST-Services beschrieben.

Bei der Fehlerbehandlung müssen zwei Varianten unterschieden werden: technische Fehler und fachliche Fehler.

*Definition von technischen Exceptions*: Service-Methoden deklarieren keine oder eine technische Exception.
Die technische Exception muss für alle Service-Methoden einer Service-Schnittstelle gleich sein.

*Definition von fachlichen Exceptions*: Service-Methoden können beliebig viele fachliche Exceptions deklarieren.
Diese können spezifisch für jede Service-Methode sein.

*Übermittlung von Daten*: Die Felder Ausnahme-ID, UUID und Fehlernachricht, wie in den xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] beschrieben, müssen stets übertragen werden.
Weiterhin darf kein Stack-Trace übertragen werden.

Grundsätzlich sind die Vorgaben aus den xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] zu beachten.
Im Anschluss folgen REST-Spezifische Regeln.

Technische Fehler werden in der HTTP-Response immer mit dem HTTP-Code 500 gesendet.

Fachlichen Fehlern muss ein entsprechend passender Fehlercode im Bereich 4xx zugeordnet werden.

<<einheitliche-fehlermeldungen>> beschreibt den Inhalt einer Fehlermeldung.


[[entkopplung-von-fehlerbehandlung-und-service-logik]]
==== Entkopplung von Fehlerbehandlung und Service-Logik

Die Fehlerbehandlung erfolgt wie im Detailkonzept Service beschrieben, außerhalb der Service-Fassade, an zentraler Stelle, in einer Exception-Fassade.
Die Exception-Fassade wird durch `RestExceptionHandler` Klassen implementiert, (vgl. <<image-fehlerbehandlung>>). 
In der Exception-Fassade werden alle Exceptions aus Methoden des Anwendungskerns oder Methoden der Service-Endpoints gefangen, gelogged, 
in Exception-Transport-Objekte umgewandelt und als Response zurückgegeben.

.Entkopplung Fehlerbehandlung und Service-Logik
[id="image-fehlerbehandlung",reftext = "{figure-caption} {counter:figures}"]
image::isy-service-rest:konzept/fehlerbehandlung.dn.svg[align = center,title-align=center]

Spring Webflux unterstützt dazu ebenso wie Spring MVC die Annotation `@RestControllerAdvice`.
Die Implementierung der `RestExceptionHandler`-Funktionalität kann daher über die Annotation einer Klasse mit `@RestControllerAdvice` erfolgen.

[NOTE]
====
Details zur Implementierung können der https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/web-reactive.html#webflux[offiziellen Spring Dokumentation] entnommen werden.
====

[[einheitliche-fehlermeldungen]]
==== Einheitliche Fehlermeldungen

Eine Fehlernachricht aus einer REST-Schnittstelle (egal, ob Client oder Server Error) muss mindestens folgende Informationen beinhalten.

.Standardfelder für Fehlernachrichten
[id="table-error-fields",reftext = "{table-caption} {counter:tables}"]
[cols="2,2,4",options="header"]
|===
|Feld |Datentyp |Beschreibung

|`timestamp`
|String
|Exakter Zeitpunkt an dem der Fehler aufgetreten ist.

|`status`
|Integer
|HTTP-Fehlercode

|`error`
|String
|Kurzbeschreibung des Fehlers, z. B. _Entity not found_.

|`message`
|String
|Detailbeschreibung des Fehlers.
Bei Client Errors sollte beschrieben werden wie der Client den Fehler beheben kann.
Es sollen keine technischen/internen Details (z. B. Stacktrace) in der Beschreibung enthalten sein.
Die message setzt sich, wie in den xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] beschrieben, folgendermaßen zusammen:

`#AusnahmeId Fehlertext #UUID`


|`path`
|String
|Pfad der Ressource, die in der Anfrage adressiert wurde.

|===


Fehler werden in einem Array zurückgegeben um auch das Senden mehrerer Fehler, beispielsweise bei der Validierung von Eingaben, zu ermöglichen.

[source,json]
----
[
    {
     "timestamp": "2020-08-23T14:53:33.452+02:00",
     "status": 404,
     "error": "Not Found",
     "message": "#0001 Die Nachricht mit der ID=1 konnte nicht gefunden werden. #4321",
     "path": "/ressource/1234"
    }
]
----

Sollten bei der Verarbeitung mehrere Fehler auftreten, sind alle Fehler zurückzugeben.

Exceptions werden im `RestExceptionHandler` auf den jeweiligen HTTP-Statuscode und die entsprechende Nachricht gemapped.
Welche Informationen enthalten sein dürfen wird im xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] genauer beschrieben.

[[sicherheit]]
=== Sicherheit

Die Authentifizierung wird nach OAuth2 sichergestellt.
Hierfür muss der Client mit jeder Nachricht einen Bearer Token mitsenden.
Dieser wird im Request-Header mit dem Tag "Authorization" versehen.
Im Sicherheitsbaustein wird das Token an den `SecurityContextHolder` weitergegeben.
Dort werden die Daten ausgelesen und der Token wird auf Echtheit überprüft.
Bei einer reinen Weitergabe greift die Bearer Propagation.

[NOTE]
====
Nähere Informationen zu OAuth2 gibt es auf der https://oauth.net/2/[OAuth2 Homepage].

Informationen zur Bearer Propagation gibt es in der https://docs.spring.io/spring-security/site/docs/5.2.x/reference/html/oauth2.html#oauth2resourceserver-bearertoken-resolver[offiziellen Spring Dokumentation].
====

Um eine Klasse oder einzelne Methoden zu sichern, wird empfohlen, die `@Secured` Annotation von Spring Security in der Service-Schicht zu verwenden.
Die Verwendung auf einzelnen Webcontroller Klassen/Methoden wird nicht empfohlen. Für Webcontroller ohne Service Schicht kann https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html[Request Level Autorisierung] genutzt werden.

Generell ist das xref:isy-security:konzept/master.adoc[Konzept der Sicherheitsarchitektur] zu beachten.

[[logging]]
=== Logging

Eingehende und ausgehende Nachrichten sind an der Systemgrenze zu loggen.
Für die Erstellung der Log-Einträge ist der Baustein Isy-Logging zu verwenden. Abweichungen zum Konzept von Isy-Logging sind im Folgenden aufgeführt.

[[server-service-provider]]
==== Server / Service-Provider
Der Baustein bietet mit `@Systemgrenze` eine Annotation, die einen Interceptor aufruft, der automatisch Aufrufe aller Methoden in der annotierten Klasse (z. B. Controller) fachlich loggt.
(vgl. xref:isy-logging:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Logging] Kapitel 4.2.2.1)
Für ein technisches Logging soll zusätzlich ein weiterer Interceptor verwendet werden.

Dieser Interceptor soll folgende Nachrichten am Controller loggen:

* eingehende Anfragen (eingehende Nachrichten),
* ausgehende Antworten (ausgehende Nachrichten).

[[client-service-provider]]
==== Client / Service-Consumer

In der Klasse, welche die Aufrufe an den Service-Provider stellt, sollen

*  ausgehende Anfragen (ausgehende Nachrichten),
*  eingehende Antworten (eingehende Nachrichten),

geloggt werden.

Wie auch serverseitig, sollen diese Log-Nachrichten möglichst automatisiert via AOP erstellt werden.

[[inhalt-log-eintrag-nachricht]]
==== Inhalt des Log-Eintrags für eine Nachricht

Um die Nachrichten im Zuge der Log-Auswertung zu filtern, sind nachrichtenspezifische Ereignisschlüssel zu verwenden.

Zusätzlich zu den Anforderungen an die Inhalte einer Log-Nachricht xref:isy-logging:konzept/master.adoc#einleitung[Konzept Logging] Kapitel 4.1.1), sollen folgende Informationen als Marker in der Log-Nachricht enthalten sein:

.Standard für zu erfassende Logging-Informationen
[id="table-logging-data",reftext = "{table-caption} {counter:tables}"]
[cols="2,3",options="header"]
|===
2+|Die zu protokollierende Information ist abhängig, ob es ein Request oder Response ist

|Ein-/Ausgehende Nachricht
|immer protokollieren

|Request-URL (Address + URI)
|immer protokollieren

|Query String
|immer protokollieren

|HTTP-Methode
|immer protokollieren

|Protocol
|immer protokollieren

|Connection- z. B. keep-alive, Transfer-Encoding
|immer protokollieren

|Encoding
|immer protokollieren

|Accept
|immer protokollieren

|Content-Type
|immer protokollieren

|Content-Length
|immer protokollieren

|Aufgerufene Methode der Klasse
|immer protokollieren (REST-Controller-Methode)

|Zeitpunkt
|bei ausgehend: Sende-Zeitpunkt +
 bei eingehend: Empfangszeitpunkt-Zeitpunkt +

|Dauer der Verarbeitung
|bei eingehend: Dauer vom Empfang des Requests bis zum Versand der Antwort +
 bei ausgehend: Dauer vom Versand des Requests bis zum Empfang der Antwort


| Aufgerufenes xref:glossary::terms-definitions.adoc#nachbarsystem[Nachbarsystem]
| bei ausgehendenden Requests, sonst leer

|===


*Konfigurationsparameter*

Diese Konfigurationsparameter aus Kapitel 4.2.2.1 xref:isy-logging:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Logging] sollen für den neuen Interceptor ebenfalls existieren:

* loggeDauer
* loggeDaten
* loggeDatenBeiException
* loggeMaximaleParameterGroesse


*Nachrichten Logging*

Zum Test und Debuggen einer Anwendung soll es möglich sein, dass komplette Nachrichten in ihrem Rohformat inkl. dem kompletten Header geloggt werden.
Das Aktivieren dieses Loggings ist über einen Konfigurationsparameter steuerbar.

[[ueberwachung]]
=== Überwachung

Die IsyFact stellt zur Überwachung von Anwendungen den Baustein Überwachung bereit.

Die Grundlagen der Überwachung von IsyFact basierten Anwendungen werden im xref:isy-ueberwachung:konzept/master.adoc#einleitung[Konzept Überwachung] beschrieben.


Detailliertere Informationen zur Konfiguration und zur Verwendung des Bausteins Überwachung findet man in den xref:isy-ueberwachung:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Überwachung].
Dieses Dokument beinhaltet auch das Kapitel "Informationen von Services".
Dieses Kapitel beinhaltet eine Liste der zu überwachenden bzw. anzubietenden Informationen für die Services von Anwendungen.
Die dort aufgelisteten Informationen müssen für jeden Service einzeln angeboten werden.
Die dort beschriebenen Informationen zur Überwachung gelten in gleichem Maße auch für REST Services.


[[versionierung]]
=== Versionierung

Versionierung kann auf verschiedene Weisen stattfinden.

Prinzipiell gilt es inkompatible API-Änderungen in einer REST-Schnittstelle zu vermeiden.
Falls irgendwann eine inkompatible Änderung notwendig sein sollte, ist eine Versionierung in der URL zu verwenden.

Die Version steht immer vor dem Pfad der Ressource und beinhaltet ausschließlich die Major Version.

----
https://service.de/api/v1/messages/{id}
https://service.de/api/v2/messages/{id}
----

// end::inhalt[]
