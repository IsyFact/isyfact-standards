= Konzept REST-Services: Inhalt

// tag::inhalt[]

[[querschnittliche-konzepte]]
== Querschnittliche Konzepte


[[validierung-von-anfragen]]
=== Validierung von Anfragen

Wie bereits gesagt muss die formale Validierung der Daten vor der inhaltlichen Validierung im Anwendungskern stattfinden.
Genau genommen müssen die Daten formal korrekt sein, bevor sie überhaupt in irgendeiner Weise weiter verarbeitet werden können.
Daher ist die formale Prüfung der erste Schritt in der Verarbeitung von Daten und komplett unabhängig von der weiteren Verarbeitung.

Eine geeignete Methode zur Prüfung der Daten auf formale Korrektheit ist die Validierung gegen das vorhandene Schema der Schnittstellenbeschreibung.
Atlassian bietet den Swagger Request Validator als freie Software an (Apache 2.0 Lizenz).
Damit lassen sich HTTP Requests und Responses gegen eine OpenAPI bzw. Swagger Spezifikation prüfen, OpenAPI v3 wird dabei bereits unterstützt.
Der https://bitbucket.org/atlassian/swagger-request-validator[Swagger Request Validator] hat keine weiteren Abhängigkeiten und kann somit unabhängig von HTTP APIs oder Frameworks verwendet werden.

[[fehlerbehandlung]]
=== Fehlerbehandlung

In diesem Abschnitt werden alle Aspekte zur Fehlerbehandlung in REST-Services beschrieben.

Bei der Fehlerbehandlung müssen zwei Varianten unterschieden werden: technische Fehler und fachliche Fehler.

*Definition von technischen Exceptions*: Service-Methoden deklarieren keine oder eine technische Exception.
Die technische Exception muss für alle Service-Methoden einer Service-Schnittstelle gleich sein.

*Definition von fachlichen Exceptions*: Service-Methoden können beliebig viele fachliche Exceptions deklarieren.
Diese können spezifisch für jede Service-Methode sein.

*Übermittlung von Daten*: Die Felder Ausnahme-ID, UUID und Fehlernachricht, wie in den xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] beschrieben, müssen stets übertragen werden.
Weiterhin darf kein Stack-Trace übertragen werden.

Grundsätzlich sind die Vorgaben aus den xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] zu beachten.
Im Anschluss folgen REST-Spezifische Regeln.

Technische Fehler werden in der HTTP-Response immer mit dem HTTP-Code 500 gesendet.

Fachlichen Fehlern muss ein entsprechend passender Fehlercode im Bereich 4xx zugeordnet werden.

<<einheitliche-fehlermeldungen>> beschreibt den Inhalt einer Fehlermeldung.


[[entkopplung-von-fehlerbehandlung-und-service-logik]]
==== Entkopplung von Fehlerbehandlung und Service-Logik

Die Fehlerbehandlung erfolgt wie im Detailkonzept Service beschrieben, außerhalb der Service-Fassade, an zentraler Stelle, in einer Exception-Fassade.
Die Exception-Fassade wird durch `RestExceptionHandler` Klassen implementiert, (vgl. <<image-fehlerbehandlung>>). 
In der Exception-Fassade werden alle Exceptions aus Methoden des Anwendungskerns oder Methoden der Service-Endpoints gefangen, geloggt, in Exception-Transport-Objekte umgewandelt und als Response zurückgegeben.

.Entkopplung Fehlerbehandlung und Service-Logik
[id="image-fehlerbehandlung",reftext = "{figure-caption} {counter:figures}"]
image::isy-service-rest:konzept/fehlerbehandlung.dn.svg[align = center,title-align=center]

Spring Webflux unterstützt dazu ebenso wie Spring MVC die Annotation `@RestControllerAdvice`.
Die Implementierung der `RestExceptionHandler`-Funktionalität kann daher über die Annotation einer Klasse mit `@RestControllerAdvice` erfolgen.

[NOTE]
====
Details zur Implementierung können der https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/web-reactive.html#webflux[offiziellen Spring Dokumentation] entnommen werden.
====

[[einheitliche-fehlermeldungen]]
==== Einheitliche Fehlermeldungen

Eine Fehlernachricht aus einer REST-Schnittstelle (egal, ob Client oder Server Error) muss mindestens folgende Informationen beinhalten.

.Standardfelder für Fehlernachrichten
[id="table-error-fields",reftext = "{table-caption} {counter:tables}"]
[cols="2,2,4",options="header"]
|===
|Feld |Datentyp |Beschreibung

|`timestamp`
|String
|Exakter Zeitpunkt an dem der Fehler aufgetreten ist.

|`status`
|Integer
|HTTP-Fehlercode

|`error`
|String
|Kurzbeschreibung des Fehlers, z. B. _Entity not found_.

|`message`
|String
|Detailbeschreibung des Fehlers.
Bei Client Errors sollte beschrieben werden wie der Client den Fehler beheben kann.
Es sollen keine technischen/internen Details (z. B. Stacktrace) in der Beschreibung enthalten sein.
Die message setzt sich, wie in den xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] beschrieben, folgendermaßen zusammen:

`#AusnahmeId Fehlertext #UUID`


|`path`
|String
|Pfad der Ressource, die in der Anfrage adressiert wurde.

|===


Fehler werden in einem Array zurückgegeben um auch das Senden mehrerer Fehler, beispielsweise bei der Validierung von Eingaben, zu ermöglichen.

[source,json]
----
[
    {
     "timestamp": "2020-08-23T14:53:33.452+02:00",
     "status": 404,
     "error": "Not Found",
     "message": "#0001 Die Nachricht mit der ID=1 konnte nicht gefunden werden. #4321",
     "path": "/ressource/1234"
    }
]
----

Sollten bei der Verarbeitung mehrere Fehler auftreten, sind alle Fehler zurückzugeben.

Exceptions werden im `RestExceptionHandler` auf den jeweiligen HTTP-Statuscode und die entsprechende Nachricht gemappt.
Welche Informationen enthalten sein dürfen wird im xref:isy-exception-core:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Fehlerbehandlung] genauer beschrieben.

[[sicherheit]]
=== Sicherheit

Die Authentifizierung wird nach OAuth2 sichergestellt.
Hierfür muss der Client mit jeder Nachricht einen Bearer Token mitsenden.
Dieser wird im Request-Header mit dem Tag "Authorization" versehen.
Im Sicherheitsbaustein wird das Token an den `SecurityContextHolder` weitergegeben.
Dort werden die Daten ausgelesen und der Token wird auf Echtheit überprüft.
Bei einer reinen Weitergabe greift die Bearer Propagation.

[NOTE]
====
Nähere Informationen zu OAuth2 gibt es auf der https://oauth.net/2/[OAuth2 Homepage].

Informationen zur Bearer Propagation gibt es in der https://docs.spring.io/spring-security/site/docs/5.2.x/reference/html/oauth2.html#oauth2resourceserver-bearertoken-resolver[offiziellen Spring Dokumentation].
====

Um eine Klasse oder einzelne Methoden zu sichern, wird empfohlen, die `@Secured` Annotation von Spring Security in der Service-Schicht zu verwenden.
Die Verwendung auf einzelnen Webcontroller Klassen/Methoden wird nicht empfohlen. Für Webcontroller ohne Service Schicht kann https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html[Request Level Autorisierung] genutzt werden.

Generell ist das xref:security::konzept.adoc[Konzept der Sicherheitsarchitektur] zu beachten.

[[logging]]
=== Logging

Eingehende und ausgehende Nachrichten sind an der Systemgrenze zu loggen.
Für die Erstellung der Log-Einträge ist der Baustein Isy-Logging zu verwenden. Abweichungen zum Konzept von Isy-Logging sind im Folgenden aufgeführt.

[[server-service-provider]]
==== Server / Service-Provider
Der Baustein bietet mit `@Systemgrenze` eine Annotation, die einen Interceptor aufruft, der automatisch Aufrufe aller Methoden in der annotierten Klasse (z. B. Controller) fachlich loggt.
(vgl. xref:isy-logging:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Logging] Kapitel 4.2.2.1)
Für ein technisches Logging soll zusätzlich ein weiterer Interceptor verwendet werden.

Dieser Interceptor soll folgende Nachrichten am Controller loggen:

* eingehende Anfragen (eingehende Nachrichten),
* ausgehende Antworten (ausgehende Nachrichten).

[[client-service-provider]]
==== Client / Service-Consumer

In der Klasse, welche die Aufrufe an den Service-Provider stellt, sollen

*  ausgehende Anfragen (ausgehende Nachrichten),
*  eingehende Antworten (eingehende Nachrichten),

geloggt werden.

Wie auch serverseitig sollen diese Log-Nachrichten möglichst automatisiert via AOP erstellt werden.

[[inhalt-log-eintrag-nachricht]]
==== Inhalt des Log-Eintrags für eine Nachricht

Um die Nachrichten im Zuge der Log-Auswertung zu filtern, sind nachrichtenspezifische Ereignisschlüssel zu verwenden.

Zusätzlich zu den Anforderungen an die Inhalte einer Log-Nachricht xref:isy-logging:konzept/master.adoc#einleitung[Konzept Logging] Kapitel 4.1.1), sollen folgende Informationen als Marker in der Log-Nachricht enthalten sein:

.Standard für zu erfassende Logging-Informationen
[id="table-logging-data",reftext = "{table-caption} {counter:tables}"]
[cols="2,3",options="header"]
|===
2+|Die zu protokollierende Information ist abhängig, ob es ein Request oder Response ist

|Ein-/Ausgehende Nachricht
|immer protokollieren

|Request-URL (Address + URI)
|immer protokollieren

|Query String
|immer protokollieren

|HTTP-Methode
|immer protokollieren

|Protocol
|immer protokollieren

|Connection- z. B. keep-alive, Transfer-Encoding
|immer protokollieren

|Encoding
|immer protokollieren

|Accept
|immer protokollieren

|Content-Type
|immer protokollieren

|Content-Length
|immer protokollieren

|Aufgerufene Methode der Klasse
|immer protokollieren (REST-Controller-Methode)

|Zeitpunkt
|bei ausgehend: Sende-Zeitpunkt +
 bei eingehend: Empfangszeitpunkt-Zeitpunkt +

|Dauer der Verarbeitung
|bei eingehend: Dauer vom Empfang des Requests bis zum Versand der Antwort +
 bei ausgehend: Dauer vom Versand des Requests bis zum Empfang der Antwort


| Aufgerufenes xref:glossary::terms-definitions.adoc#nachbarsystem[Nachbarsystem]
| bei ausgehendenden Requests, sonst leer

|===


*Konfigurationsparameter*

Diese Konfigurationsparameter aus Kapitel 4.2.2.1 xref:isy-logging:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Logging] sollen für den neuen Interceptor ebenfalls existieren:

* `loggeDauer`,
* `loggeDaten`,
* `loggeDatenBeiException`,
* `loggeMaximaleParameterGroesse`.


*Nachrichten Logging*

Zum Test und Debuggen einer Anwendung soll es möglich sein, dass komplette Nachrichten in ihrem Rohformat inklusive dem kompletten Header geloggt werden.
Das Aktivieren dieses Loggings ist über einen Konfigurationsparameter steuerbar.

[[ueberwachung]]
=== Überwachung

Die IsyFact stellt zur Überwachung von Anwendungen den Baustein Überwachung bereit.

Die Grundlagen der Überwachung von IsyFact basierten Anwendungen werden im xref:isy-ueberwachung:konzept/master.adoc#einleitung[Konzept Überwachung] beschrieben.


Detailliertere Informationen zur Konfiguration und zur Verwendung des Bausteins Überwachung findet man in den xref:isy-ueberwachung:nutzungsvorgaben/master.adoc#einleitung[Nutzungsvorgaben Überwachung].
Dieses Dokument beinhaltet auch das Kapitel "Informationen von Services".
Dieses Kapitel beinhaltet eine Liste der zu überwachenden bzw. anzubietenden Informationen für die Services von Anwendungen.
Die dort aufgelisteten Informationen müssen für jeden Service einzeln angeboten werden.
Die dort beschriebenen Informationen zur Überwachung gelten in gleichem Maße auch für REST Services.


[[versionierung]]
=== Versionierung

Versionierung kann auf verschiedene Weisen stattfinden.

Prinzipiell gilt es inkompatible API-Änderungen in einer REST-Schnittstelle zu vermeiden.
Falls irgendwann eine inkompatible Änderung notwendig sein sollte, ist eine Versionierung in der URL zu verwenden.

Die Version steht immer vor dem Pfad der Ressource und beinhaltet ausschließlich die Major Version.

----
https://service.de/api/v1/messages/{id}
https://service.de/api/v2/messages/{id}
----

// end::inhalt[]
