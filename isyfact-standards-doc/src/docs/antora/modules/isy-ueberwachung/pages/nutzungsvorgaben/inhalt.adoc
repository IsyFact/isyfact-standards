= Nutzungsvorgaben Überwachung: Inhalt

// tag::inhalt[]
[[ueberwachung-von-anwendungen]]
== Überwachung von Anwendungen

In diesem Kapitel werden die Anforderungen an die Überwachung von Anwendungen beschrieben.
Für die Überwachung wird der Actuator von Spring Boot eingesetzt.
Actuator bringt eine Reihe von eingebauten Endpoints mit und bietet auch die Möglichkeit, eigene Endpoints hinzuzufügen.
So wird für Informationen über den Systemzustand der eingebauten Endpoint `health` angeboten und über den Endpoint `metrics` können Metriken gelesen werden.
Die bereitgestellten Metriken werden von Micrometer erfasst.
Eine nähere Beschreibung des Konzeptes findet sich im Dokument xref:konzept/master.adoc#einleitung[Überwachung - Konzept].

Der Fokus liegt dabei auf der Schaffung von einheitlichen Administrationsschnittstellen, welche dem Betrieb eine einfache Überwachung der Anwendungen erlauben.
Alle Vorgaben sind beim Entwurf und der Realisierung von neuen Anwendungen nach IsyFact-Architektur zu berücksichtigen.
Gegebenenfalls können in Systementwürfen Verfeinerungen der hier getroffenen Vorgaben gemacht werden.
Weiterhin können die hier gemachten Vorgaben als Basis für die Beschreibung der Überwachungsschnittstelle im Betriebshandbuch der Anwendungssysteme verwendet werden.

[[designvorgaben-fuer-die-ueberwachungsschnittstelle]]
=== Designvorgaben für die Überwachungsschnittstelle

Dieses Kapitel beschreibt die zu verwendenden Designmuster und Konventionen für die Überwachung mit Actuator und Micrometer.

Für die Überwachbarkeit der Anwendungen werden die folgenden Festlegungen getroffen:

* Für die Überwachung wird Spring Boot Actuator eingesetzt.
* Die Endpoints von Actuator werden über HTTP bereitgestellt.
* Es werden nur die unbedingt benötigten Endpoints freigeschaltet.
  Alle nicht benötigten Endpoints sind zu deaktivieren.
* Endpoints werden nur passiv benutzt.
  Die Anwendung wird nicht darüber konfiguriert.
* Der Zugriff auf Endpoints wird mit Benutzername und Passwort abgesichert.
* Anwendungen stellen einen definierten Satz von Überwachungsinformationen bereit.

Beispielhaft wird eine mögliche Konfiguration zur Anbindung beschrieben.

[[vorgaben-fuer-bereitgestellte-informationen]]
==== Vorgaben für bereitgestellte Informationen

In diesem Kapitel werden die Informationen beschrieben, welche jede Anwendung zur Überwachung bereitstellen muss.

Für das Anbieten dieser genormten Management-Schnittstellen wird eine Bibliothek `isy-ueberwachung`
bereitgestellt, welche die dafür notwendigen Klassen enthält.
Die Bibliothek wird in die zu überwachende Anwendung eingebunden.
Durch das Einbinden von `isy-ueberwachung` werden auch die für Actuator und Micrometer benötigten Dritt-Bibliotheken
eingebunden.

[[allgemeine-ueberwachungsinformationen]]
===== Allgemeine Überwachungsinformationen

Actuator stellt über den `metrics` Endpoint allgemeine Überwachungsinformationen bereit.
Die folgenden Metriken müssen durch Spring Boot automatisch registriert und bereitgestellt werden:

* JVM Metriken
  ** Speicher und Puffer
  ** Statistiken zur Garbage Collection
  ** Nutzung von Threads
  ** Anzahl der geladenen Klassen
* Metriken zur Prozessorauslastung
* Metriken für Dateideskriptoren
* Metriken zur Uptime der Anwendung
* Tomcat-Metriken

[[informationen-von-services]]
===== Informationen von Services

<<table-StdueberServ>> zeigt eine Liste der zu überwachenden bzw. anzubietenden Informationen für die Services von Anwendungen.
Die dort aufgelisteten Informationen müssen für jeden Service einzeln angeboten werden.

.Standard Überwachungsinformationen für Services
[id="table-StdueberServ",reftext="{table-caption} {counter:tables}"]
[cols=",",options="header"]
|====
2+m|Tags: anwendung = <Package der Anwendung>, servicestatistik = <Name des Service>
m|AnzahlAufrufeLetzteMinute |Liefert die Anzahl der in der letzten Minute erfolgten Aufrufe des Services insgesamt.
m|AnzahlFehlerLetzteMinute |Liefert die Anzahl der in der letzten Minute erfolgten Aufrufe des Services, bei denen ein technischer Fehler aufgetreten ist.
m|DurchschnittsDauerLetzteAufrufe |Liefert die durchschnittliche Bearbeitungsdauer der letzten 10 Aufrufe der Services in Millisekunden (einfacher gleitender Durchschnitt).
m|ServiceStatistic|Stellt Informationen über den Dienstnamen und die Version bereit.
|====

NOTE: Die Summe der Aufrufe wird alle 60 Sekunden aktualisiert.

Das Interface `ServiceStatistik` ermöglicht es, Klassen zum Sammeln von Metriken zu erstellen.
Alle `ServiceStatistik` implementierenden Beans werden automatisch der Micrometer-Registry hinzugefügt.

Da die gesammelten Informationen für alle Services identisch sind, bringt `isy-ueberwachung` eine Klasse `DefaultServiceStatistik`
mit, die diese transparent erfasst.

Um die Informationen für mehrere Services in einer Anwendung anzubieten, wird die Klasse mehrfach als Spring-Bean konfiguriert.
Die Aktualisierung der Daten in `DefaultServiceStatistik` wird in der Service-Fassade der jeweiligen Komponente durchgeführt.
Dazu wird per Spring ein AOP-Advice für die Service-Methoden der Komponente definiert.
Die Konfiguration für eine `DefaultServiceStatistik`-Bean und den dazugehörigen AOP-Advice ist beispielhaft in <<listing-ServiceStatistikConfig>> dargestellt.

.ServiceStatistik-Bean und AOP-Advice für die Service-Methoden der Komponente
[id="listing-ServiceStatistikConfig",reftext="{listing-caption} {counter:listings }"]
[source,java]
----
@Configuration
@EnableAspectJAutoProxy
public class UeberwachungConfig {

    @Bean
    public DefaultServiceStatistik verwaltungMonitor() {
        return new DefaultServiceStatistik("servicestatistik", "verwaltung");
    }

    @Bean
    public Advisor verwaltungMonitorAdvice() {
        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
        pointcut.setExpression("target(de.bund.bva.anwendung.service.verwaltung.VerwaltungRemoteBean)");
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, verwaltungMonitor());
        advisor.setOrder(1000);
        return advisor;
    }
}
----

Der Advice bewirkt, dass jeder Aufruf von `VerwaltungRemoteBean` zu einem Aufruf der Methode `zaehleAufruf` in der Bean `verwaltungMonitor` führt.
Die Bean `verwaltungMonitor` ist die `DefaultServiceStatistik`-Instanz für die `VerwaltungRemoteBean`.
Eine entsprechende Konfiguration wird also für jeden Service in die Spring-Konfiguration aufgenommen.

Für das Monitoring per AOP werden intern Datenstrukturen gespeichert, die vorhalten, an welchen Stellen Aspekte eingebracht werden.
Das kann, wenn eine große Anzahl von Service-Klassen mit vielen Methoden genutzt wird, zu einem großen Speicherverbrauch führen.
Dies muss beim Design der Services berücksichtigt werden.
Da in Anwendungen pro Komponente in der Regel ein Service angeboten wird und in Anwendung gemäß Referenzarchitektur nur eine eher kleine Anzahl von Komponenten vorhanden ist, stellt dies in der Regel kein Problem dar.

[[ueberwachung-von-caches]]
===== Überwachung von Caches

Für Caches, die beim Start der Anwendung initialisiert sind, werden automatisch im Endpoint `metrics` Statistiken mit dem Präfix `cache.` geführt.
Die Art der angezeigten Statistiken ist von der verwendeten Cache-Implementierung abhängig.

[[implementierung-von-eigenen-metriken]]
==== Implementierung von eigenen Metriken

Zusätzlich zu den eingebauten Metriken kann eine Anwendung selber Metriken aufzeichnen und über Micrometer registrieren.

[[implementierung]]
===== Implementierung

Zum Einsatz von eigenen Metriken werden die von Micrometer angebotenen abstrakten `Meter` über eine `MeterRegistry` registriert und dann in der Anwendung mit Daten befüllt.


Die `MeterRegistriy` wird von Spring per Dependency Injection bereitgestellt.
Bei der Registrierung eines Meters ist ein Tag zur Unterscheidung und eine Beschreibung zu setzen.
Ein Beispiel zur Registrierung und Verwendung eines `Meters` am Beispiel eines `Counters` zeigt <<listing-custommeter>>.
Dort wird ein `Counter` mit dem Namen `eintrag.neu` mit einem Tag registriert, der aus einem Schlüssel `komponente` mit dem Wert `verwaltung` besteht.
Zu den Namenskonventionen bei der Vergabe von Namen und Tags siehe <<ueberwachung-namenskonventionen>>.

.Registrierung und Verwendung eines Counters.
[id="listing-custommeter",reftext="{listing-caption} {counter:listings }"]
[source,java]
----
@Component
public class VerwaltungImpl implements Verwaltung {

    private final Counter neuerEintragCounter;

    ...

    public VerwaltungImpl(MeterRegistry registry) {
        neuerEintragCounter = registry.counter("eintrag.neu", "komponente", "verwaltung");
        ...
    }

    public EintragDaten neuerEintrag(...) {
        ...
        neuerEintragCounter.increment();
        ...
    }
}
----

[[ueberwachung-namenskonventionen]]
===== Namenskonventionen

Bei der Benennung von Metern und Tags sind Konventionen einzuhalten.

[[benennung-von-metern]]
====== Benennung von Metern

Die Konventionen von Micrometer bei der Vergabe von Namen sehen die Verwendung von kleingeschriebenen Wörtern vor, die durch Punkte (`.`) getrennt werden.

  registry.timer("http.server.requests");

Verschiedene Monitoring-Systeme haben ihre eigenen Namenskonventionen, die untereinander inkompatibel sein können.
Deshalb sorgt jede Implementierung von Micrometer zur Anbindung eines Monitoring-Systems dafür, dass die Standardkonvention in die Namenskonvention des jeweiligen Monitoring-Systems übertragen werden kann.
Gleichzeitig stellt die Einhaltung der Konvention sicher, dass keine im angebundenen Monitoring-Systems verbotenen Zeichen verwendet werden und die Namen der Metriken somit möglichst portabel sind.

[[benennung-von-tags]]
====== Benennung von Tags

Die Benennung von Tags folgt syntaktisch dem gleichen Schema wie die Benennung von Metern.
Damit wird auch hier eine Übersetzung der Namen in die Konventionen des Monitoring-Systems möglich.
Bei der Auswahl der Bezeichner ist darauf zu achten, dass diese sprechend sind.
Das folgende Beispiel  zeigt die Verwendung von Tags.
Es sollen die Zahl der HTTP Requests und die Zahl der Datenbankzugriffe gemessen werden.

 registry.counter("database.calls", "db", "users")
 registry.counter("http.requests", "uri", "/api/users")

Damit kann man über den Namen 'database.calls' die Zahl aller Zugriffe auf die Datenbank abfragen und dann über den Tag die Aufrufe nach Datenbank weiter aufschlüsseln.

[[allgemeine-tags]]
====== Allgemeine Tags

Allgemeine Tags werden zu jeder Metrik hinzugefügt, die im System registriert wird.
Diese werden zur Kennzeichnung der betrieblichen Systemumgebung (Anwendung, Host, Instanz, etc.) gesetzt.
Allgemeine Tags können über Properties in `application.properties` gesetzt werden.
Die Properties sind dabei nach dem Schema

  management.metrics.tags.<Schlüssel>=<Wert>

aufgebaut.
Damit jeder Metrik ein Tag hinzugefügt wird, der den Namen der Anwendung enthält, wird die Property

  management.metrics.tags.anwendung=beispielanwendung

gesetzt.

[[performance]]
===== Performance

Die im Konzept beschriebenen Überwachungsfunktionen dürfen keinen relevanten negativen Einfluss auf die Performance der Anwendung haben.
Dazu sind neben der Einhaltung der in dem Dokument xref:konzept/master.adoc#einleitung[Überwachung - Konzept] beschriebenen Vorgaben noch einige grundlegende  Regeln zu beachten:

* Da nicht auszuschließen ist, dass ein Überwachungswerkzeug sehr häufig Informationen aus den Endpoints abruft, darf das Bereitstellen der Informationen keine zeitaufwändigen Aktionen im xref:glossary:glossary:master.adoc#glossar-anwendungssystem[Anwendungssystem] veranlassen.
* Bei der Bereitstellung weiterer Überwachungsinformationen ist darauf zu achten, dass die Ermittlung der Kennzahlen keinen relevanten negativen Einfluss auf die Performance der Anwendung hat.
Insbesondere dürfen keine fachlichen Funktionen des xref:glossary:glossary:master.adoc#glossar-anwendungskern[Anwendungskerns] aufgerufen werden.

[[statische-informationen-ueber-die-anwendung]]
==== Statische Informationen über die Anwendung

Der Info-Endpoint liefert statische Informationen über die Anwendung und ist im Baustein Überwachung aktiviert.
Die Informationen müssen von der Anwendung explizit bereitgestellt werden.
Es können z. B. Informationen über den Build und Quellcode-Stand (Git) der Anwendung geliefert werden. Durch die
Einbindung von passenden Maven-Plugins können diese Informationen automatisch bei jedem Build erzeugt werden:

.Maven Konfiguration für Build- und GIT Informationen
[id="listing-info-maven-config",reftext="{listing-caption} {counter:listings }"]
[source,xml]
----
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
<plugin>
    <groupId>pl.project13.maven</groupId>
    <artifactId>git-commit-id-plugin</artifactId>
</plugin>
----

Durch das Einbinden der Plugins (s. <<listing-info-maven-config>>) werden 2 Dateien mit folgenden Informationen erzeugt:

* `build-info.properties` mit den Keys:
** `build.artifact`
** `build.group`
** `build.name`
** `build.time`
** `build.version`
* `git.properties` mit den Keys:
** `git.branch`
** `git.commit.id.abbrev`
** `git.commit.time`

Die Werte der Keys werden über den Info-Endpoint bereitgestellt.

Bei Bedarf können weitere statische Informationen durch zusätzliche Konfiguration von der Anwendung bereitgestellt werden.

NOTE: Weiterführende Informationen enthält die xref:literaturextern:inhalt.adoc#litextern-spring-boot-info-endpoint[Dokumentation von Spring Boot zum Info-Endpoint].

[[konfiguration-und-absicherung-von-endpoints]]
==== Konfiguration und Absicherung von Endpoints

Gemäß den Vorgaben werden nicht benötigte Endpoints deaktiviert, und jeder veröffentlichte Endpoint wird durch
Authentifizierung abgesichert.

[[konfiguration-von-endpoints]]
===== Konfiguration von Endpoints

Zur Überwachung einer Anwendung werden die folgenden eingebauten Endpoints verwendet:

* `health`
* `metrics`

Diese sind bereits mit Standardwerten konfiguriert.
Da der Endpoint `health` seine Informationen aus einem Cache abfragt, welcher von einem Task befüllt wird, werden die in <<listing-task-activation>> gezeigten Properties in `application.properties` gesetzt, um das Starten der Tasks zu aktivieren.

.Properties zur Aktivierung des Tasks
[id="listing-task-activation",reftext="{listing-caption} {counter:listings }"]
----
isy.task.autostart=true
isy.task.default.host=
----

Endpoints können einzeln aktiviert oder deaktiviert werden.
Damit wird gesteuert, ob der Endpoint erstellt wird und die dafür notwendigen Beans erzeugt werden.
Für den Zugriff von außerhalb muss der Endpoint zusätzlich über eine Schnittstelle (HTTP oder JMX) bereitgestellt werden.

Da von Spring standardmäßig fast alle Endpoints aktiviert sind, werden zunächst alle Endpoints ausgeschaltet, und anschließend die Endpoints `health` und `metrics` explizit wieder aktiviert.
Die Bereitstellung der Endpoints erfolgt nur über HTTP.

Der Task für die Aktualisierung der Informationen für den Endpoint `health` muss regelmäßig ausgeführt werden.
Durch das Caching ist gewährleistet, dass die wiederholte Abfrage des Endpoints nicht übermäßige Abfragen erzeugt, die auf andere Systeme propagieren können.

Für diese Konfiguration sind die in <<listing-endpointconfig-defaults>> gezeigten Properties standardmäßig gesetzt.
Diese können bei Bedarf in `application.properties` überschrieben werden.

.Properties zur Konfiguration der Endpoints
[id="listing-endpointconfig-defaults",reftext="{listing-caption} {counter:listings }"]
----
management.endpoints.enabled-by-default=false
management.endpoint.health.enabled=true
management.endpoint.metrics.enabled=true
management.endpoint.info.enabled=true
management.endpoints.web.exposure.include=health, metrics, info
management.endpoints.jmx.exposure.exclude=*

isy.task.tasks.isyHealthTask.ausfuehrung=FIXED_DELAY
isy.task.tasks.isyHealthTask.initial-delay=5s
isy.task.tasks.isyHealthTask.fixed-delay=30s
----

[[absicherung-von-endpoints]]
===== Absicherung von Endpoints

Der Zugriff auf Endpoints muss mit einer Authentifizierung abgesichert werden.
Eine Konfiguration für Spring Security, die alle Endpoints mit HTTP Basic Authentication absichert,
zeigt <<listing-endpointsecurityconfig>>.
Der Benutzername und das Passwort werden in `application.properties` gepflegt.


.Absicherung der Endpoints mit Spring Security
[id="listing-endpointsecurityconfig",reftext="{listing-caption} {counter:listings }"]
[source,java]
----
@Configuration
@EnableWebSecurity
@Profile("produktion")
public class ActuatorSecurityProduktionConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UeberwachungSecurityConfigProperties properties;

    private static final String ENDPOINT_ROLE = "ENDPOINT_ADMIN";

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
         auth.inMemoryAuthentication()
             .withUser(properties.getUsername())
             .password(passwordEncoder().encode(properties.getPassword()))
             .roles(ENDPOINT_ROLE);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.requestMatcher(EndpointRequest.toAnyEndpoint())
                .authorizeHttpRequests(requests -> requests.anyRequest().hasRole(ENDPOINT_ROLE))
                .httpBasic();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
----

[[abschalten-der-absicherung-fuer-die-entwicklung]]
====== Abschalten der Absicherung für die Entwicklung

Um die Authentifizierung für die Endpoints bei der Entwicklung abzuschalten, kann in <<listing-endpointsecurityconfig>>
gezeigte Konfiguration über ein Spring-Profil (im Beispiel `produktion`) aktiviert bzw. deaktiviert werden.


[[vorgaben-fuer-die-pruefung-der-verfuegbarkeit]]
==== Prüfung der Verfügbarkeit

Anwendungen nach IsyFact-Architektur sollen Mechanismen bereitstellen, die es erlauben, die Verfügbarkeit der
Anwendung durch eine betriebliche Überwachung zu prüfen.

Grundlage dafür ist die Bereitstellung eines HealthEndpoints.

[[implementierung-von-ping-und-pruefmethoden]]
===== Konfiguration des Nachbarsystem-HealthIndicator

Jede Anwendung stellt einen HealthEndpoint unter `/actuator/health` bereit. Zur Konfiguration siehe auch <<konfiguration-von-endpoints>>.
Dieser zeigt den Status des Systems abhängig von allen vorhandenen Health-Indikatoren (`HealthIndicator`).

Der Baustein liefert einen Nachbarsystem-Indikator mit, der den HealthEndpoint aller konfigurierten Nachbarsysteme abfragt.

Dieser lässt sich wie folgt konfigurieren:

.Konfiguration des NachbarsystemIndicators
[id="listing-nachbarsysteme",reftext="{listing-caption} {counter:listings }"]
----
## Konfiguration von Timeout und Retries bei der Abfrage von Nachbarsystemen
isy.ueberwachung.nachbarsystemcheck.anzahlretries=1
isy.ueberwachung.nachbarsystemcheck.timeout=2s

## Konfiguration eines Nachbarsystems, das überwacht wird
isy.ueberwachung.nachbarsysteme.beispielnachbar.systemname=Beispielnachbar
isy.ueberwachung.nachbarsysteme.beispielnachbar.healthendpoint=http(s)://example.com/actuator/health
isy.ueberwachung.nachbarsysteme.beispielnachbar.essentiell=false

# weitere Nachbarn
#isy.ueberwachung.nachbarsysteme.anderernachbar.systemname=EinAndererNachbar
#...
----
Unter `isy.ueberwachung.nachbarsystemcheck` sind die Zeit bis zum Timeout einer Anfrage und die Anzahl der Wiederholungsversuche pro Abfrage konfigurierbar.
Ist nichts anderes konfiguriert, ist der Standardwert hier 3 Sekunden bis zum Timeout und ein Wiederholungsversuch.
Alle abzufragenden Nachbarsysteme sind unter `isy.ueberwachung.nachbarsysteme` zu konfigurieren.
Im Listing oben ist `beispielnachbar` ein selbst zu wählender Schlüssel.
Für jeden Schlüssel sind folgende Properties zu setzen:

* `systemname`: Wird in der Log-Ausgabe als Name des Nachbarsystems verwendet
* `healthendpoint`: Die URL, unter der der HealthEndpoint des Nachbarsystems zu erreichen ist
* `essentiell` (`true`/`false`) : Ist ein essenzielles Nachbarsystem nicht erreichbar, wird der Status des Nachbarsystem-Indikators auf DOWN gesetzt und ein Error geloggt.
Nicht essenzielle Nachbarsysteme beeinflussen den Status nicht und werden, falls sie nicht erreichbar sind, nur als Warning geloggt.

==== Korrelations-ID bei einem Nachbarsystem-HealthIndicator
Eine Korrelations-ID muss gesetzt werden, wenn ein `HealthIndicator` ein Nachbarsystem aufruft.
Diese wird im Logging Kontext benötigt.
Konkret wird die Korrelations-ID im Task Scheduling gesetzt. `isy-ueberwachung` liefert
nur eine Default-Konfiguration für einen `HealthIndicator`.

==== Implementierung weiterer eigener Health-Indikatoren

Es können weitere Indikatoren zur Überprüfung anderer Komponenten implementiert werden.
Um einen eigenen `HealthIndicator` zu implementieren, wird eine Spring-Bean registriert, die das Interface `HealthIndicator` implementiert.
Dort wird die Methode `health()` implementiert, die eine Objekt vom Typ `Health` zurückgibt.
Diese enthält den Status der überprüften Komponente und kann optional weitere Details zur Anzeige enthalten.
`HealthIndicator` werden automatisch von Spring Boot erkannt und im `health` Endpoint bereitgestellt.

Hierfür gelten folgende Richtlinien:

* Der `HealthIndicator` wird als Teil der Administrationskomponente implementiert.
* Der `HealthIndicator` darf keine fachlich relevanten Daten verändern.

Neben den Nachbarsystemen sind weitere Überprüfungen sinnvoll:

* Verfügbarkeit weiterer genutzter Ressourcen, wie beispielsweise das IAM-System oder genutzte FTP-Verzeichnisse.
Bei der Prüfung der genutzten Ressourcen ist zu beachten, dass sich die Implementierung nicht aufhängt und somit die Prüfung nicht weiterläuft.
Um dies zu vermeiden, sollte zur Prüfung der genutzten Ressourcen das Future-Pattern wie in <<listing-Pruefmethode>> gezeigt, verwendet werden.
+
[NOTE]
====
Als Beispiel sei hier das IAM-System genannt.
Zur Prüfung des IAM-Systems wird in der Regel eine Beispielanfrage an den Server gesendet.
Ist vor das IAM-System ein Loadbalancer geschaltet, so kann es nach einem Fail-Over passieren, dass diese Beispielanfrage endlos läuft.
====
* Anwendungen, die HTTP-Invoker Schnittstellen bereitstellen, müssen nach Vorgabe das Administration-Bean anbieten, um die Erreichbarkeit des Systems zu prüfen.
Die Ping-Methode dieses Beans kann zur Implementierung eines Health-Indikators verwendet werden, wie in <<listing-CustomHealthIndicator>> dargestellt.
+
NOTE: Bei der Erstellung des AdministrationRemoteBean muss der Request-Timeout gesetzt werden, damit Ressourcen nicht zu lange blockiert werden.

.Demonstration Future-Pattern
[id="listing-Pruefmethode",reftext="{listing-caption} {counter:listings }"]
[source,java]
----
boolean pruefeSystem() {
    ExecutorService executor = Executors.newCachedThreadPool();
    Future<Boolean> future = executor.submit((Callable<Boolean>) () -> {
        if (!anwendungXYZ.isAnwendungXYZAlive()) {
            throw new AnwendungXYZNotAvailableException();
        }
        return true;
    });

    try {
        return future.get(10, TimeUnit.SECONDS);
    } catch (Exception e) {
        return false;
    }
}
----

.Beispiel: Implementierung eines eigenen Health-Indikators
[id="listing-CustomHealthIndicator",reftext="{listing-caption} {counter:listings }"]
[source,java]
----
/** Health configuration. */
@Configuration
@ConditionalOnAvailableEndpoint(endpoint = HealthEndpoint.class)
public class HealthConfiguration {
    /** Ping message. */
    private final String pingMsg;

    /**
     * @param systemName current system name
     */
    HealthConfiguration(@Value("${system.name}") String systemName) {
        pingMsg = "Ping from " + systemName;
    }

    /**
     * App2 {@link HealthIndicator}; available in an entry named {@code app2}.
     * @param app2AdminBean App2 {@link AdministrationRemoteBean}
     */
    @Bean
    HealthIndicator app2HealthIndicator(AdministrationRemoteBean app2AdminBean) {
        return () -> {
            try {
                app2AdminBean.ping(pingMsg);
                return Health.up().build();
            } catch (Exception e) {
                return Health.down(e).build();
            }
        };
    }
}
----

[[implementierung-von-liveness-und-readiness-health-checks]]
==== Implementierung von Liveness und Readiness Health-Checks

Wie in xref:konzept/master.adoc#informationen-ueber-den-systemzustand[Informationen über den Systemzustand] beschrieben sind _Liveness_ und _Readiness_ optionale Zustände, die einem feingranularen Monitoring dienen.

Diese sind mit der IsyFact 3.0 ausschließlich konzeptionell beschrieben und nicht in den Bibliotheken implementiert. Daher werden hier diesbezüglich ausschließlich grobe Implementierungsdetails gegeben, bzw. auf Literatur hingewiesen.

[[auslesen-von-liveness-und-readiness-probes]]
===== Auslesen von Liveness und Readiness Probes

_Liveness_ und _Readiness_ Probes können aktiviert werden durch (vgl. xref:literaturextern:inhalt.adoc#litextern-baeldung-spring-liveness-readiness-probes[Baeldung: Liveness und Readiness Probes in Spring Boot]):

[[listing-enable-liveness-readiness-states]]
[source,properties]
----
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
----

[[update-des-liveness-states]]
===== Update des Liveness States

_Liveness_ soll nicht durch externe Checks wie Health-Checks gemessen werden.
Andernfalls könnte es sein, dass einem Fehlschlagen eines externen Systems (database, Web API, externe cache, ...) ein Neustart des Systems folgt, welcher Fehlerkaskaden über die Plattform auslöst.

Der innere Zustand einer Spring Boot Application wird hauptsächlich über Springs `ApplicationContext` dargestellt.
Wenn der `ApplicationContext` erfolgreich gestartet ist, geht Spring Boot davon aus, dass die Anwendung in einem korrekten Zustand ist.
Die Anwendung wird als alive betrachtet, sobald der `Context` aufgefrischt wird
(vgl. xref:literaturextern:inhalt.adoc#litextern-spring-liveness[Spring Boot Liveness]).

Neben dem funktionierenden `ApplicationContext` ist der _Liveness_-Zustand von weiteren, anwendungsspezifische Komponenten abhängig und muss entsprechend aktualisiert werden (vgl. xref:literaturextern:inhalt.adoc#litextern-baeldung-spring-liveness-readiness-probes[Baeldung: Liveness und Readiness Probes in Spring Boot]).

[[update-des-readiness-states]]
===== Update des Readiness States

Für den *Readiness State* kann die Kommunikation durch Rest Aufrufe geprüft werden. D. h. _Readiness_ wird durch von Spring Boot bereitgestellte _Readiness_-Probes sichergestellt. Das System ist z. B. bei einem http 200 Ergebnis ready. Die Probes können wiederum durch einen Task-Scheduler durchgeführt werden (vgl.
xref:literaturextern:inhalt.adoc#litextern-medium-enable-liveness-readiness-probes[Medium: Liveness und Readiness Probes]).


[[anbindung-eines-monitoring-systems]]
=== Anbindung eines Monitoring-Systems

Zur Anbindung eines konkreten Monitoring-Systems wird die passende Meter Registry für das Monitoring-System als Maven-Abhängigkeit in die `pom.xml` aufgenommen.

Die Namen der Abhängigkeiten folgen dem Schema `micrometer-registry-<Monitoring-System>`.
Soll beispielweise _Prometheus_ angebunden werden, muss die folgende Abhängigkeit eingetragen werden.

[source,xml]
----
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
----

Häufig ist keine weitere Konfiguration notwendig, da die Anbindung durch Spring Boot automatische konfiguriert wird.
Die Konfiguration für die unterstützten Monitoring-System ist in xref:literaturextern:inhalt.adoc#litextern-monitoring-systeme[Monitoring-Systeme] beschrieben.

[[anwendungen-deaktivierbar-machen]]
=== Anwendungen deaktivierbar machen

Für die Durchführung von Updates beim Deployment ist es notwendig, einzelne Knoten eines Anwendungsclusters aus dem Loadbalancing herauszunehmen, sodass dieser Knoten keine Anfragen mehr vom Loadbalancer zugeteilt bekommt.

[[integration-des-loadbalancer-servlets]]
==== Integration des Loadbalancer-Servlets

Das Loadbalancing-Servlet ist als Teil der Bibliothek `isy-ueberwachung`.
Es wird automatisch durch die Einbindung der Bibliothek als Servlet registriert.
Standardmäßig verwendet das Servlet die Datei `/WEB-INF/classes/config/isAlive` als IsAlive-Datei.

NOTE: Nach dem Deployment entspricht dies der Datei `/etc/<anwendungsname>/isAlive`.

Die zu suchende Datei kann bei Bedarf durch die Property `isy.ueberwachung.loadbalancer.isAliveFileLocation` in `application.properties` geändert werden.

[[nutzung-des-loadbalancing-servlets]]
==== Nutzung des Loadbalancing-Servlets

Durch die oben beschriebene Konfiguration kann die gewünschte Verfügbarkeit der Anwendung über die URL `http(s)://<serverurl>/<anwendungsname>/Loadbalancer abgefragt werden`.

Zur Steuerung des Loadbalancing-Servlets muss die IsAlive-Datei im Konfigurationsverzeichnis der Anwendung durch den Betrieb angelegt bzw. entfernt werden.
Der Standardname für die IsAlive-Datei ist `/etc/<anwendungsname>/isAlive`.
Dieses kann der Betrieb bei Bedarf über ein Shell-Skript automatisieren.

// end::inhalt[]
