rules:
  - id: find_sec_bugs.HTTPONLY_COOKIE-1
    languages:
      - java
    patterns:
      - pattern: |
          $X.servlet.http.Cookie $C = new $X.servlet.http.Cookie(..., ...);
          ...
          ($X.servlet.http.HttpServletResponse $RESP).addCookie($C);
      - pattern-not-inside: |
          $X.servlet.http.Cookie $C = new $X.servlet.http.Cookie(..., ...);
          ...
          $C.setHttpOnly(true);
          ...
          ($X.servlet.http.HttpServletResponse $RESP).addCookie($C);
    message: |
      The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by
      client side JavaScript such
      as reading the `document.cookie` values. By enabling this protection, a website that is
      vulnerable to
      Cross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie
      value from JavaScript.
      
      Example of protecting a `Cookie`:
      ```
      // Create an HttpOnly cookie.
      Cookie someCookie = new Cookie("SomeCookieName", "SomeValue");
      // Set HttpOnly flag to true
      someCookie.setHttpOnly(true);
      ```
      
      For more information see:
      https://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-
      
      Session cookies should be configured with the following security directives:
      
      - [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
      - [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
      - [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
    severity: WARNING
    metadata:
      shortDescription: Sensitive cookie without 'HttpOnly' flag
      category: security
      owasp:
        - A6:2017-Security Misconfiguration
        - A05:2021-Security Misconfiguration
      cwe: CWE-1004
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.HTTPONLY_COOKIE-1
      secondary_identifiers:
        - name: Find Security Bugs-HTTPONLY_COOKIE
          type: find_sec_bugs_type
          value: HTTPONLY_COOKIE
  - id: find_sec_bugs.INSECURE_COOKIE-1
    languages:
      - java
    patterns:
      - pattern: |
          $X.servlet.http.Cookie $C = new $X.servlet.http.Cookie(..., ...);
          ...
          ($X.servlet.http.HttpServletResponse $RESP).addCookie($C);
      - pattern-not-inside: |
          $X.servlet.http.Cookie $C = new $X.servlet.http.Cookie(..., ...);
          ...
          $C.setSecure(true);
          ...
          ($X.servlet.http.HttpServletResponse $RESP).addCookie($C);
    message: |
      The `Secure` attribute when set to `true` protects the cookie value from being being
      transmitted over clear text
      communication paths such as HTTP. By enabling this protection, the cookie will only be sent
      over HTTPS.
      
      Example of protecting a `Cookie`:
      ```
      // Create an Secure cookie.
      Cookie someCookie = new Cookie("SomeCookieName", "SomeValue");
      // Set Secure flag to true
      someCookie.setSecure(true);
      ```
      
      For more information see:
      https://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-
      
      Session cookies should be configured with the following security directives:
      
      - [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
      - [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
      - [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
    severity: WARNING
    metadata:
      shortDescription: Sensitive cookie in HTTPS session without 'Secure' attribute
      category: security
      cwe: CWE-614
      owasp:
        - A6:2017-Security Misconfiguration
        - A05:2021-Security Misconfiguration
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.INSECURE_COOKIE-1
      secondary_identifiers:
        - name: Find Security Bugs-INSECURE_COOKIE
          type: find_sec_bugs_type
          value: INSECURE_COOKIE
  - id: find_sec_bugs.HTTP_RESPONSE_SPLITTING-1
    languages:
      - java
    mode: taint
    pattern-sanitizers:
      - patterns:
          - pattern-inside: |
              $STR.replaceAll($REPLACER, "...");
              ...
          - pattern: "$STR"
          - metavariable-regex:
              metavariable: "$REPLACER"
              regex: ".*\\[(?=.*\\\\r)(?=.*\\\\n).*\\]\\+"
      - pattern: org.apache.commons.text.StringEscapeUtils.escapeJava($STR);
    pattern-sinks:
      - pattern: new javax.servlet.http.Cookie("$KEY", ...);
      - patterns:
          - pattern-inside: |
              $C = new javax.servlet.http.Cookie("$KEY", ...);
              ...
          - pattern: "$C.setValue(...);"
    pattern-sources:
      - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameter(...);"
      - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameterNames();"
      - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameterValues(...);"
      - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameterMap();"
      - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getHeader(...);"
      - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getPathInfo();"
    message: |
      HTTP Response Splitting is a vulnerability where Carriage Return (CR `\r`) and Line Feed (LF
      `\n`)
      characters are introduced into an HTTP header from user-supplied input. By injecting the
      `\r\n`
      character sequence, an adversary could potentially modify how the response is interpreted by
      the
      client or any downstream caching services. This could allow an adversary to poison the cache
      data or execute Cross-Site Scripting (XSS) attacks.
      
      Some Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) as of version
      8.0, newer versions of Jetty and other servers that implement the [RFC 6265 Standard](https://datatracker.ietf.org/doc/html/rfc6265) will
      disallow `\r' and '\n` characters characters from being set in cookies. If your application server does not
      automatically provide this functionality, user-supplied input that is used in cookie keys or
      values must be validated.
      
      Example of validating cookies to only allow valid characters:
      ```
      // throws an IllegalArgumentException if the provided value contains invalid characters
      public void validateRfc6265CookieValue(String value) throws IllegalArgumentException {
          char[] chars = value.toCharArray();
      
          // iterate over every character
          for (int i = 0; i < chars.length; i++) {
              char c = chars[i];
      
              // check for any characters below 0x21 as well as: '"' ',' ';' '\' and 0x7f.
              if (c < 0x21 || c == '"' || c == ',' || c == ';' || c == '\\' || c == 0x7f) {
                  throw new IllegalArgumentException("Invalid character in cookie detected:
      {0}".format(Integer.toString(c)));
              }
          }
      }
      ```
      
      Alternatively, you could use a string escape package such as
      [Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:
      ```
      public String escapeValue(String value) {
        return StringEscapeUtils.escapeJava(value);
      }
      ```
      
      For more information on response splitting attacks see OWASP:
      https://owasp.org/www-community/attacks/HTTP_Response_Splitting
    severity: WARNING
    metadata:
      shortDescription: Improper neutralization of CRLF sequences in HTTP headers ('HTTP
        Response Splitting')
      category: security
      cwe: CWE-113
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.HTTP_RESPONSE_SPLITTING-1
      secondary_identifiers:
        - name: Find Security Bugs-HTTP_RESPONSE_SPLITTING
          type: find_sec_bugs_type
          value: HTTP_RESPONSE_SPLITTING
  - id: find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1
    languages:
      - java
    mode: taint
    pattern-sanitizers:
      - patterns:
          - pattern-inside: |
              $STR.replaceAll("$INPUT", "...");
              ...
          - pattern: "$STR"
          - metavariable-regex:
              metavariable: "$INPUT"
              regex: ".*\\[(?=.*\\\\r)(?=.*\\\\n).*\\]\\+"
      - pattern: org.apache.commons.text.StringEscapeUtils.unescapeJava(...);
    pattern-sinks:
      - pattern: ($X.servlet.http.HttpServletResponse $RES).setHeader("$KEY", ...);
      - pattern: ($X.servlet.http.HttpServletResponse $RES).addHeader("$KEY", ...);
      - pattern: ($X.servlet.http.HttpServletResponseWrapper $WRP).setHeader("$KEY", ...);
      - pattern: ($X.servlet.http.HttpServletResponseWrapper $WRP).addHeader("$KEY", ...);
    pattern-sources:
      - pattern: "($X.servlet.http.HttpServletRequest $REQ).getParameter(...);"
      - pattern: "($X.servlet.http.HttpServletRequest $REQ).getParameterNames();"
      - pattern: "($X.servlet.http.HttpServletRequest $REQ).getParameterValues(...);"
      - pattern: "($X.servlet.http.HttpServletRequest $REQ).getParameterMap();"
      - pattern: "($X.servlet.http.HttpServletRequest $REQ).getHeader(...);"
      - pattern: "($X.servlet.http.HttpServletRequest $REQ).getPathInfo();"
    message: |
      HTTP Response Splitting is a vulnerability where Carriage Return (CR `\r`) and Line Feed (LF
      `\n`)
      characters are introduced into an HTTP header from user-supplied input. By injecting the
      `\r\n`
      character sequence, an adversary could potentially modify how the response is interpreted by
      the
      client or any down stream caching services. This could allow an adversary to poison the cache
      data or execute Cross-Site Scripting (XSS) attacks.
      
      Some Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) will
      automatically encode
      characters from being set in response headers as a space `0x20` character. If your application
      server does
      not automatically provide this functionality, user-supplied input that is used in header keys
      or values must be
      validated.
      
      Example of validating headers to only allow valid characters:
      ```
      // throws an IllegalArgumentException if the provided value contains invalid characters
      public void validateHeader(String value) throws IllegalArgumentException {
          char[] chars = value.toCharArray();
      
          // iterate over every character
          for (int i = 0; i < chars.length; i++) {
              char c = chars[i];
      
              // check for any characters below 0x21 as well as: '"' ',' ';' '\' and 0x7f.
              if (c < 0x21 || c == '"' || c == ',' || c == ';' || c == '\\' || c == 0x7f) {
                  throw new IllegalArgumentException("Invalid character in cookie detected:
      {0}".format(Integer.toString(c)));
              }
          }
      }
      ```
      
      Alternatively, you could use a string escape package such as
      [Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:
      ```
      public String escapeValue(String value) {
        return StringEscapeUtils.escapeJava(value);
      }
      ```
      
      For more information on response splitting attacks see OWASP:
      https://owasp.org/www-community/attacks/HTTP_Response_Splitting
    severity: ERROR
    metadata:
      shortDescription: Improper neutralization of CRLF sequences in HTTP headers ('HTTP
        Response Splitting')
      category: security
      cwe: CWE-113
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1
      secondary_identifiers:
        - name: Find Security Bugs-HRS_REQUEST_PARAMETER_TO_HTTP_HEADER
          type: find_sec_bugs_type
          value: HRS_REQUEST_PARAMETER_TO_HTTP_HEADER
  - id: find_sec_bugs.PERMISSIVE_CORS-2
    languages:
      - java
    mode: taint
    pattern-sources:
      - pattern: "(HttpServletRequest $REQ).getParameter(...)"
      - pattern: "(HttpServletRequest $REQ).getHeader(...)"
      - pattern: "(HttpServletRequest $REQ).getPathInfo()"
      - pattern: "(HttpServletRequest $REQ).getQueryString()"
      - pattern: "(HttpServletRequest $REQ).getAttribute(...)"
      - pattern: "(HttpServletRequest $REQ).getSession().getAttribute(...)"
      - pattern: "(HttpServletRequest $REQ).getServletContext().getAttribute(...)"
      - pattern: "(HttpServletRequest $REQ).getParameterValues(...)"
      - pattern: "(HttpServletRequest $REQ).getParameterNames()"
      - pattern: "(HttpServletRequest $REQ).getParameterMap()"
    pattern-sinks:
      - patterns:
          - pattern-either:
              - pattern: (HttpServletResponse $RES).setHeader("$HEADER", ...)
              - pattern: (HttpServletResponse $RES).addHeader("$HEADER", ...)
          - metavariable-regex:
              metavariable: "$HEADER"
              regex: "(?i)(Access-Control-Allow-Origin)"
    message: |
      This application potentially allows user-supplied input into the value of the
      `Access-Control-Allow-Origin` response header. This header is part of the
      [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) CORS
      specification. By allowing user input to specify which domains can communicate with this
      server,
      an adversary could exploit a weakness in this server to force clients to send credentials (such
      as session
      identifiers) to the adversary's server.
      
      For the above attack to work, the application would need to suffer from an additional
      vulnerability,
      such as Cross-Site Scripting (XSS).
      
      To remediate this issue, do not use user-supplied information when calling
      `HttpServletResponse.setHeader` or `HttpServletResponse.addHeader`
      for the `Access-Control-Allow-Origin` header's value. Instead, hardcode the allowed domain(s)
      and reference them in a lookup
      table:
      Example allowing dynamic but safe domains in `Access-Control-Allow-Origin`:
      
      ```
        // this data should be in the class constructor or taken from a trusted datasource
        Map<String, String> allowedDomains = new HashMap();
        allowedDomains.put("sub1", "sub1.example.com");
        allowedDomains.put("sub2", "sub2.example.com");
      
        // extract the allowedDomain parameters value as a key to look up which domain to provide
      via the allowedDomains map
        // if not found, sets sub1 as the default
        String headerValue = allowedDomains.getOrDefault(request.getParameter("allowedDomain"),
      allowedDomains.get("sub1"));
      
        // add the header with our trusted sub1.example.com or sub2.example.com domains.
        response.addHeader("Access-Control-Allow-Origin", headerValue);
      }
      ```
      
      For more information on `Access-Control-Allow-Origin` see:
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
    severity: ERROR
    metadata:
      shortDescription: Permissive cross-domain policy with untrusted domains
      cwe: CWE-942
      category: security
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.PERMISSIVE_CORS-2
      secondary_identifiers:
        - name: Find Security Bugs-PERMISSIVE_CORS
          type: find_sec_bugs_type
          value: PERMISSIVE_CORS
  - id: find_sec_bugs.BLOWFISH_KEY_SIZE-1
    languages:
      - java
    patterns:
      - pattern-inside: |
          $KEYGEN = javax.crypto.KeyGenerator.getInstance("Blowfish", ...);
          ...
          $KEYGEN.init($KEY_SIZE);
      - metavariable-comparison:
          comparison: "$KEY_SIZE < 128"
          metavariable: "$KEY_SIZE"
    message: |
      The Blowfish encryption algorithm was meant as a drop-in replacement for DES and was created in
      1993. Smaller key sizes may make the ciphertext vulnerable to [birthday
      attacks](https://en.wikipedia.org/wiki/Birthday_attack). While no known attacks against
      Blowfish
      exist, it should never be used to encrypt files over 4GB in size. If possible consider
      using AES as the instance of `KeyGenerator` instead of Blowfish.
      
      To remediate the small key size, pass a value such as 256 to the `KeyGenerator.init(keySize)`
      method.
      
      Example setting a larger key size and changing to `KeyGenerator` to AES:
      ```
      public static void aesKeyGenerator() throws java.security.NoSuchAlgorithmException {
          // Use the AES algorithm for key generation
          KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
      
          // Set the key size here
          keyGenerator.init(256);
      
          // get the raw bytes of the key
          byte[] key = keyGenerator.generateKey().getEncoded();
      
          // pass the key bytes to create a SecretKeySpec
          SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES");
      }
      ```
      
      Example setting a larger key size for Blowfish:
      ```
      public static void blowFishKeyGenerator() throws java.security.NoSuchAlgorithmException {
          // Use the Blowfish algorithm for key generation
          KeyGenerator keyGenerator = KeyGenerator.getInstance("Blowfish");
      
          // Set the key size here
          keyGenerator.init(256);
      
          // get the raw bytes of the key
          byte[] key = keyGenerator.generateKey().getEncoded();
      
          // pass the key bytes to create a SecretKeySpec
          SecretKeySpec secretKeySpec = new SecretKeySpec(key, "Blowfish");
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: WARNING
    metadata:
      category: security
      shortDescription: Inadequate encryption strength
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      cwe: CWE-326
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.BLOWFISH_KEY_SIZE-1
      secondary_identifiers:
        - name: Find Security Bugs-BLOWFISH_KEY_SIZE
          type: find_sec_bugs_type
          value: BLOWFISH_KEY_SIZE
  - id: find_sec_bugs.DES_USAGE-1
    languages:
      - java
    patterns:
      - pattern-inside: javax.crypto.Cipher.getInstance("$ALG")
      - metavariable-regex:
          metavariable: "$ALG"
          regex: "^(DES)/.*"
    message: |
      DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.
      Newer algorithms  apply message integrity to validate ciphertext has not been tampered
      with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the
      alternatives such as `AES-256-GCM`.
      
      For older applications that don't have support for `ChaCha20Poly1305`,
      `AES-256-GCM` is recommended, however it has many drawbacks:
      - Slower than `ChaCha20Poly1305`.
      - Catastrophic failure if nonce values are reused.
      
      Example using `ChaCha20Poly1305`:
      ```
      public encrypt() throws Exception {
          chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
      }
      
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
          // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      
      public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
      NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
      InvalidAlgorithmParameterException  {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create a ChaCha20-Poly1305 cipher instance
          Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          // Create our parameterSpec using our ivKey
          AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
          // Create a SecretKeySpec using our secretKey
          SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
          // Initialize and return the cipher for the provided mode
          chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
          return chaChaCipher;
      }
      
      public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
      NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create secretKey
          byte[] secretKey = new byte[32];
          random.nextBytes(secretKey);
          // Create an IV Key
          byte[] ivKey = new byte[12];
          random.nextBytes(ivKey);
      
          // Create a chaCha encryption cipher instance
          Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);
      
          // Encrypt the text using ChaCha20Poly1305
          byte[] cipherText = null;
          try {
              cipherText = chaChaEncryptor.doFinal(plainText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to encrypt text");
              return;
          }
          System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
      
           // Create a chaCha decryption cipher instance
          Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);
      
          // Decrypt the text
          byte[] decryptedText = null;
          try {
              decryptedText = chaChaDecryptor.doFinal(cipherText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to decrypt text");
              return;
          }
          System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: WARNING
    metadata:
      shortDescription: Inadequate encryption strength
      category: security
      cwe: CWE-326
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.DES_USAGE-1
      secondary_identifiers:
        - name: Find Security Bugs-DES_USAGE
          type: find_sec_bugs_type
          value: DES_USAGE
  - id: find_sec_bugs.TDES_USAGE-1
    languages:
      - java
    patterns:
      - pattern-inside: javax.crypto.Cipher.getInstance("$ALG")
      - metavariable-regex:
          metavariable: "$ALG"
          regex: "^(DESede)/.*"
    message: |
      DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.
      Newer algorithms  apply message integrity to validate ciphertext has not been tampered
      with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the
      alternatives such as `AES-256-GCM`.
      
      For older applications that don't have support for `ChaCha20Poly1305`,
      `AES-256-GCM` is recommended, however it has many drawbacks:
      - Slower than `ChaCha20Poly1305`.
      - Catastrophic failure if nonce values are reused.
      
      Example using `ChaCha20Poly1305`:
      ```
      public encrypt() throws Exception {
          chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
      }
      
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
          // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      
      public Cipher getChaCha20Poly1305(int mode, byte[] nonceKey, byte[] secretKey) throws
      NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
      InvalidAlgorithmParameterException  {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create a ChaCha20-Poly1305 cipher instance
          Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          // Create our parameterSpec using our nonceKey
          AlgorithmParameterSpec parameterSpec = new IvParameterSpec(nonceKey);
          // Create a SecretKeySpec using our secretKey
          SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
          // Initialize and return the cipher for the provided mode
          chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
          return chaChaCipher;
      }
      
      public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
      NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create secretKey
          byte[] secretKey = new byte[32];
          random.nextBytes(secretKey);
          // Create an IV nonceKey
          byte[] nonceKey = new byte[12];
          random.nextBytes(nonceKey);
          // Create a chaCha encryption cipher instance
          Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, nonceKey, secretKey);
          // Encrypt the text using ChaCha20Poly1305
          byte[] cipherText = null;
          try {
              cipherText = chaChaEncryptor.doFinal(plainText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to encrypt text");
              return;
          }
          System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
          // Create a chaCha decryption cipher instance
          Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, nonceKey, secretKey);
          // Decrypt the text
          byte[] decryptedText = null;
          try {
              decryptedText = chaChaDecryptor.doFinal(cipherText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to decrypt text");
              return;
          }
          System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: WARNING
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      category: security
      cwe: CWE-327
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.TDES_USAGE-1
      secondary_identifiers:
        - name: Find Security Bugs-TDES_USAGE
          type: find_sec_bugs_type
          value: TDES_USAGE
  - id: find_sec_bugs.ECB_MODE-1
    languages:
      - java
    patterns:
      - pattern-inside: javax.crypto.Cipher.getInstance("...")
      - pattern-regex: "(AES|DES(ede)?)(/ECB/*)"
    message: |
      Cryptographic algorithms provide many different modes of operation, only some of which provide
      message integrity. Without message integrity it could be possible for an adversary to attempt
      to tamper with the ciphertext which could lead to compromising the encryption key. Newer
      algorithms
      apply message integrity to validate ciphertext has not been tampered with.
      
      Instead of using an algorithm that requires configuring a cipher mode, an algorithm
      that has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or
      `AES-256-GCM` instead.
      
      For older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is
      recommended, however it has many drawbacks:
        - Slower than `ChaCha20Poly1305`.
        - Catastrophic failure if nonce values are reused.
      
      Example using `ChaCha20Poly1305`:
      ```
      public encrypt() throws Exception {
          chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
      }
      
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
          // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      
      public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
      NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
      InvalidAlgorithmParameterException  {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create a ChaCha20-Poly1305 cipher instance
          Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          // Create our parameterSpec using our ivKey
          AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
          // Create a SecretKeySpec using our secretKey
          SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
          // Initialize and return the cipher for the provided mode
          chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
          return chaChaCipher;
      }
      
      public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
      NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create secretKey
          byte[] secretKey = new byte[32];
          random.nextBytes(secretKey);
          // Create an IV Key
          byte[] ivKey = new byte[12];
          random.nextBytes(ivKey);
      
          // Create a chaCha encryption cipher instance
          Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);
      
          // Encrypt the text using ChaCha20Poly1305
          byte[] cipherText = null;
          try {
              cipherText = chaChaEncryptor.doFinal(plainText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to encrypt text");
              return;
          }
          System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
      
           // Create a chaCha decryption cipher instance
          Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);
      
          // Decrypt the text
          byte[] decryptedText = null;
          try {
              decryptedText = chaChaDecryptor.doFinal(cipherText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to decrypt text");
              return;
          }
          System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: ERROR
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      category: security
      cwe: CWE-327
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.ECB_MODE-1
      secondary_identifiers:
        - name: Find Security Bugs-ECB_MODE
          type: find_sec_bugs_type
          value: ECB_MODE
  - id: find_sec_bugs.CIPHER_INTEGRITY-1
    languages:
      - java
    patterns:
      - pattern-inside: javax.crypto.Cipher.getInstance("...")
      - pattern-either:
          - pattern-regex: "(/CBC/PKCS5Padding)"
          - pattern-regex: "(AES|DES(ede)?)(/ECB/*)"
      - pattern-not-regex: ".*/(CCM|CWC|OCB|EAX|GCM)/.*"
      - pattern-not-regex: "^(RSA)/.*"
      - pattern-not-regex: "^(ECIES)$"
    message: |
      Cryptographic algorithms provide many different modes of operation, only some of which provide
      message integrity. Without message integrity it could be possible for an adversary to attempt
      to tamper with the ciphertext which could lead to compromising the encryption key. Newer
      algorithms
      apply message integrity to validate ciphertext has not been tampered with.
      
      Instead of using an algorithm that requires configuring a cipher mode, an algorithm
      that has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or
      `AES-256-GCM` instead.
      
      For older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is
      recommended, however it has many drawbacks:
        - Slower than `ChaCha20Poly1305`.
        - Catastrophic failure if nonce values are reused.
      
      Example using `ChaCha20Poly1305`:
      ```
      public encrypt() throws Exception {
          chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
      }
      
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
      // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      
      public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
      NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
      InvalidAlgorithmParameterException  {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create a ChaCha20-Poly1305 cipher instance
          Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          // Create our parameterSpec using our ivKey
          AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
          // Create a SecretKeySpec using our secretKey
          SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
          // Initialize and return the cipher for the provided mode
          chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
          return chaChaCipher;
      }
      
      public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
      NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create secretKey
          byte[] secretKey = new byte[32];
          random.nextBytes(secretKey);
          // Create an IV Key
          byte[] ivKey = new byte[12];
          random.nextBytes(ivKey);
      
          // Create a chaCha encryption cipher instance
          Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);
      
          // Encrypt the text using ChaCha20Poly1305
          byte[] cipherText = null;
          try {
              cipherText = chaChaEncryptor.doFinal(plainText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to encrypt text");
              return;
          }
          System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
      
           // Create a chaCha decryption cipher instance
          Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);
      
          // Decrypt the text
          byte[] decryptedText = null;
          try {
              decryptedText = chaChaDecryptor.doFinal(cipherText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to decrypt text");
              return;
          }
          System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: ERROR
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      category: security
      cwe: CWE-327
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.CIPHER_INTEGRITY-1
      secondary_identifiers:
        - name: Find Security Bugs-CIPHER_INTEGRITY
          type: find_sec_bugs_type
          value: CIPHER_INTEGRITY
  - id: find_sec_bugs.PADDING_ORACLE-1
    languages:
      - java
    patterns:
      - pattern-inside: javax.crypto.Cipher.getInstance("...")
      - pattern-regex: "(/CBC/PKCS5Padding)"
      - pattern-not-regex: "^(RSA)/.*"
      - pattern-not-regex: "^(ECIES)$"
    message: |
      Cryptographic block ciphers can be configured to pad individual blocks if there is not enough
      input data to match the size of the block. This specific mode of CBC used in combination with
      PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt
      the message if the system exposed the difference between plaintext with invalid padding or
      valid padding. The distinction between valid and invalid padding is usually revealed through
      distinct error messages being returned for each condition.
      
      Consider switching to a more secure cipher that doesn't require padding and builds in message
      authentication integrity directly into the algorithm.
      
      Consider using `ChaCha20Poly1305` or
      `AES-256-GCM` instead.
      
      For older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is
      recommended, however it has many drawbacks:
        - Slower than `ChaCha20Poly1305`.
        - Catastrophic failure if nonce values are reused.
      
      Example using `ChaCha20Poly1305`:
      ```
      public encrypt() throws Exception {
          chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
      }
      
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
          // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      
      public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
      NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
      InvalidAlgorithmParameterException  {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create a ChaCha20-Poly1305 cipher instance
          Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          // Create our parameterSpec using our ivKey
          AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
          // Create a SecretKeySpec using our secretKey
          SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
          // Initialize and return the cipher for the provided mode
          chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
          return chaChaCipher;
      }
      
      public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
      NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create secretKey
          byte[] secretKey = new byte[32];
          random.nextBytes(secretKey);
          // Create an IV Key
          byte[] ivKey = new byte[12];
          random.nextBytes(ivKey);
      
          // Create a chaCha encryption cipher instance
          Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);
      
          // Encrypt the text using ChaCha20Poly1305
          byte[] cipherText = null;
          try {
              cipherText = chaChaEncryptor.doFinal(plainText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to encrypt text");
              return;
          }
          System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
      
           // Create a chaCha decryption cipher instance
          Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);
      
          // Decrypt the text
          byte[] decryptedText = null;
          try {
              decryptedText = chaChaDecryptor.doFinal(cipherText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to decrypt text");
              return;
          }
          System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
      }
      ```
      
      For more information on padding oracle attacks see:
      https://en.wikipedia.org/wiki/Padding_oracle_attack
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: ERROR
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      category: security
      cwe: CWE-327
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.PADDING_ORACLE-1
      secondary_identifiers:
        - name: Find Security Bugs-PADDING_ORACLE
          type: find_sec_bugs_type
          value: PADDING_ORACLE
  - id: find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1
    languages:
      - java
    patterns:
      - pattern: |
          class $CLAZZ extends java.security.MessageDigest {
            ...
          }
    message: |
      The application was found implementing a custom `java.security.MessageDigest`. It is
      strongly recommended that a standard Digest algorithm be chosen instead as implementing
      a digest by hand is error-prone. The National Institute of Standards and
      Technology (NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or
      SHA-512/256.
      
      Example of creating a SHA-384 hash:
      ```
      // Create a MessageDigest using the SHA-384 algorithm
      MessageDigest sha384Digest = MessageDigest.getInstance("SHA-384");
      // Call update with your data
      sha384Digest.update(input);
      // Only call digest once all data has been fed into the update sha384digest instance
      byte[] output = sha384Digest.digest();
      // output base64 encoded version of the hash
      System.out.println("hash: " + Base64.getEncoder().encodeToString(output));
      ```
    severity: WARNING
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      category: security
      cwe: CWE-327
      owasp:
        - A6:2017-Security Misconfiguration
        - A04:2021-Insecure Design
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1
      secondary_identifiers:
        - name: Find Security Bugs-CUSTOM_MESSAGE_DIGEST
          type: find_sec_bugs_type
          value: CUSTOM_MESSAGE_DIGEST
  - id: find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1
    languages:
      - java
    patterns:
      - pattern: new com.hazelcast.config.SymmetricEncryptionConfig()
    message: |
      The network communications for Hazelcast is configured to use a deprecated symmetric cipher.
      Consider using TLS/SSL when establishing communications across the Hazelcast cluster.
      
      For more information on configuring TLS/SSL for Hazelcast see:
      https://docs.hazelcast.com/imdg/4.2/security/tls-ssl
    severity: WARNING
    metadata:
      shortDescription: Inadequate encryption strength
      category: security
      cwe: CWE-326
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1
      secondary_identifiers:
        - name: Find Security Bugs-HAZELCAST_SYMMETRIC_ENCRYPTION
          type: find_sec_bugs_type
          value: HAZELCAST_SYMMETRIC_ENCRYPTION
  - id: find_sec_bugs.RSA_KEY_SIZE-1
    languages:
      - java
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  $GEN = KeyPairGenerator.getInstance($ALG, ...);
                  ...
              - pattern-either:
                  - pattern: "$VAR.initialize($SIZE, ...);"
                  - pattern: new java.security.spec.RSAKeyGenParameterSpec($SIZE,...);
              - metavariable-comparison:
                  comparison: "$SIZE < 2048"
                  metavariable: "$SIZE"
              - metavariable-regex:
                  metavariable: "$ALG"
                  regex: '"(RSA|DSA)"'
    message: |
      The application is generating an RSA key that is less than the recommended 2048 bits.
      The National Institute of Standards and Technology (NIST) deprecated signing Digital
      Certificates that contained RSA Public Keys of 1024 bits in December 2010. While
      1024-bit RSA keys have not been factored yet, advances in compute may make it possible
      in the near future.
      
      Consider upgrading to the newer asymmetric algorithm such as `Ed25519` which handles
      the complexities of generating key pairs and choosing correct key sizes for you:
      ```
      public static KeyPair generateEd25519() throws NoSuchAlgorithmException {
          // Choose Ed25519 for KeyPairGenerator Instance
          KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("Ed25519");
          // Generate a KeyPair and return
          return keyPairGenerator.generateKeyPair();
      }
      ```
      
      Otherwise use a key size greater than 2048 when generating RSA keys:
      ```
      public static KeyPair generateRSA() throws NoSuchAlgorithmException {
          // Choose RSA for KeyPairGenerator Instance
          KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
          // Initialize with 2048 key size
          keyPairGenerator.initialize(2048);
          // Generate a KeyPair and return
          return keyPairGenerator.generateKeyPair();
      }
      ```
      
      For more information on Ed25519 see: http://ed25519.cr.yp.to/
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    metadata:
      shortDescription: Inadequate encryption strength
      category: security
      cwe: CWE-326
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.RSA_KEY_SIZE-1
      secondary_identifiers:
        - name: Find Security Bugs-RSA_KEY_SIZE
          type: find_sec_bugs_type
          value: RSA_KEY_SIZE
    severity: WARNING
  - id: find_sec_bugs.NULL_CIPHER-1
    languages:
      - java
    pattern: new javax.crypto.NullCipher()
    message: |
      The application was found creating a `NullCipher` instance. `NullCipher` implements the
      `Cipher` interface by returning ciphertext identical to the supplied plaintext. This means
      any data passed to the `doFinal(...)` or `update(...)` methods will not actually encrypt
      the input.
      
      Remove the NullCipher reference and replace with a legitimate `Cipher` instance such as
      `ChaCha20-Poly1305`
      
      Example using `ChaCha20Poly1305`:
      ```
      public encrypt() throws Exception {
          chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
      }
      
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
          // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      
      public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
      NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
      InvalidAlgorithmParameterException  {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create a ChaCha20-Poly1305 cipher instance
          Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          // Create our parameterSpec using our ivKey
          AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
          // Create a SecretKeySpec using our secretKey
          SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
          // Initialize and return the cipher for the provided mode
          chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
          return chaChaCipher;
      }
      
      public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
      NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
          // Get a DRBG random number generator instance
          SecureRandom random = getSecureRandomDRBG();
          // Create secretKey
          byte[] secretKey = new byte[32];
          random.nextBytes(secretKey);
          // Create an IV Key
          byte[] ivKey = new byte[12];
          random.nextBytes(ivKey);
      
          // Create a chaCha encryption cipher instance
          Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);
      
          // Encrypt the text using ChaCha20Poly1305
          byte[] cipherText = null;
          try {
              cipherText = chaChaEncryptor.doFinal(plainText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to encrypt text");
              return;
          }
          System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
      
           // Create a chaCha decryption cipher instance
          Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);
      
          // Decrypt the text
          byte[] decryptedText = null;
          try {
              decryptedText = chaChaDecryptor.doFinal(cipherText);
          } catch (IllegalBlockSizeException | BadPaddingException e) {
              System.out.println("failed to decrypt text");
              return;
          }
          System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: WARNING
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      category: security
      cwe: CWE-327
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.NULL_CIPHER-1
      secondary_identifiers:
        - name: Find Security Bugs-NULL_CIPHER
          type: find_sec_bugs_type
          value: NULL_CIPHER
  - id: find_sec_bugs.RSA_NO_PADDING-1
    languages:
      - java
    pattern-either:
      - patterns:
          - pattern: |
              $VAR = "$ALG";
              ...
              javax.crypto.Cipher.getInstance($VAR);
          - metavariable-regex:
              metavariable: "$ALG"
              regex: ".*RSA.*NoPadding.*"
      - patterns:
          - pattern: javax.crypto.Cipher.getInstance($ALG,...);
          - metavariable-regex:
              metavariable: "$ALG"
              regex: ".*RSA.*NoPadding.*"
    message: |
      The software uses the RSA algorithm but does not incorporate Optimal Asymmetric
      Encryption Padding (OAEP). By not enabling padding, the algorithm maybe vulnerable
      to [chosen plaintext attacks](https://en.wikipedia.org/wiki/Chosen-plaintext_attack).
      
      To enable OAEP mode, pass `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` to the `Cipher.getInstance`
      method.
      
      Example encrypting and decrypting a message using RSA with OAEP:
      ```
      public static void encryptWithRSA() throws InvalidKeyException, NoSuchAlgorithmException,
      NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
          // Generate an RSA Public and Private Key Pair
          KeyPair keyPair = generateRSAKeys();
          // Create a Cipher instance using RSA, ECB with OAEP
          Cipher rsaEncryptor = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
          // Initialize to ENCRYPT_MODE with the public key
          rsaEncryptor.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
          // Encrypt our secret message
          byte[] cipherText = rsaEncryptor.doFinal("Some secret
      message".getBytes(StandardCharsets.UTF_8));
      
          // Create a Cipher instance using RSA, ECB with OAEP
          Cipher rsaDecryptor = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
          // Initialize to DECRYPT_MODE with the private key
          rsaDecryptor.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
          // Decrypt the secret message
          byte[] plainText = rsaDecryptor.doFinal(cipherText);
          // Debug output
          System.out.println(new String(plainText));
      }
      ```
      More information on Optimal asymmetric encryption padding:
      https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    metadata:
      shortDescription: Use of RSA algorithm without OAEP
      category: security
      cwe: CWE-780
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.RSA_NO_PADDING-1
      secondary_identifiers:
        - name: Find Security Bugs-RSA_NO_PADDING
          type: find_sec_bugs_type
          value: RSA_NO_PADDING
    severity: WARNING
  - id: find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: MessageDigest.getInstance($ALG, ...)
          - pattern: Signature.getInstance($ALG, ...)
      - metavariable-regex:
          metavariable: "$ALG"
          regex: ".*(MD5|MD4|MD2|SHA1|SHA-1).*"
    message: |
      The application was found using an insecure or risky digest or signature algorithm. Both MD5
      and SHA1 hash algorithms have been found to be vulnerable to producing collisions.
      This means
      that two different values, when hashed, can lead to the same hash value. If the application is
      trying
      to use these hash methods for storing passwords, then it is recommended to switch to a
      password hashing
      algorithm such as Argon2id or PBKDF2.
      strongly recommended that a standard Digest algorithm be chosen instead as implementing
      a digest by hand is error-prone.
      
      Example of creating a SHA-384 hash:
      ```
      // Create a MessageDigest using the SHA-384 algorithm
      MessageDigest sha384Digest = MessageDigest.getInstance("SHA-384");
      // Call update with your data
      sha384Digest.update(input);
      // Only call digest once all data has been fed into the update sha384digest instance
      byte[] output = sha384Digest.digest();
      // output base64 encoded version of the hash
      System.out.println("hash: " + Base64.getEncoder().encodeToString(output));
      ```
      
      For more information on secure password storage see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
    severity: WARNING
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm (SHA1/MD5)
      category: security
      cwe: CWE-327
      owasp:
        - A6:2017-Security Misconfiguration
        - A04:2021-Insecure Design
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1
      secondary_identifiers:
        - name: Find Security Bugs-WEAK_MESSAGE_DIGEST_MD5
          type: find_sec_bugs_type
          value: WEAK_MESSAGE_DIGEST_MD5
        - name: Find Security Bugs-WEAK_MESSAGE_DIGEST_SHA1
          type: find_sec_bugs_type
          value: WEAK_MESSAGE_DIGEST_SHA1
  - id: find_sec_bugs.SSL_CONTEXT-1
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: new org.apache.http.impl.client.DefaultHttpClient();
          - pattern: javax.net.ssl.SSLContext.getInstance("SSL");
    message: |
      The `org.apache.http.impl.client.DefaultHttpClient` and `javax.net.ssl.SSLContext.getInstance`
      object instances do not verify the hostnames upon connection.
      
      This allows for an adversary who is in between the application and the target host to intercept
      potentially sensitive information or transmit malicious data.
      
      Do not use the `org.apache.http.impl.client.DefaultHttpClient();` as it is deprecated. Instead
      use the new `java.net.http.HttpClient` that was introduced in Java 9.
      
      Example connecting to a host that will automatically do TLS validation:
      ```
      // Create a new java.net.http.HttpClient
      HttpClient httpClient = HttpClient.newHttpClient();
      // Create a HttpRequest builder
      HttpRequest request = HttpRequest.newBuilder()
              // Create a URI for a website which requires TLS
              .uri(URI.create("https://www.example.com/"))
              // Build the request
              .build();
      
      // Use the httpClient to send the request and use an HttpResponse.BodyHandlers String type
      HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
      // Debug print
      System.out.println(response);
      ```
    metadata:
      shortDescription: Improper certificate validation
      category: security
      cwe: CWE-295
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.SSL_CONTEXT-1
      secondary_identifiers:
        - name: Find Security Bugs-SSL_CONTEXT
          type: find_sec_bugs_type
          value: SSL_CONTEXT
    severity: WARNING
  - id: find_sec_bugs.SSL_CONTEXT-2
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              import javax.net.ssl.*;
              ...
          - pattern-inside: |
              import javax.net.ssl.SSLContext;
              ...
      - pattern-either:
          - pattern-inside: 'SSLContext.getInstance("$UNSAFE_VERSION");

        '
          - pattern-inside: |
              SSLContext.getInstance(...);
              ...
              $ENGINE.setEnabledProtocols(new String[]{...,"$UNSAFE_VERSION",...});
      - pattern-not-inside: |
          $C = SSLContext.getInstance(...);
          ...
          $ENGINE.setEnabledProtocols(new String[]{...,"TLSv1.2",...});
      - pattern-not-inside: |
          $C = SSLContext.getInstance(...);
          ...
          $ENGINE.setEnabledProtocols(new String[]{...,"TLSv1.3",...});
      - pattern-not-inside: |
          $C = SSLContext.getInstance(...);
          ...
          $ENGINE.setEnabledProtocols(new String[]{...,"DTLSv1.2",...});
      - pattern-not-inside: |
          $C = SSLContext.getInstance(...);
          ...
          $ENGINE.setEnabledProtocols(new String[]{...,"DTLSv1.3",...});
      - metavariable-regex:
          metavariable: "$UNSAFE_VERSION"
          regex: "^(TLS|(D)?TLSv1.(0|1))$"
    message: |
      The application was found enabling insecure TLS protocol versions. When enabling protocol
      versions for an `SSLContext`, only the following versions should be allowed:
      - TLSv1.2
      - TLSv1.3
      - DTLSv1.2
      - DTLSv1.3
      
      To mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum
      protocol version and disallow older versions such as TLS 1.0. Do note that newer versions of
      Java do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS
      prior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts
      the
      connection and alters the requested protocol version to be a less secure one.
      
      In many scenarios, relying on the default system configuration does not meet compliance
      standards. This is due to the application being deployed across diverse systems with varying
      configurations and Java versions. While the default value may be secure on modern and
      up-to-date systems, it may not hold true for older systems. Consequently, it is highly
      recommended to explicitly define a secure configuration in all cases.
      
      Example configuring an SSLContext with TLSv1.2:
      ```
      // Create an SSLContext with TLSv1.2 explicitly
      SSLContext tlsContext = SSLContext.getInstance("TLSv1.2"); // or TLSv1.3, DTLSv1.2, DTLSv1.3
      
      // Alternatively, set the enabled protocols
      SSLContext serverSslContext = SSLContext.getInstance("TLS");
      SSLEngine serverEngine = serverSslContext.createSSLEngine();
      // Calling setEnabledProtocols will override the original context's configured protocol version
      serverEngine.setEnabledProtocols(new String[]{ "TLSv1.2" });
      ```
      
      For more information on `SSLContext` see:
      - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html
      
      For more information on MiTM attacks see:
      - https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack
    metadata:
      shortDescription: Inadequate encryption strength
      category: security
      cwe: CWE-326
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.SSL_CONTEXT-2
      secondary_identifiers:
        - name: Find Security Bugs-SSL_CONTEXT
          type: find_sec_bugs_type
          value: SSL_CONTEXT
    severity: WARNING
  - id: find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1
    languages:
      - java
    pattern-either:
      - pattern: "(org.springframework.security.config.annotation.web.builders.HttpSecurity
      $H). ... .csrf().disable();"
      - pattern: "(org.springframework.security.config.annotation.web.configurers.CsrfConfigurer<HttpSecurity>
      $C).disable();"
    message: |
      The application fails to protect against Cross-Site Request Forgery (CSRF)
      due to disabling Spring's CSRF protection features.
      
      The vulnerability can be exploited by an adversary creating a link or form on a third
      party site and tricking an authenticated victim to access them.
      
      To remediate this issue, remove the call to `HttpSecurity.csrf().disable()` or remove
      the custom `CsrfConfigurer`.
      
      For more information on CSRF protection in Spring see:
      https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf
      
      Additionally, consider setting all session cookies to have the `SameSite=Strict` attribute.
      It should be noted that this may impact usability when sharing links across other mediums.
      It is recommended that a two cookie based approach is taken, as outlined in the
      [Top level
      navigations](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-08#section-8.8.2)
      section
      of the SameSite RFC.
      
      For more information on CSRF see OWASP's guide:
      https://owasp.org/www-community/attacks/csrf
    metadata:
      shortDescription: Cross-Site Request Forgery (CSRF)
      category: security
      cwe: CWE-352
      owasp:
        - A5:2017-Broken Access Control
        - A01:2021-Broken Access Control
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1
      secondary_identifiers:
        - name: Find Security Bugs-SPRING_CSRF_PROTECTION_DISABLED
          type: find_sec_bugs_type
          value: SPRING_CSRF_PROTECTION_DISABLED
    severity: WARNING
  - id: find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1
    languages:
      - java
    message: "Unvalidated redirects occur when an application redirects a user to a\ndestination
    URL specified by a user supplied parameter that is not validated.\nSuch vulnerabilities
    can be used to facilitate phishing attacks.\n\nTo avoid open redirect vulnerabilities
    in Java, one effective strategy is to\nonly allow redirection to URLs that are
    pre-defined in a safe list. This safe\nlist can be implemented using a collection
    like a Map, List, or Dictionary,\nwhere you store all the valid URLs or URL patterns.
    When a redirect request is\nmade, you can check if the requested URL is in this
    safe list before proceeding \nwith the redirection. For example:\n\n```\n  protected
    void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException,
    IOException {\n      private List<String> safeUrls = new ArrayList<>();\n      safeUrls.add(\"/home\");\n
    \     safeUrls.add(\"/user/profile\");\n      safeUrls.add(\"/dashboard\");\n
    \     \n      String redirectUrl = request.getParameter(\"url\");\n\n      if
    (safeUrls.contains(redirectUrl)) {\n          response.sendRedirect(redirectUrl);\n
    \     } else {\n          response.sendRedirect(\"/errorPage\");\n      }\n  }\"\n```
    \ \n"
    mode: taint
    pattern-sources:
      - patterns:
          - pattern: "$URL = ($X.servlet.http.HttpServletRequest $REQ).$M(...);\n"
          - metavariable-regex:
              metavariable: "$M"
              regex: "(getParameter|getCookies|getHeader|getHeaders|getHeaderNames|getPathInfo|getPathTranslated|getContextPath|getQueryString|getRemoteUser|getRequestedSessionId|getRequestURI|getRequestURL|getServletPath|getParts|getPart|getReader)"
    pattern-sinks:
      - pattern-either:
          - pattern: "($X.servlet.http.HttpServletResponse $RES).sendRedirect($URL)\n"
          - pattern: '($X.servlet.http.HttpServletResponse $RES).addHeader("Location", $URL)

        '
    pattern-sanitizers:
      - patterns:
          - pattern-inside: |
              if ($SAFE.contains($URL)){
                ...
              }
          - pattern-either:
              - pattern: "($X.servlet.http.HttpServletResponse $RES).sendRedirect($URL)\n"
              - pattern: '($X.servlet.http.HttpServletResponse $RES).addHeader("Location",
          $URL)

          '
    metadata:
      category: security
      cwe: CWE-601
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      shortDescription: URL redirection to untrusted site ('Open Redirect')
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1
      secondary_identifiers:
        - name: Find Security Bugs-UNVALIDATED_REDIRECT
          type: find_sec_bugs_type
          value: UNVALIDATED_REDIRECT
        - name: Find Security Bugs-URL_REWRITING
          type: find_sec_bugs_type
          value: URL_REWRITING
    severity: ERROR
  - id: find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1
    languages:
      - java
    message: |
      Either the `HostnameVerifier` has been set to always return `true` or the `X509TrustManager`
      has
      been configured to return null, or both. This effectively disables the validation of server or
      client certificates.
      
      This allows for an adversary who is in between the application and the target host to intercept
      potentially sensitive information or transmit malicious data.
      
      It is recommended to not override the default `HostnameVerifiers`.
      
      Consider using the default `TrustManager` instead of implementing a custom one. If you must
      override
      the default verification process, implement proper TrustManager verification for
      `checkServerTrusted` and
      `checkClientTrusted` by throwing `CertificateException` if the certificate is invalid.
      
      Example using the built in `TrustManagerFactory` to manage validating certificate chains:
      ```
      // Use the default TrustManagerFactory
      TrustManagerFactory trustManagerFactory =
      TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      // Use default system KeyStore, alternatively pass in your own keystore.
      trustManagerFactory.init((KeyStore) null);
      // Create SSLContext for TLS connections
      SSLContext tlsContext = SSLContext.getInstance("TLS");
      // Initialize the tlsContext with our trust manager and a SecureRandom number generator.
      tlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());
      ```
      
      For more information on TLS security see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  class $V implements HostnameVerifier {
                    ...
                  }
              - pattern-inside: |
                  public boolean verify(...) {
                    ...
                  }
              - pattern: return true;
          - patterns:
              - pattern-inside: |
                  class $V implements X509TrustManager {
                    ...
                  }
              - pattern-either:
                  - pattern: public void checkClientTrusted(...) {}
                  - pattern: public void checkServerTrusted(...) {}
                  - pattern: |
                      public X509Certificate[] getAcceptedIssuers() {
                        ...
                        return null;
                      }
    metadata:
      shortDescription: Improper certificate validation
      category: security
      owasp:
        - A2:2017-Broken Authentication
        - A07:2021-Identification and Authentication Failures
      cwe: CWE-295
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1
      secondary_identifiers:
        - name: Find Security Bugs-WEAK_HOSTNAME_VERIFIER
          type: find_sec_bugs_type
          value: WEAK_HOSTNAME_VERIFIER
        - name: Find Security Bugs-WEAK_TRUST_MANAGER
          type: find_sec_bugs_type
          value: WEAK_TRUST_MANAGER
    severity: WARNING
  - id: find_sec_bugs.FILE_UPLOAD_FILENAME-1
    languages:
      - java
    message: "The filename provided by the FileUpload API can be tampered with\nwhich
    could lead to unauthorized access or file inclusion vulnerabilities. \nTo mitigate
    this risk, it is essential to conduct rigorous validation of the\nfilenames provided
    by clients. This validation should ensure that the filename \nadheres to a predefined
    structure, is devoid of potentially dangerous characters \n(such as forward slashes
    / and backslashes \\), and corresponds to an authorized \nfile only.\n\nFor example,
    as a remediation strategy, the application could:\n1. Sanitize Filenames: Create
    a function to sanitize filenames by removing \n   or replacing unauthorized characters,
    including path traversal sequences (../ or ..\\).\n2. Allowlist Validation: Implement
    a allowlist approach, allowing only filenames\n   that match a specific pattern
    or are part of a predefined list.\n3. Use Server-Generated Filenames: Rather than
    relying on client-provided filenames, \n   generate unique names server-side for
    storing files.\n4. Verify File Paths: Ensure files are being saved in the correct,
    \n   intended directory, and prevent redirection to unauthorized directories.\n\nExample
    remediation:\n```\n  public class FileUploadHandler {\n\n        protected void
    doPost(HttpServletRequest request, HttpServletResponse response)\n              throws
    ServletException, IOException {\n          \n          Part filePart = request.getPart(\"file\");
    \n          String fileName = filePart.getSubmittedFileName(); \n\n          //
    removes any path information from the filename\n          String sanitizedFileName
    = sanitizeFileName(fileName);\n          if (!isFileNameAllowed(sanitizedFileName))
    {\n              throw new SecurityException(\"Invalid file name\");\n          }\n\n
    \         // Generate a unique file name for storage\n          String storedFileName
    = UUID.randomUUID().toString() + \".txt\";\n\n          Path targetPath = Paths.get(\"uploads\").resolve(storedFileName);\n
    \         Files.copy(fileContent, targetPath, StandardCopyOption.REPLACE_EXISTING);\n
    \     }\n\n      private String sanitizeFileName(String fileName) {\n          return
    Paths.get(fileName).getFileName().toString();\n      }\n\n      private boolean
    isFileNameAllowed(String fileName) {\n          return fileName.matches(\"[a-zA-Z0-9._-]+\");\n
    \     }\n  }\n```\n"
    pattern-either:
      - patterns:
          - pattern-inside: |
              $FILES = (ServletFileUpload $SFU).parseRequest(($X.servlet.http.HttpServletRequest $REQ));
              ...
              for(FileItem $ITEM : $FILES) {
                ...
              }
          - pattern: "$ITEM.getName()"
      - pattern: "($X.servlet.http.Part $PART).getSubmittedFileName()"
    metadata:
      category: security
      cwe: CWE-22
      shortDescription: Improper limitation of a pathname to a restricted directory
        ('Path Traversal')
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.FILE_UPLOAD_FILENAME-1
      secondary_identifiers:
        - name: Find Security Bugs-FILE_UPLOAD_FILENAME
          type: find_sec_bugs_type
          value: FILE_UPLOAD_FILENAME
    severity: ERROR
  - id: find_sec_bugs.WEAK_FILENAMEUTILS-1
    languages:
      - java
    message: |
      A file is opened to read its content. The filename comes from an input
      parameter. If an unfiltered parameter is passed to this file API, files from an
      arbitrary filesystem location could be read.
    patterns:
      - pattern-inside: |
          import static org.apache.commons.io.FilenameUtils;
          ...
      - pattern-either:
          - pattern: normalize(...)
          - pattern: getExtension(...)
          - pattern: isExtensions(...)
          - pattern: getName(...)
          - pattern: getBaseName(...)
          - pattern: org.apache.commons.io.FilenameUtils.normalize(...)
          - pattern: org.apache.commons.io.FilenameUtils.getExtension(...)
          - pattern: org.apache.commons.io.FilenameUtils.isExtensions(...)
          - pattern: org.apache.commons.io.FilenameUtils.getName(...)
          - pattern: org.apache.commons.io.FilenameUtils.getBaseName(...)
    metadata:
      category: security
      cwe: CWE-22
      shortDescription: Improper limitation of a pathname to a restricted directory
        ('Path Traversal')
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.WEAK_FILENAMEUTILS-1
      secondary_identifiers:
        - name: Find Security Bugs-WEAK_FILENAMEUTILS
          type: find_sec_bugs_type
          value: WEAK_FILENAMEUTILS
    severity: ERROR
  - id: find_sec_bugs.COMMAND_INJECTION-1
    languages:
      - java
    pattern-either:
      - patterns:
          - pattern-inside: |
              $FUNC(...,String $PARAM, ...) {
                ...
              }
          - pattern-either:
              - pattern: "(Runtime $R).exec(<...$PARAM...>,...);"
              - patterns:
                  - pattern-either:
                      - pattern: |
                          $CMDARR = new String[]{"$SHELL",...,<...$PARAM...>,...};
                          ...
                          (Runtime $R).exec($CMDARR,...);
                      - pattern: |
                          String[] $CMDARR = {"$SHELL",...,<...$PARAM...>,...};
                          ...
                          (Runtime $R).exec($CMDARR,...);
                      - pattern: (Runtime $R).exec(new String[]{"$SHELL",...,<...$PARAM...>,...},
                          ...);
                      - pattern: (Runtime $R).exec(java.util.String.format("...", ...,<...$PARAM...>,...));
                      - pattern: "(Runtime $R).exec((String $A) + (String $B));"
                  - metavariable-regex:
                      metavariable: "$SHELL"
                      regex: "(/.../)?(sh|bash|ksh|csh|tcsh|zsh)$"
          - pattern-not: (Runtime $R).exec("...","...","...",...);
          - pattern-not: '(Runtime $R).exec(new String[]{"...","...","...",...},...);

        '
      - patterns:
          - pattern-inside: |
              $FUNC(...,String $PARAM, ...) {
                ...
              }
          - pattern-either:
              - pattern: "(ProcessBuilder $PB).command(<...$PARAM...>,...);"
              - patterns:
                  - pattern-inside: "$VAL = <...$PARAM...>; ..."
                  - pattern: "(ProcessBuilder $PB).command(<...$VAL...>,...);"
              - patterns:
                  - pattern-either:
                      - pattern: (ProcessBuilder $PB).command("$SHELL",...,<...$PARAM...>,...);
                      - pattern: |
                          $CMDARR = java.util.Arrays.asList("$SHELL",...,<...$PARAM...>,...);
                          ...
                          (ProcessBuilder $PB).command($CMDARR,...);
                      - pattern: (ProcessBuilder $PB).command(java.util.Arrays.asList("$SHELL",...,<...$PARAM...>,...),...);
                      - pattern: (ProcessBuilder $PB).command(java.util.String.format("...", ...,<...$PARAM...>,...));
                      - pattern: "(ProcessBuilder $PB).command((String $A) + (String $B));"
                  - metavariable-regex:
                      metavariable: "$SHELL"
                      regex: "(/.../)?(sh|bash|ksh|csh|tcsh|zsh)$"
          - pattern-not: (ProcessBuilder $PB).command("...","...","...",...);
          - pattern-not: '(ProcessBuilder $PB).command(java.util.Arrays.asList("...","...","...",...));

        '
    message: |
      OS command injection is a critical vulnerability that can lead to a full system
      compromise as it may allow an adversary to pass in arbitrary commands or arguments
      to be executed.
      
      User input should never be used in constructing commands or command arguments
      to functions which execute OS commands. This includes filenames supplied by
      user uploads or downloads.
      
      Ensure your application does not:
      
      - Use user-supplied information in the process name to execute.
      - Use user-supplied information in an OS command execution function which does
      not escape shell meta-characters.
      - Use user-supplied information in arguments to OS commands.
      
      The application should have a hardcoded set of arguments that are to be passed
      to OS commands. If filenames are being passed to these functions, it is
      recommended that a hash of the filename be used instead, or some other unique
      identifier. It is strongly recommended that a native library that implements
      the same functionality be used instead of using OS system commands, due to the
      risk of unknown attacks against third party commands.
      
      When specifying the OS command, ensure the application uses the full path
      information, otherwise the OS may attempt to look up which process to execute
      and could be vulnerable to untrusted search path vulnerabilities (CWE-426).
      
      Example of safely executing an OS command:
      ```
      public static void executeCommand(String userFileData) throws java.io.IOException {
          // Generate a random filename, do not use user input
          String fileName = UUID.randomUUID().toString();
          // Create a Buffered/FileWriter
          BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));
          // Write the user content to our random file
          writer.write(userFileData);
          // Close the file to flush contents
          writer.close();
          // Create the process builder with a hardcoded path to the binary, and our randomly
      generated filename
          ProcessBuilder processBuilder = new ProcessBuilder("/opt/app/path", fileName);
          // Start the process
          Process process = processBuilder.start();
          // Handle/redirect output of process here
          // ...
      }
      ```
      
      For more information on OS command injection, see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html
    severity: WARNING
    metadata:
      shortDescription: Improper neutralization of special elements used in an OS command
        ('OS Command Injection')
      category: security
      cwe: CWE-78
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.COMMAND_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-COMMAND_INJECTION
          type: find_sec_bugs_type
          value: COMMAND_INJECTION
  - id: find_sec_bugs.EL_INJECTION-1
    languages:
      - java
    message: "This rule identifies potential Expression Language (EL) injection vulnerabilities
    within Java applications. \nThe rule targets use of `createValueExpression`, `createMethodExpression`,
    `ELProcessor.eval`, `getValue`, \nand `setValue` methods, particularly when input
    to these methods is not a hardcoded string, indicating dynamic \nevaluation of
    potentially untrusted input. \n\n`createValueExpression` creates a `ValueExpression`
    object which gets evaluated upon calling methods like \n`getValue()` and `setValue()`
    or a Lambda `invoke()` i.e. it evaluates the expression passed to the \n`createValueExpression`
    method.\n\nSimilarly, `createMethodExpression` creates a `MethodExpression` object
    which gets evaluated upon calling \nmethods like `invoke()` and `getMethodInfo()`.\n`ELProcessor.eval`,
    `getValue()`, and `setValue()` methods all evaluate their expressions which are
    passed \nas parameters.\n\nCalling these method directly with user-supplied input
    may allow an adversary to execute arbitrary Java \ncode, including OS system commands.
    Never call these methods directly with user-supplied input. Consider \nalternate
    methods such as a lookup table to take user input and resolve hardcoded values.\n\nSecure
    example:\n\n```\nimport javax.el.ELProcessor;\nimport java.util.Set;\n\npublic
    class SafeELHandling {\n    private static final Set<String> ALLOWED_VALUES =
    Set.of(\"value1\", \"value2\", \"value3\");\n\n    public void processInput(String
    userInput) {\n        // Validate user input against the allowlist\n        if
    (!ALLOWED_VALUES.contains(userInput)) {\n            throw new IllegalArgumentException(\"Invalid
    input\");\n        }\n        \n        ELProcessor elProcessor = new ELProcessor();\n
    \       elProcessor.defineBean(\"userInput\", userInput);\n        \n        //
    Example EL expression using the safe, predefined input\n        String result
    = (String) elProcessor.eval(userInput);\n    }\n}\n```\n"
    metadata:
      category: security
      cwe: CWE-917
      shortDescription: Improper neutralization of special elements used in an expression
        language statement ('Expression Language Injection')
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.EL_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-EL_INJECTION
          type: find_sec_bugs_type
          value: EL_INJECTION
    pattern-either:
      - patterns:
          - pattern: |
              (ExpressionFactory $EXP).createValueExpression((ELContext $CTX), $EXPR,
              ...)
          - pattern-not: |
              (ExpressionFactory $EXP).createValueExpression((ELContext $CTX), "...",
              ...)
      - patterns:
          - pattern: |
              (ExpressionFactory $EXP).createMethodExpression((ELContext $CTX), $EXPR,
              ...)
          - pattern-not: |
              (ExpressionFactory $EXP).createMethodExpression((ELContext $CTX), "...",
              ...)
      - patterns:
          - pattern: "($X.el.ELProcessor $P).eval(...)\n"
          - pattern-not: '($X.el.ELProcessor $P).eval("...", ...)

        '
      - patterns:
          - pattern: "($X.el.ELProcessor $P).getValue(...)\n"
          - pattern-not: '($X.el.ELProcessor $P).getValue("...", ...)

        '
      - patterns:
          - pattern: "($X.el.ELProcessor $P).setValue(...)\n"
          - pattern-not: "($X.el.ELProcessor $P).setValue(\"...\", \"...\")   \n"
    severity: WARNING
  - id: find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1
    languages:
      - java
    mode: taint
    pattern-sinks:
      - patterns:
          - pattern: new org.springframework.web.servlet.ModelAndView($FST);
          - pattern: "$FST"
      - patterns:
          - pattern: new org.springframework.web.servlet.ModelAndView($FST, $SND);
          - pattern: "$FST"
      - patterns:
          - pattern: new org.springframework.web.servlet.ModelAndView($FST, $SND, $TRD);
          - pattern: "$FST"
      - patterns:
          - pattern: new org.apache.struts.action.ActionForward($FST)
          - pattern: "$FST"
      - patterns:
          - pattern: new org.apache.struts.action.ActionForward($FST, $SND)
          - pattern: "$FST"
      - patterns:
          - pattern: new org.apache.struts.action.ActionForward($FST, $SND, $TRD)
          - pattern: "$SND"
      - patterns:
          - pattern: new org.apache.struts.action.ActionForward($FST, $SND, $TRD)
          - pattern: "$TRD"
      - patterns:
          - pattern-inside: |
              $ACTION = new org.apache.struts.action.ActionForward();
              ...
          - pattern: "$ACTION.setPath(...)"
      - patterns:
          - pattern-inside: |
              $MVC = new org.springframework.web.servlet.ModelAndView();
              ...
          - pattern: "$MVC.setViewName(...);"
      - patterns:
          - pattern-inside: |
              $REQ = $HTTP.getRequestDispatcher(...);
              ...
          - pattern-either:
              - pattern: "$REQ.include($FST, $SND)"
              - pattern: "$REQ.forward($FST, $SND)"
    pattern-sources:
      - pattern: "(javax.servlet.http.HttpServletRequest $VAR).getParameter(...)"
    message: |
      The `org.springframework.web.servlet.ModelAndView` class and
      `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods may
      potentially allow access to restricted files if called with user-supplied input.
      
      For Spring MVC, the ModelAndView class looks up a view by name to resolve a `.jsp`
      file. If this view name comes from user-supplied input, it could be abused to attempt
      to return a JSP view that the user should not have access to.
      
      The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return
      any file that is resolvable within the web application context. This includes the `web.xml`
      file, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are
      accessible.
      
      Never pass user-supplied input directly to any of these methods. Use a lookup table or
      hardcode
      which views or paths the user should be directed to. Another option is to use a simple HTTP
      redirect by returning an empty response body with a 301 status code and a `Location` redirect
      header. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.
      
      Example using a lookup table to resolve a view from a Spring MVC application:
      ```
      @RequestMapping(value="/mvc", method=RequestMethod.GET)
      public ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)
       {
        // Create a look up table or pull from a data source
        HashMap<String, String> lookupTable = new HashMap<>();
        lookupTable.put("key1", "view1");
        lookupTable.put("key2", "view2");
        // Get user input
        String userInput = request.getParameter("key");
        // Look up view from the user input
        String viewValue = lookupTable.getOrDefault(userInput, userInput);
        // return the new model and view
        return new ModelAndView(viewValue);
      }
      ```
      
      Example using a redirect instead of a `RequestDispatcher`:
      ```
      // Create a look up table or pull from a data source
      HashMap<String, String> lookupTable = new HashMap<>();
      lookupTable.put("key1", "/Resource1");
      lookupTable.put("key2", "/Resource2");
      // Get user input
      String userInput = request.getParameter("key");
      // Look up resource to redirect to from the user input
      String redirectValue = lookupTable.getOrDefault(userInput, "/Resource1");
      // Redirect the user
      response.sendRedirect(redirectValue);
      ```
    metadata:
      shortDescription: Files or directories accessible to external parties
      category: security
      cwe: CWE-552
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1
      secondary_identifiers:
        - name: Find Security Bugs-REQUESTDISPATCHER_FILE_DISCLOSURE
          type: find_sec_bugs_type
          value: REQUESTDISPATCHER_FILE_DISCLOSURE
        - name: Find Security Bugs-STRUTS_FILE_DISCLOSURE
          type: find_sec_bugs_type
          value: STRUTS_FILE_DISCLOSURE
        - name: Find Security Bugs-SPRING_FILE_DISCLOSURE
          type: find_sec_bugs_type
          value: SPRING_FILE_DISCLOSURE
    severity: ERROR
  - id: find_sec_bugs.HTTP_PARAMETER_POLLUTION-1
    languages:
      - java
    mode: taint
    pattern-sources:
      - pattern: "(HttpServletRequest $REQ).getParameter(...)"
    pattern-sanitizers:
      - pattern: java.net.URLEncoder.encode(...)
      - pattern: com.google.common.net.UrlEscapers.urlPathSegmentEscaper().escape(...)
    pattern-sinks:
      - pattern: new org.apache.http.client.methods.HttpGet(...)
      - pattern: new org.apache.commons.httpclient.methods.GetMethod(...)
      - pattern: "(org.apache.commons.httpclient.methods.GetMethod $GM).setQueryString(...)"
    message: |
      The application was found including unvalidated user input into a URL, which could lead to
      HTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could
      allow an adversary to override the value of a URL or a request parameter.  HTTP Parameter
      Pollution
      (HPP) attacks consist of injecting encoded query string delimiters into other existing
      parameters. If a web
      application does not properly sanitize the user input, an adversary may modify the logic of
      these
      requests to other applications.
      
      To remediate this issue, never allow user input directly into creation of a URL or URL
      parameter. Consider
      using a map to look up user-supplied information and return exact values to be used in the
      generation of
      requests.
      
      Example using a map to look up a key to be used in a HTTP request:
      ```
      HashMap<String, String> lookupTable = new HashMap<>();
      lookupTable.put("key1", "value1");
      lookupTable.put("key2", "value2");
      String userInput = request.getParameter("key");
      
      // Create a CloseableHttpClient, ideally any requests issued should be done
      // out-of-band from the servlet request itself (such as using a separate thread/scheduler
      system)
      try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
          // Lookup the value from our user input from our lookupTable
          String value = lookupTable.getOrDefault(userInput, "value1");
          // Construct the url, with the hardcoded url and only pass in the value from the
      lookupTable,
          // not direct user input
          final HttpGet httpget = new HttpGet("https://example.com/getId?key="+value);
          // Execute the request
          CloseableHttpResponse clientResponse = httpClient.execute(httpget);
          // Read the response
          byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
          // Handle the response
          // ...
      }
      ```
      
      If using a map is not possible, the user-supplied input must be encoded prior to use, and
      never allow full
      URLs:
      ```
      // Get user input
      String userInput = request.getParameter("key");
      // Encode the string using java.net.URLEncoder with the UTF-8 character set
      String encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);
      // Create a CloseableHttpClient, ideally any requests issued should be done
      // out-of-band from the servlet request itself (such as using a separate thread/scheduler
      system)
      try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
        // Construct the url, with the hardcoded url and only pass in the encoded value, never a
      full URL
        final HttpGet httpget = new HttpGet("https://example.com/getId?key="+encodedString);
        // Execute the request
        CloseableHttpResponse clientResponse = httpClient.execute(httpget);
        // Read the response
        byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
        // handle the response
      }
      ```
      
      For more information on SSRF see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html
      
      For more information on HTTP Parameter Pollution see:
      https://en.wikipedia.org/wiki/HTTP_parameter_pollution
    severity: ERROR
    metadata:
      shortDescription: Improper neutralization of argument delimiters in a command
        ('Argument Injection')
      category: security
      cwe: CWE-88
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.HTTP_PARAMETER_POLLUTION-1
      secondary_identifiers:
        - name: Find Security Bugs-HTTP_PARAMETER_POLLUTION
          type: find_sec_bugs_type
          value: HTTP_PARAMETER_POLLUTION
  - id: find_sec_bugs.LDAP_INJECTION-1
    languages:
      - java
    mode: taint
    pattern-sinks:
      - pattern: javax.naming.ldap.LdapName(...)
      - pattern: "(javax.naming.directory.Context $C).lookup(...)"
      - pattern: "(javax.naming.Context $C).lookup(...)"
      - patterns:
          - pattern-inside: "(com.unboundid.ldap.sdk.LDAPConnection $C).search($QUERY, ...)"
          - pattern: "$QUERY"
      - patterns:
          - pattern-either:
              - pattern: "$CTX.lookup(...)"
              - patterns:
                  - pattern-inside: "$CTX.search($QUERY, ...)"
                  - pattern: "$QUERY"
              - patterns:
                  - pattern-inside: "$CTX.search($NAME, $FILTER, ...)"
                  - pattern: "$FILTER"
          - metavariable-pattern:
              metavariable: "$CTX"
              pattern-either:
                - pattern: "(DirContext $C)"
                - pattern: "(InitialDirContext $IDC)"
                - pattern: "(LdapContext $LC)"
                - pattern: "(EventDirContext $EDC)"
                - pattern: "(LdapCtx $LC)"
                - pattern: "(javax.naming.directory.DirContext $C)"
                - pattern: "(javax.naming.directory.InitialDirContext $IDC)"
                - pattern: "(javax.naming.ldap.LdapContext $LC)"
                - pattern: "(javax.naming.event.EventDirContext $EDC)"
                - pattern: "(com.sun.jndi.ldap.LdapCtx $LC)"
      - patterns:
          - pattern-either:
              - patterns:
                  - pattern-inside: "$CTX.list($QUERY, ...)"
                  - pattern: "$QUERY"
              - patterns:
                  - pattern-inside: "$CTX.lookup($QUERY, ...)"
                  - pattern: "$QUERY"
              - patterns:
                  - pattern-inside: "$CTX.search($QUERY, ...)"
                  - pattern: "$QUERY"
              - patterns:
                  - pattern-inside: "$CTX.search($NAME, $FILTER, ...)"
                  - pattern: "$FILTER"
          - metavariable-pattern:
              metavariable: "$CTX"
              pattern-either:
                - pattern: "(LdapTemplate $LT)"
                - pattern: "(LdapOperations $LO)"
                - pattern: "(org.springframework.ldap.core.LdapTemplate $LT)"
                - pattern: "(org.springframework.ldap.core.LdapOperations $LO)"
    pattern-sources:
      - patterns:
          - pattern-inside: |
              $FUNC(..., $VAR, ...) {
                ...
              }
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: |
              $FUNC(..., $X, ...) {
                ...
                $VAR = ... + $X;
                ...
              }
          - pattern: "$VAR"
    message: |
      LDAP injection attacks exploit LDAP queries to influence how data is returned by
      the LDAP server.
      
      Later versions of Java's `InitialDirContext.search` introduced a four argument method, one of
      which is the `filterArg` parameter. The `filterArg` will be automatically encoded when
      querying
      the LDAP server. If this method signature is not available, the application must encode the
      LDAP strings manually.
      
      More details on the four argument `search` method can be found here:
      https://docs.oracle.com/en/java/javase/20/docs/api/java.naming/javax/naming/directory/InitialDirContext.html#search(javax.naming.Name,java.lang.String,java.lang.Object[],javax.naming.directory.SearchControls)
      
      To encode the string manually, it is recommended that all input passed to LDAP querying
      systems
      encode the following values:
      
      - Any occurrence of the null character must be escaped as \00.
      - Any occurrence of the open parenthesis character must be escaped as \28.
      - Any occurrence of the close parenthesis character must be escaped as \29.
      - Any occurrence of the asterisk character must be escaped as \2a.
      - Any occurrence of the backslash character must be escaped as \5c.
      
      Example function that safely encodes user-supplied input to be used in an LDAP query.
      ```
      public static String encodeLDAPString(String input) {
        // Note the \ character is replaced first
        CharSequence[] chars = new CharSequence[] { "\\", "\0", "(", ")", "*" };
        CharSequence[] encoded = new CharSequence[] { "\\5c", "\\00", "\\28", "\\29", "\\2a" };
        // Iterate over each character sequence, replacing the raw value with an encoded version of
      it
        for (int i = 0; i < chars.length; i++)
        {
            // re-assign to input
            input = input.replace(chars[i], encoded[i]);
        }
        // return our modified input string
        return input;
      }
      ```
      
      Example code that using the `filterArgs` parameter which automatically encodes for us:
      ```
      // Create a properties to hold the ldap connection details
      Properties props = new Properties();
      // Use the com.sun.jndi.ldap.LdapCtxFactory factory provider
      props.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
      // The LDAP server URL
      props.put(Context.PROVIDER_URL, "ldap://ldap.example.org:3889");
      // User details for the connection
      props.put(Context.SECURITY_PRINCIPAL, "cn=admin,dc=example,dc=org");
      // LDAP account password
      String ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();
      // Pass in the LDAP password
      props.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);
      
      // Create the LDAPContext
      InitialDirContext ldapContext = new InitialDirContext(props);
      // Example using SUBTREE_SCOPE SearchControls
      SearchControls searchControls = new SearchControls();
      searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);
      
      // Get user input for query
      String userQuery = someUserInput;
      // Use searchArguments to hold the user-supplied input
      Object[] searchArguments = new Object[]{userQuery};
      // Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,
      and pass in the search controls.
      // searchArguments automatically encode
      NamingEnumeration answer = ldapContext.search("dc=example,dc=org", "(cn={0})",
      searchArguments, searchControls);
      // Process the response answer
      while (answer.hasMoreElements()) {
        ...
      }
      ```
      
      For more information on LDAP Injection see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
    severity: WARNING
    metadata:
      shortDescription: Improper neutralization of special elements used in an LDAP
        query ('LDAP Injection')
      category: security
      cwe: CWE-90
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.LDAP_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-LDAP_INJECTION
          type: find_sec_bugs_type
          value: LDAP_INJECTION
  - id: find_sec_bugs.OGNL_INJECTION-1
    languages:
      - java
    mode: taint
    pattern-sources:
      - patterns:
          - pattern-inside: |
              $FUNC(..., $VAR, ...) {
                ...
              }
          - metavariable-pattern:
              metavariable: "$VAR"
              pattern-either:
                - pattern: "(String $S)"
                - pattern: "(Map<String, ?> $M)"
                - pattern: "(Map<String, String> $M)"
                - pattern: "(Map<String, Object> $M)"
          - pattern: "$VAR"
    pattern-sinks:
      - patterns:
          - pattern-inside: com.opensymphony.xwork2.util.TextParseUtil.translateVariables($VAL,
              ...)
          - pattern: "$VAL"
      - patterns:
          - pattern-inside: com.opensymphony.xwork2.util.TextParseUtil.translateVariablesCollection($VAL,
              ...)
          - pattern: "$VAL"
      - pattern: com.opensymphony.xwork2.util.TextParseUtil.shallBeIncluded(...)
      - pattern: com.opensymphony.xwork2.util.TextParseUtil.commaDelimitedStringToSet(...)
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.TextParser $P).evaluate($VAR,
        $VAL, ...)"
          - pattern: "$VAL"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.OgnlTextParser $P).evaluate($VAR,
        $VAL, ...)"
          - pattern: "$VAL"
      - pattern: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getGetMethod($CLZ,
      ...)"
      - pattern: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getSetMethod($CLZ,
      ...)"
      - pattern: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getField($CLZ,
      ...)"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).setProperties($MAP,
        ...)"
          - pattern: "$MAP"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).setProperty($VAL,
        ...)"
          - pattern: "$VAL"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getValue($VAL,
        ...)"
          - pattern: "$VAL"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).setValue($VAL,
        ...)"
          - pattern: "$VAL"
      - pattern: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getGetMethod($CLZ,
      ...)"
      - pattern: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getSetMethod($CLZ,
      ...)"
      - pattern: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getField($CLZ,
      ...)"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider
        $P).setProperties($MAP, ...)"
          - pattern: "$MAP"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider
        $P).setProperty($VAR, ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider
        $P).getValue($VAR, ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider
        $P).setValue($VAR, ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlUtil $P).setProperties($MAP,
        ...)"
          - pattern: "$MAP"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlUtil $P).setProperty($VAR,
        ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlUtil $P).getValue($VAR, ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlUtil $P).setValue($VAR, ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlUtil $P).callMethod($VAR,
        ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.ognl.OgnlUtil $P).compile($VAR, ...)"
          - pattern: "$VAR"
      - pattern: "(org.apache.struts2.util.VelocityStrutsUtil $P).evaluate(...)"
      - pattern: org.apache.struts2.util.StrutsUtil.findString(...)
      - pattern: org.apache.struts2.util.StrutsUtil.findValue(..., $VAL)
      - pattern: org.apache.struts2.util.StrutsUtil.getText(...)
      - pattern: org.apache.struts2.util.StrutsUtil.translateVariables(...)
      - patterns:
          - pattern-inside: org.apache.struts2.util.StrutsUtil.makeSelectList($VAR, ...)
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(org.apache.struts2.views.jsp.ui.OgnlTool $T).findValue($VAR,
        ...)"
          - pattern: "$VAR"
      - pattern: "(com.opensymphony.xwork2.util.ValueStack $V).findString(...)"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.ValueStack $V).findValue($VAR,
        ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.ValueStack $V).setValue($VAR,
        ...)"
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: "(com.opensymphony.xwork2.util.ValueStack $V).setParameter($VAR,
        ...)"
          - pattern: "$VAR"
    message: |
      The Object Graph Navigation Language (OGNL) is an expression language that allows access to
      Java objects and properties stored in an ActionContext. Usage of these low-level
      functions is discouraged because they can effectively execute strings as code, leading to
      remote code execution vulnerabilities. Consider using struts tags when processing
      user-supplied input and templates.
      
      Much like the Struts security guide recommending to not use raw `${}` EL expressions,
      do not call or use the following OGNL packages with user-supplied input:
      
      - `com.opensymphony.xwork2.ognl`
      - `com.opensymphony.xwork2.util`
      - `com.opensymphony.xwork2.util.reflection`
      - `org.apache.struts2.util.StrutsUtil`
      
      For more information on Struts2 security see:
      https://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation
    severity: WARNING
    metadata:
      shortDescription: Expression injection (OGNL)
      category: security
      cwe: CWE-917
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.OGNL_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-OGNL_INJECTION
          type: find_sec_bugs_type
          value: OGNL_INJECTION
  - id: find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1
    languages:
      - java
    mode: taint
    pattern-sanitizers:
      - pattern: org.apache.commons.io.FilenameUtils.getName(...)
    pattern-sinks:
      - patterns:
          - pattern-inside: "$U = new java.net.URI($VAR)\n"
          - pattern-either:
              - pattern-inside: new java.io.File($U)
              - pattern-inside: java.nio.file.Paths.get($U)
          - pattern: "$VAR"
      - patterns:
          - pattern-inside: new java.io.RandomAccessFile($INPUT,...)
          - pattern: "$INPUT"
      - pattern: new java.io.FileReader(...)
      - pattern: new javax.activation.FileDataSource(...)
      - pattern: new java.io.FileInputStream(...)
      - pattern: new java.io.File(...)
      - pattern: java.nio.file.Paths.get(...)
      - pattern: java.io.File.createTempFile(...)
      - pattern: java.io.File.createTempDirectory(...)
      - pattern: java.nio.file.Files.createTempFile(...)
      - pattern: java.nio.file.Files.createTempDirectory(...)
      - patterns:
          - pattern: "$SRC.$METHOD(...)"
          - metavariable-pattern:
              metavariable: "$SRC"
              pattern-either:
                - pattern: getClass()
                - pattern: getClass().getClassLoader()
                - pattern: "(ClassLoader $C)"
                - pattern: "(Class $C)"
                - pattern: "$CLZ.getClassLoader()"
          - metavariable-pattern:
              metavariable: "$METHOD"
              pattern-either:
                - pattern: getResourceAsStream
                - pattern: getResource
      - patterns:
          - pattern-inside: new java.io.FileWriter($PATH, ...)
          - pattern: "$PATH"
      - patterns:
          - pattern-inside: new java.io.FileOutputStream($PATH, ...)
          - pattern: "$PATH"
    pattern-sources:
      - pattern: "(HttpServletRequest $REQ).getParameter(...)"
      - patterns:
          - pattern-inside: "$FUNC(..., @RequestParam $TYPE $REQ, ...) {...}"
          - focus-metavariable: "$REQ"
    message: |
      The application dynamically constructs file or path information. If the path
      information comes from user input, it could be abused to read sensitive files,
      access other users' data, or aid in exploitation to gain further system access.
      
      User input should never be used in constructing paths or files for interacting
      with the filesystem. This includes filenames supplied by user uploads or downloads.
      If possible, consider hashing user input or replacing it with unique values and
      use `Path.resolve` to resolve and validate the path information
      prior to processing any file functionality.
      
      Example using `Path.resolve` and not allowing direct user input:
      ```
      // Class to store our user data along with a randomly generated file name
      public static class UserData {
          private String userFileNameUnsafe;
          private String fileName;
          public UserData(String userFileName) {
              this.userFileNameUnsafe = userFileName;
              // Generate a random ID for the filename
              this.fileName = UUID.randomUUID().toString();
          }
          public String getUserFileNameUnsafe() { return userFileNameUnsafe; };
          public String getFileName() { return fileName; };
      }
      
      public static void main(String[] args) throws Exception {
          // User input, saved only as a reference
          UserData userData = new UserData("..\\test.txt");
          // Restrict all file processing to this directory only
          String base = "/var/app/restricted";
          Path basePath = Paths.get(base);
          // Resolve the full path, but only use our random generated filename
          Path fullPath = basePath.resolve(userData.getFileName());
          // verify the path is contained within our basePath
          if (!fullPath.startsWith(base)) {
              throw new Exception("Invalid path specified!");
          }
          // process / work with file
      }
      ```
      
      For more information on path traversal issues see OWASP:
      https://owasp.org/www-community/attacks/Path_Traversal
    severity: WARNING
    metadata:
      shortDescription: Improper limitation of a pathname to a restricted directory
        ('Path Traversal')
      category: security
      cwe: CWE-22
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1
      secondary_identifiers:
        - name: Find Security Bugs-PT_ABSOLUTE_PATH_TRAVERSAL
          type: find_sec_bugs_type
          value: PT_ABSOLUTE_PATH_TRAVERSAL
  - id: find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1
    languages:
      - java
    message: |
      SQL Injection is a critical vulnerability that can lead to data or system compromise. By
      dynamically generating SQL query strings, user input may be able to influence the logic of
      the SQL statement. This could lead to an adversary accessing information they should
      not have access to, or in some circumstances, being able to execute OS functionality or code.
      
      Replace all dynamically generated SQL queries with parameterized queries. In situations where
      dynamic queries must be created, never use direct user input, but instead use a map or
      dictionary of valid values and resolve them using a user-supplied key.
      
      For example, some database drivers do not allow parameterized queries for `>` or `<` comparison
      operators. In these cases, do not use a user supplied `>` or `<` value, but rather have the
      user
      supply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`
      values to be used in the construction of the dynamic query. The same goes for other queries
      where
      column or table names are required but cannot be parameterized.
      
      Example using `PreparedStatement` queries:
      ```
      // Some userInput
      String userInput = "someUserInput";
      // Your connection string
      String url = "...";
      // Get a connection from the DB via the DriverManager
      Connection conn = DriverManager.getConnection(url);
      // Create a prepared statement
      PreparedStatement st = conn.prepareStatement("SELECT name FROM table where name=?");
      // Set each parameters value by the index (starting from 1)
      st.setString(1, userInput);
      // Execute query and get the result set
      ResultSet rs = st.executeQuery();
      // Iterate over results
      while (rs.next()) {
          // Get result for this row at the provided column number (starting from 1)
          String result = rs.getString(1);
          // ...
      }
      // Close the ResultSet
      rs.close();
      // Close the PreparedStatement
      st.close();
      ```
      
      For more information on SQL Injection see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
    mode: taint
    options:
      taint_assume_safe_functions: true
    pattern-sources:
      - patterns:
          - pattern: public $FUNC(..., String $SRC, ...) { ... }
          - focus-metavariable: "$SRC"
    pattern-propagators:
      - pattern: "$SB.append($SRC)"
        from: "$SRC"
        to: "$SB"
      - pattern: "$RET = String.format(..., $SRC, ...)"
        from: "$SRC"
        to: "$RET"
    pattern-sinks:
      - patterns:
          - pattern-either:
              - pattern: "(javax.jdo.PersistenceManager $PM).newQuery($ARG)"
              - pattern: "(javax.jdo.PersistenceManager $PM).newQuery(..., $ARG)"
              - pattern: "(javax.jdo.Query $Q).setFilter($ARG)"
              - pattern: "(javax.jdo.Query $Q).setGrouping($ARG)"
              - pattern: org.hibernate.criterion.Restrictions.sqlRestriction($ARG, ...)
              - pattern: "(org.hibernate.Session $S).createQuery((String $ARG), ...)"
              - pattern: "(org.hibernate.Session $S).createSQLQuery($ARG, ...)"
              - pattern: "(java.sql.Statement $S).executeQuery($ARG, ...)"
              - pattern: "(java.sql.Statement $S).execute($ARG, ...)"
              - pattern: "(java.sql.Statement $S).executeUpdate($ARG, ...)"
              - pattern: "(java.sql.Statement $S).executeLargeUpdate($ARG, ...)"
              - pattern: "(java.sql.Statement $S).addBatch($ARG, ...)"
              - pattern: "(java.sql.PreparedStatement $S).executeQuery($ARG, ...)"
              - pattern: "(java.sql.PreparedStatement $S).execute($ARG, ...)"
              - pattern: "(java.sql.PreparedStatement $S).executeUpdate($ARG, ...)"
              - pattern: "(java.sql.PreparedStatement $S).executeLargeUpdate($ARG, ...)"
              - pattern: "(java.sql.PreparedStatement $S).addBatch($ARG, ...)"
              - pattern: "(java.sql.Connection $S).prepareCall($ARG, ...)"
              - pattern: "(java.sql.Connection $S).prepareStatement($ARG, ...)"
              - pattern: "(java.sql.Connection $S).nativeSQL($ARG, ...)"
              - pattern: new org.springframework.jdbc.core.PreparedStatementCreatorFactory($ARG,
                  ...)
              - pattern: "(org.springframework.jdbc.core.PreparedStatementCreatorFactory $F).newPreparedStatementCreator($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).batchUpdate($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).execute($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).query($ARG, ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForList($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForMap($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForObject($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForObject($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForRowSet($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForInt($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForLong($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).update($ARG, ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).batchUpdate($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).execute($ARG, ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).query($ARG, ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForList($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForMap($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForObject($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForRowSet($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForInt($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForLong($ARG,
          ...)"
              - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).update($ARG, ...)"
              - pattern: "(io.vertx.sqlclient.SqlClient $O).query($ARG, ...)"
              - pattern: "(io.vertx.sqlclient.SqlClient $O).preparedQuery($ARG, ...)"
              - pattern: "(io.vertx.sqlclient.SqlConnection $O).prepare($ARG, ...)"
              - pattern: "(org.apache.turbine.om.peer.BasePeer $O).executeQuery($ARG, ...)"
              - pattern: "(org.apache.torque.util.BasePeer $O).executeQuery($ARG, ...)"
              - pattern: "(javax.persistence.EntityManager $O).createQuery($ARG, ...)"
              - pattern: "(javax.persistence.EntityManager $O).createNativeQuery($ARG, ...)"
              - pattern: "(org.jdbi.v3.core.Handle $H).createQuery($ARG, ...)"
              - pattern: "(org.jdbi.v3.core.Handle $H).createScript($ARG, ...)"
              - pattern: "(org.jdbi.v3.core.Handle $H).createUpdate($ARG, ...)"
              - pattern: "(org.jdbi.v3.core.Handle $H).execute($ARG, ...)"
              - pattern: "(org.jdbi.v3.core.Handle $H).prepareBatch($ARG, ...)"
              - pattern: "(org.jdbi.v3.core.Handle $H).select($ARG, ...)"
              - pattern: new org.jdbi.v3.core.statement.Script($H, $ARG)
              - pattern: new org.jdbi.v3.core.statement.Update($H, $ARG)
              - pattern: new org.jdbi.v3.core.statement.PreparedBatch($H, $ARG)
          - focus-metavariable: "$ARG"
    metadata:
      shortDescription: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')
      category: security
      cwe: CWE-89
      technology:
        - java
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1
      secondary_identifiers:
        - name: Find Security Bugs-SQL_INJECTION_SPRING_JDBC
          type: find_sec_bugs_type
          value: SQL_INJECTION_SPRING_JDBC
        - name: Find Security Bugs-SQL_INJECTION_JPA
          type: find_sec_bugs_type
          value: SQL_INJECTION_JPA
        - name: Find Security Bugs-SQL_INJECTION_JDO
          type: find_sec_bugs_type
          value: SQL_INJECTION_JDO
        - name: Find Security Bugs-SQL_INJECTION_JDBC
          type: find_sec_bugs_type
          value: SQL_INJECTION_JDBC
        - name: Find Security Bugs-SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE
          type: find_sec_bugs_type
          value: SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE
        - name: Find Security Bugs-SQL_INJECTION
          type: find_sec_bugs_type
          value: SQL_INJECTION
        - name: Find Security Bugs-SQL_INJECTION_HIBERNATE
          type: find_sec_bugs_type
          value: SQL_INJECTION_HIBERNATE
        - name: Find Security Bugs-SQL_INJECTION_VERTX
          type: find_sec_bugs_type
          value: SQL_INJECTION_VERTX
        - name: Find Security Bugs-SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
          type: find_sec_bugs_type
          value: SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
    severity: ERROR
  - id: find_sec_bugs.LDAP_ANONYMOUS-1
    languages:
      - java
    patterns:
      - pattern-inside: |
          import javax.naming.Context;
          ...
      - pattern: $ENV.put(Context.SECURITY_AUTHENTICATION, "none");
    message: |
      The application does not provide authentication when communicating an LDAP
      server. It is strongly recommended that the LDAP server be configured with
      authentication and restrict what queries users can execute.
      
      Example code that authenticates with a remote LDAP server and encodes any
      user-supplied input:
      ```
      // Create a properties to hold the ldap connection details
      Properties props = new Properties();
      // Use the com.sun.jndi.ldap.LdapCtxFactory factory provider
      props.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
      // The LDAP server URL
      props.put(Context.PROVIDER_URL, "ldap://ldap.example.org:3889");
      // User details for the connection
      props.put(Context.SECURITY_PRINCIPAL, "cn=admin,dc=example,dc=org");
      // LDAP account password
      String ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();
      // Pass in the LDAP password
      props.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);
      
      // Create the LDAPContext
      InitialDirContext ldapContext = new InitialDirContext(props);
      // Example using SUBTREE_SCOPE SearchControls
      SearchControls searchControls = new SearchControls();
      searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);
      
      // Get user input for query
      String userQuery = someUserInput;
      // Use searchArguments to hold the user-supplied input
      Object[] searchArguments = new Object[]{userQuery};
      // Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,
      and pass in the search controls.
      // searchArguments automatically encode
      NamingEnumeration answer = ldapContext.search("dc=example,dc=org", "(cn={0})",
      searchArguments, searchControls);
      // Process the response answer
      while (answer.hasMoreElements()) {
        ...
      }
      ```
      
      For information on enabling authentication, please see your LDAP server's
      documentation.
      
      For more information on LDAP Injection see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
    metadata:
      shortDescription: Missing authentication for critical function (LDAP)
      category: security
      cwe: CWE-306
      owasp:
        - A2:2017-Broken Authentication
        - A07:2021-Identification and Authentication Failures
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.LDAP_ANONYMOUS-1
      secondary_identifiers:
        - name: Find Security Bugs-LDAP_ANONYMOUS
          type: find_sec_bugs_type
          value: LDAP_ANONYMOUS
    severity: WARNING
  - id: find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3
    languages:
      - java
    patterns:
      - pattern: java.sql.DriverManager.getConnection($URI, $USR, "...");
    message: |
      A potential hard-coded password was identified in a database connection string.
      Passwords should not be stored directly in code
      but loaded from secure locations such as a Key Management System (KMS).
      
      The purpose of using a Key Management System is so access can be audited and keys easily
      rotated
      in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
      when or if, a key is compromised.
      
      The recommendation on which KMS to use depends on the environment the application is running
      in:
      
      - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
      - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
      - For on premise or other alternatives to cloud providers, consider [Hashicorp's
      Vault](https://www.vaultproject.io/)
      - For other cloud providers, please see their documentation
    severity: WARNING
    metadata:
      shortDescription: Use of hard-coded password
      category: security
      cwe: CWE-259
      owasp:
        - A2:2017-Broken Authentication
        - A07:2021-Identification and Authentication Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3
      secondary_identifiers:
        - name: Find Security Bugs-DMI_CONSTANT_DB_PASSWORD
          type: find_sec_bugs_type
          value: DMI_CONSTANT_DB_PASSWORD
        - name: Find Security Bugs-HARD_CODE_PASSWORD
          type: find_sec_bugs_type
          value: HARD_CODE_PASSWORD
  - id: find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2
    languages:
      - java
    patterns:
      - pattern: java.sql.DriverManager.getConnection($URI, $USR, "");
    message: |
      The application does not provide authentication when communicating a database
      server. It is strongly recommended that the database server be configured with
      authentication and restrict what queries users can execute.
      
      Please see your database server's documentation on how to configure a password.
      
      Additionally, passwords should not be stored directly in code
      but loaded from secure locations such as a Key Management System (KMS).
      
      The purpose of using a Key Management System is so access can be audited and keys easily
      rotated
      in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
      when or if, a key is compromised.
      
      The recommendation on which KMS to use depends on the environment the application is running
      in:
      
      - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
      - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
      - For on premise or other alternatives to cloud providers, consider [Hashicorp's
      Vault](https://www.vaultproject.io/)
      - For other cloud providers, please see their documentation
    severity: WARNING
    metadata:
      shortDescription: Missing authentication for critical function (database)
      category: security
      cwe: CWE-306
      owasp:
        - A2:2017-Broken Authentication
        - A07:2021-Identification and Authentication Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2
      secondary_identifiers:
        - name: Find Security Bugs-DMI_EMPTY_DB_PASSWORD
          type: find_sec_bugs_type
          value: DMI_EMPTY_DB_PASSWORD
        - name: Find Security Bugs-HARD_CODE_PASSWORD
          type: find_sec_bugs_type
          value: HARD_CODE_PASSWORD
  - id: find_sec_bugs.HARD_CODE_PASSWORD-1
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              char[] $PWD = ...;
              ...
          - pattern-inside: |
              String $PWD = ...;
              ...
          - pattern-inside: |
              public class $CLAZZ {
              final char[] $PWD = ...;
                ...
              }
          - pattern-inside: |
              public class $CLAZZ {
              final String $PWD = ...;
                ...
              }
          - pattern-inside: |
              $S = new SymmetricEncryptionConfig(...);
              ...
      - pattern-either:
          - pattern: (java.security.KeyStore $KS).load(..., "...")
          - pattern: (java.security.KeyStore $KS).load(..., "...".$FOO(...))
          - pattern: "(java.security.KeyStore $KS).load(..., $PWD)"
          - pattern: "(java.security.KeyStore $KS).load(..., $PWD.$FOO(...))"
          - pattern: KeyManagerFactory.getInstance(...).init(..., $PWD);
          - pattern: KeyManagerFactory.getInstance(...).init(..., $PWD.$FOO(...));
          - pattern: KeyManagerFactory.getInstance(...).init(..., "...");
          - pattern: KeyManagerFactory.getInstance(...).init(..., "...".$FOO(...));
          - pattern: (java.security.KeyStore $KS).getInstance(...).load(..., "...")
          - pattern: (java.security.KeyStore $KS).getInstance(...).load(..., "...".$FOO(...))
          - pattern: "(java.security.KeyStore $KS).getInstance(...).load(..., $PWD)"
          - pattern: "(java.security.KeyStore $KS).getInstance(...).load(..., $PWD.$FOO(...))"
          - pattern: KeyStore.getInstance(...).load(..., "...");
          - pattern: KeyStore.getInstance(...).load(..., "...".$FOO(...));
          - pattern: KeyStore.getInstance(...).load(..., $PWD);
          - pattern: KeyStore.getInstance(...).load(..., $PWD.$FOO(...));
          - pattern: new PBEKeySpec("...", ...)
          - pattern: new PBEKeySpec("...".$FOO(...), ...)
          - pattern: new PBEKeySpec($PWD, ...)
          - pattern: new PBEKeySpec($PWD.$FOO(...), ...)
          - pattern: new PasswordAuthentication("...", "...")
          - pattern: new PasswordAuthentication("...", "...".$FOO(...))
          - pattern: new PasswordAuthentication("...", $PWD)
          - pattern: new PasswordAuthentication("...", $PWD.$FOO(...))
          - pattern: (PasswordCallback $CB).setPassword("...")
          - pattern: (PasswordCallback $CB).setPassword("...".$FOO(...))
          - pattern: "(PasswordCallback $CB).setPassword($PWD)"
          - pattern: "(PasswordCallback $CB).setPassword($PWD.$FOO(...))"
          - pattern: new KeyStore.PasswordProtection("...")
          - pattern: new KeyStore.PasswordProtection("...".$FOO(...))
          - pattern: new KeyStore.PasswordProtection($PWD)
          - pattern: new KeyStore.PasswordProtection($PWD.$FOO(...))
          - pattern: new KerberosKey(...,"...",...);
          - pattern: new KerberosKey(...,"...".$FOO(...),...);
          - pattern: new KerberosKey(...,$PWD,...);
          - pattern: new KerberosKey(...,$PWD.$FOO(...),...);
          - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD);"
          - pattern: (javax.net.ssl.KeyManagerFactory $KMF).init(..., "...");
          - pattern: (javax.net.ssl.KeyManagerFactory $KMF).init(..., "...".$FOO(...));
          - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD.$FOO(...));"
          - pattern: (java.sql.DriverManager).getConnection(..., "...");
          - pattern: (java.sql.DriverManager).getConnection(..., "...".$FOO(...));
          - pattern: "(java.sql.DriverManager).getConnection(..., $PWD);"
          - pattern: "(java.sql.DriverManager).getConnection(..., $PWD.$FOO(...));"
          - pattern: (javax.net.ssl.KeyManagerFactory $KMF).init(..., "...");
          - pattern: (javax.net.ssl.KeyManagerFactory $KMF).init(..., "...".$FOO(...));
          - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD);"
          - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD.$FOO(...));"
          - pattern: io.vertx.ext.web.handler.CSRFHandler.create(..., "...");
          - pattern: io.vertx.ext.web.handler.CSRFHandler.create(..., "...".$FOO(...));
          - pattern: io.vertx.ext.web.handler.CSRFHandler.create(..., $PWD);
          - pattern: io.vertx.ext.web.handler.CSRFHandler.create(..., $PWD.$FOO(...));
          - pattern: "$S.setPassword($PWD);"
          - pattern: "$S.setPassword($PWD.$FOO(...));"
          - pattern: $S.setPassword("...");
      - metavariable-regex:
          metavariable: "$PWD"
          regex: "(?i).*(pass|pwd|psw|secret|key|cipher|crypt|des|aes|mac|private|sign|cert).*"
    message: |
      A potential hard-coded password was identified in a hard-coded string.
      Passwords should not be stored directly in code
      but loaded from secure locations such as a Key Management System (KMS).
      
      The purpose of using a Key Management System is so access can be audited and keys easily
      rotated
      in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
      when or if, a key is compromised.
      
      The recommendation on which KMS to use depends on the environment the application is running
      in:
      
      - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
      - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
      - For on premise or other alternatives to cloud providers, consider [Hashicorp's
      Vault](https://www.vaultproject.io/)
      - For other cloud providers, please see their documentation
    severity: ERROR
    metadata:
      shortDescription: Use of hard-coded password
      category: security
      cwe: CWE-259
      owasp:
        - A2:2017-Broken Authentication
        - A07:2021-Identification and Authentication Failures
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.HARD_CODE_PASSWORD-1
      secondary_identifiers:
        - name: Find Security Bugs-HARD_CODE_PASSWORD
          type: find_sec_bugs_type
          value: HARD_CODE_PASSWORD
  - id: find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1
    pattern-either:
      - pattern: |
          $RUNVAR = new RuntimePermission("createClassLoader");
          ...
          (PermissionCollection $PC).add($RUNVAR);
      - pattern: |
          $REFVAR = new ReflectPermission("suppressAccessChecks");
          ...
          (PermissionCollection $PC).add($REFVAR);
      - pattern: (PermissionCollection $PC).add(new ReflectPermission("suppressAccessChecks"))
      - pattern: (PermissionCollection $PC).add(new RuntimePermission("createClassLoader"))
    languages:
      - java
    message: |
      The application was found to permit the `RuntimePermission` of `createClassLoader`,
      `ReflectPermission` of `suppressAccessChecks`, or both.
      
      By granting the `RuntimePermission` of `createClassLoader`, a compromised application
      could instantiate their own class loaders and load arbitrary classes.
      
      By granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer
      check Java language access checks on fields and methods of a class. This will effectively
      grant access to protected and private members.
      
      For more information on `RuntimePermission` see:
      https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html
      
      For more information on `ReflectPermission` see:
      https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html
    metadata:
      shortDescription: Improper privilege management
      category: security
      cwe: CWE-269
      owasp:
        - A5:2017-Broken Access Control
        - A01:2021-Broken Access Control
      confidence: HIGH
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1
      secondary_identifiers:
        - name: Find Security Bugs-DANGEROUS_PERMISSION_COMBINATION
          type: find_sec_bugs_type
          value: DANGEROUS_PERMISSION_COMBINATION
    severity: WARNING
  - id: find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: java.nio.file.Files.setPosixFilePermissions(..., java.nio.file.attribute.PosixFilePermissions.fromString("$PERM_STRING"));
          - pattern: |
              $PERMISSIONS = java.nio.file.attribute.PosixFilePermissions.fromString("$PERM_STRING");
              ...
              java.nio.file.Files.setPosixFilePermissions(..., $PERMISSIONS);
      - metavariable-regex:
          metavariable: "$PERM_STRING"
          regex: "[rwx-]{6}[rwx]{1,}"
    message: |
      The application was found setting file permissions to overly permissive values. Consider
      using the following values if the application user is the only process to access
      the file:
      
      - `r--` - read only access to the file
      - `w--` - write only access to the file
      - `rw-` - read/write access to the file
      
      Example setting read/write permissions for only the owner of a `Path`:
      ```
      // Get a reference to the path
      Path path = Paths.get("/tmp/somefile");
      // Create a PosixFilePermission set from java.nio.file.attribute
      Set<PosixFilePermission> permissions =
      java.nio.file.attribute.PosixFilePermissions.fromString("rw-------");
      // Set the permissions
      java.nio.file.Files.setPosixFilePermissions(path, permissions);
      ```
      
      For all other values please see:
      https://en.wikipedia.org/wiki/File-system_permissions#Symbolic_notation
    metadata:
      shortDescription: Incorrect permission assignment for critical resource
      cwe: CWE-732
      owasp:
        - A5:2017-Broken Access Control
        - A01:2021-Broken Access Control
      category: security
      confidence: HIGH
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1
      secondary_identifiers:
        - name: Find Security Bugs-OVERLY_PERMISSIVE_FILE_PERMISSION
          type: find_sec_bugs_type
          value: OVERLY_PERMISSIVE_FILE_PERMISSION
    severity: WARNING
  - id: find_sec_bugs.PREDICTABLE_RANDOM-1
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              java.util.Random $R = new java.util.Random();
              ...
              $R.$METHOD();
          - pattern: "(java.util.Random $R).$METHOD()"
          - pattern: new java.util.Random().$METHOD()
          - pattern: org.apache.commons.lang.math.RandomUtils.$METHOD()
          - pattern: org.apache.commons.lang.RandomStringUtils.$METHOD(...)
      - metavariable-regex:
          metavariable: "$METHOD"
          regex: "^(next|random)"
    message: |
      Depending on the context, generating weak random numbers may expose cryptographic functions
      which rely on these numbers, to be exploitable. When generating numbers for sensitive values
      such as tokens, nonces, and cryptographic keys, it is recommended that the `DRBG` instance
      of `SecureRandom` be used.
      
      Example using `DRBG` with `SecureRandom`:
      ```
      public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
      // Use DRBG according to
      http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
          return SecureRandom.getInstance("DRBG",
                  // Security strength in bits (default is 128)
                  DrbgParameters.instantiation(256,
                      // Set prediction resistance and re-seeding
                      DrbgParameters.Capability.PR_AND_RESEED,
                      // Set the personalization string (optional, not necessary)
                      "some_personalization_string".getBytes()
                  )
          );
      }
      ```
      
      For more information on Java Cryptography see:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: WARNING
    metadata:
      shortDescription: Use of insufficiently random values
      category: security
      cwe: CWE-330
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.PREDICTABLE_RANDOM-1
      secondary_identifiers:
        - name: Find Security Bugs-PREDICTABLE_RANDOM
          type: find_sec_bugs_type
          value: PREDICTABLE_RANDOM
  - id: find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1
    languages:
      - java
    mode: taint
    pattern-sinks:
      - patterns:
          - pattern: "(javax.script.ScriptEngine $ENGINE).eval($ARG, ...);"
          - pattern-not: (javax.script.ScriptEngine $ENGINE).eval("...");
          - pattern-not: (javax.script.ScriptEngine $ENGINE).eval("...", (javax.script.Bindings
              $BINDING));
      - patterns:
          - pattern-either:
              - pattern: "(javax.script.Invocable $INVC).invokeFunction(..., $ARG)"
              - pattern: "(javax.script.Invocable $INVC).invokeMethod(..., $ARG)"
    pattern-sources:
      - patterns:
          - pattern-inside: "$FUNC(..., $VAR, ...) { ... }"
          - pattern: "$VAR"
    message: |
      The application executes an argument using a `ScriptEngine`'s `eval` method. This
      may allow for direct OS commands to be executed as it's possible to pass in strings
      such as `java.lang.Runtime.getRuntime().exec('/bin/sh ...');`.
      
      Never pass user-supplied input directly to the `eval` function. If possible hardcode all
      JavasScript code or use a lookup table to resolve user input to known values. If none of these
      techniques are possible, use `javax.script.Bindings` to pass input to the script engine.
      
      Example using `Binding` to safely pass in string values:
      ```
      // Get ECMAScript engine
      ScriptEngine engine = new ScriptEngineManager().getEngineByName("ECMAScript");
      
      // User input, consisting of first and last name
      String userFirstName = "John";
      String userLastName = "Snow";
      
      // Create bindings to pass into our script, forcing the values to be String.
      Bindings bindings = engine.createBindings();
      bindings.put("fname", new String(userFirstName));
      bindings.put("lname", new String(userLastName));
      
      // Example script that concatenates a greeting with the user-supplied input first/last name
      String script = "var greeting='Hello ';" +
      // fname and lname variables will be resolved by our bindings defined above
      "greeting += fname + ' ' + lname;" +
      // prints greeting
      "greeting";
      
      try {
        // Execute the script, passing in the bindings
        Object bindingsResult = engine.eval(script, bindings);
        // Work with result
        // ...
      } catch (ScriptException e) {
        // Handle exception
        e.printStackTrace();
      }
      ```
    severity: ERROR
    metadata:
      shortDescription: Improper control of generation of code ('Code Injection')
      category: security
      cwe: CWE-94
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-SCRIPT_ENGINE_INJECTION
          type: find_sec_bugs_type
          value: SCRIPT_ENGINE_INJECTION
        - name: Find Security Bugs-SPEL_INJECTION
          type: find_sec_bugs_type
          value: SPEL_INJECTION
        - name: Find Security Bugs-EL_INJECTION
          type: find_sec_bugs_type
          value: EL_INJECTION
        - name: Find Security Bugs-SEAM_LOG_INJECTION
          type: find_sec_bugs_type
          value: SEAM_LOG_INJECTION
  - id: find_sec_bugs.SCRIPT_ENGINE_INJECTION-2
    languages:
      - java
    patterns:
      - pattern: "($PARSER $P).$METHOD($ARG);"
      - pattern-not: ($PARSER $P).$METHOD("...");
      - metavariable-pattern:
          metavariable: "$PARSER"
          pattern-either:
            - pattern: org.springframework.expression.spel.standard.SpelExpressionParser
            - pattern: org.springframework.expression.ExpressionParser
      - metavariable-regex:
          metavariable: "$METHOD"
          regex: "(parseExpression|parseRaw)"
    message: |
      The application was found calling SpringFramework's `SpelExpressionParser.parseExpression`.
      Calling this method directly with user-supplied input may allow an adversary to
      execute arbitrary Java code including OS system commands.
      
      Never call `parseExpression` or `parseRaw` directly with user-supplied input. Consider
      alternate
      methods such as a lookup table to take user input and resolve hardcoded values.
      
      Later versions of SpringFramework introduced a `SimpleEvaluationContext` which can be
      used to access bound data when calling the `getValue` result of `parseExpression`. This
      `SimpleEvaluationContext` has a reduced set of functionality and can restrict data binding
      to read-only or read-write contexts. An adversary could still access public properties
      or fields on custom types that have been provided to the evaluation context. Use with caution.
      
      Example using `SimpleEvaluationContext` with a read-write data binding context:
      ```
      @RequestMapping(value="/spel", method=RequestMethod.POST)
      public String spel(@Validated User user, Model model)  {
        // Create the Expression Parser
        SpelExpressionParser parser = new SpelExpressionParser();
        // Parse the expression
        Expression parsedExpression = parser.parseExpression(model.getPossiblyUnsafeData());
        // Create the read-write data binding context
        SimpleEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
        // Execute the expression, passing in the read-write context
        Object result = parsedExpression.getValue(context);
        // work with the result
        // ...
        return "user";
      }
      ```
      
      For more information on SimpleEvaluationContext see:
      https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html
    severity: ERROR
    metadata:
      shortDescription: Improper neutralization of special elements used in an expression
        language statement ('Expression Language Injection')
      category: security
      cwe: CWE-917
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.SCRIPT_ENGINE_INJECTION-2
      secondary_identifiers:
        - name: Find Security Bugs-SCRIPT_ENGINE_INJECTION
          type: find_sec_bugs_type
          value: SCRIPT_ENGINE_INJECTION
  - id: find_sec_bugs.INSECURE_SMTP_SSL-1
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              $E = new org.apache.commons.mail.SimpleEmail(...);
              ...
          - pattern-inside: |
              $E = new org.apache.commons.mail.Email(...);
              ...
          - pattern-inside: |
              $E = new org.apache.commons.mail.MultiPartEmail(...);
              ...
          - pattern-inside: |
              $E = new org.apache.commons.mail.HtmlEmail(...);
              ...
          - pattern-inside: |
              $E = new org.apache.commons.mail.ImageHtmlEmail(...);
              ...
      - pattern-not: |
          $E.setSSLOnConnect(true);
          ...
          $E.setSSLCheckServerIdentity(true);
    message: |
      The Apache commons mail client by default does not enable TLS server identity.
      This allows for an adversary who is in between the application and the target host to intercept
      potentially sensitive information or transmit malicious data.
      
      Enable checking server identity by calling `Email.setSSLCheckServerIdentity(true)`
      
      Example email client that enables TLS and server identity:
      ```
      // Create an email client
      Email email = new SimpleEmail();
      // Configure the email hostname
      email.setHostName("smtp.mail.example.com");
      // Set the port
      email.setSmtpPort(465);
      // Securely retrieve username and password values
      String username = getUserNameFromKMSorSecretStore();
      String password = getPasswordFromKMSorSecretStore();
      // Configure the Authenticator
      DefaultAuthenticator auth = new DefaultAuthenticator(username, password);
      // Set the authenticator
      email.setAuthenticator(auth);
      // Ensure we use SSL on connect
      email.setSSLOnConnect(true);
      // Ensure we validate server identity
      email.setSSLCheckServerIdentity(true);
      // configure the rest of the email
      email.setFrom("x@example.com");
      email.setSubject("TestMail");
      email.setMsg("This is a test mail ... :-)");
      email.addTo("y@example.com");
      email.send();
      ```
    metadata:
      shortDescription: Improper validation of certificate with host mismatch
      category: security
      cwe: CWE-297
      owasp:
        - A3:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.INSECURE_SMTP_SSL-1
      secondary_identifiers:
        - name: Find Security Bugs-INSECURE_SMTP_SSL
          type: find_sec_bugs_type
          value: INSECURE_SMTP_SSL
    severity: ERROR
  - id: find_sec_bugs.SMTP_HEADER_INJECTION-1
    languages:
      - java
    message: |
      The application was found calling `MimeMessage` methods without encoding
      new line characters. Much like HTTP, Simple Mail Transfer Protocol (SMTP) is a
      text based protocol that uses headers to convey additional directives for how
      email messages should be treated. An adversary could potentially cause email
      messages to be sent to unintended recipients by abusing the CC or BCC headers
      if they were able to inject them.
      
      To mitigate this issue, `\r\n` (CRLF) character sequences must be escaped
      or encoded prior to being used in any of the `MimeMessage` methods.
      
      Example that escapes values that come from user input with
      [Apache Commons Text](https://commons.apache.org/proper/commons-text/):
      ```
      // Create a MimeMessage with a javax.mail.Session
      Message message = new MimeMessage(session);
      // Set the from address
      message.setFrom(new InternetAddress("source@example.com"));
      // Set the to address
      message.setRecipients(Message.RecipientType.TO,new InternetAddress[] {new
      InternetAddress("destination@example.com")});
      // Example user input
      String subject = "potentially malicious data";
      String headerValue = "potentially malicious data";
      // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
      message.setSubject(StringEscapeUtils.escapeJava(subject));
      // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
      message.addHeader("HeaderName", StringEscapeUtils.escapeJava(header));
      // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
      message.setDescription(StringEscapeUtils.escapeJava("some description"));
      // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
      message.setDisposition(StringEscapeUtils.escapeJava("some disposition"));
      // Set the mail body text
      message.setText("Some email content.");
      // Send the message
      ```
    patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern-either:
          - patterns:
              - pattern-either:
                  - pattern: "$M.setSubject($VAR)"
                  - pattern: "$M.addHeader($ARG, $VAR)"
                  - pattern: "$M.addHeader($VAR, $ARG)"
                  - pattern: "$M.setDescription($VAR)"
                  - pattern: "$M.setDisposition($VAR)"
              - metavariable-regex:
                  metavariable: "$VAR"
                  regex: "^[a-zA-Z_$][a-zA-Z0-9_$]*$"
          - patterns:
              - pattern-either:
                  - pattern: "$M.setSubject($OBJ.$GETTER(...))"
                  - pattern: "$M.setSubject($OBJ.$GETTER(...) + ...)"
                  - pattern: "$M.setSubject(... + $OBJ.$GETTER(...))"
                  - pattern: "$M.setSubject(... + $OBJ.$GETTER(...) + ...)"
                  - pattern: "$M.addHeader($ARG, $OBJ.$GETTER(...))"
                  - pattern: "$M.addHeader($ARG, $OBJ.$GETTER(...) + ...)"
                  - pattern: "$M.addHeader($ARG, ... + $OBJ.$GETTER(...))"
                  - pattern: "$M.addHeader($ARG, ... + $OBJ.$GETTER(...) + ...)"
                  - pattern: "$M.addHeader($OBJ.$GETTER(...), $ARG)"
                  - pattern: "$M.addHeader($OBJ.$GETTER(...) + ..., $ARG)"
                  - pattern: "$M.addHeader(... + $OBJ.$GETTER(...), $ARG)"
                  - pattern: "$M.addHeader(... + $OBJ.$GETTER(...) + ..., $ARG)"
                  - pattern: "$M.setDescription($OBJ.$GETTER(...))"
                  - pattern: "$M.setDisposition($OBJ.$GETTER(...) + ...)"
                  - pattern: "$M.setDisposition(... + $OBJ.$GETTER(...))"
                  - pattern: "$M.setDisposition(... + $OBJ.$GETTER(...) + ...)"
              - metavariable-regex:
                  metavariable: "$GETTER"
                  regex: "^get"
    metadata:
      shortDescription: Improper neutralization of special elements used in a command
      category: security
      cwe: CWE-77
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.SMTP_HEADER_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-SMTP_HEADER_INJECTION
          type: find_sec_bugs_type
          value: SMTP_HEADER_INJECTION
    severity: ERROR
  - id: find_sec_bugs.URLCONNECTION_SSRF_FD-1
    languages:
      - java
    message: |
      Server-Side-Request-Forgery (SSRF) exploits backend systems that initiate requests to third
      parties.
      If user input is used in constructing or sending these requests, an attacker could supply
      malicious
      data to force the request to other systems or modify request data to cause unwanted actions.
      
      Ensure user input is not used directly in constructing URLs or URIs when initiating requests
      to third party
      systems from back end systems. Care must also be taken when constructing payloads using user
      input. Where
      possible restrict to known URIs or payloads. Consider using a server-side map where keys are
      used to return
      URLs such as `https://site/goto?key=1` where `{key: 1, url: 'http://some.url/', key: 2, url:
      'http://...'}`.
      
      If you must use user-supplied input for requesting URLs, it is strongly recommended that the
      HTTP client
      chosen allows you to customize and block certain IP ranges at the network level. By blocking
      RFC 1918
      addresses or other network address ranges, you can limit the severity of a successful SSRF
      attack. Care must
      also be taken to block certain protocol or address formatting such as IPv6.
      
      If you cannot block address ranges at the client level, you may want to run the HTTP client
      as a protected
      user, or in a protected network where you can apply IP Table or firewall rules to block access
      to dangerous
      addresses. Finally, if none of the above protections are available, you could also run a
      custom HTTP proxy
      and force all requests through it to handle blocking dangerous addresses.
      
      Example using a map to look up a key to be used in a HTTP request:
      ```
      HashMap<String, String> lookupTable = new HashMap<>();
      lookupTable.put("key1", "https://example.com/");
      lookupTable.put("key2", "https://safeurl.com/");
      String userInput = request.getParameter("key");
      
      // Create a CloseableHttpClient, ideally any requests issued should be done
      // out-of-band from the servlet request itself (such as using a separate thread/scheduler
      system)
      try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
          // Lookup the value from our user input from our lookupTable
          String value = lookupTable.getOrDefault(userInput, "https://example.com/");
          // Construct the url, with the hardcoded url and only pass in the value from the
      lookupTable,
          // not direct user input
          final HttpGet httpget = new HttpGet(value);
          // Execute the request
          CloseableHttpResponse clientResponse = httpClient.execute(httpget);
          // Read the response
          byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
          // Handle the response
          // ...
      }
      ```
      
      If using a map is not possible, the user-supplied input must be encoded prior to use, and
      never allow full
      URLs:
      ```
      // Get user input
      String userInput = request.getParameter("key");
      // Encode the string using java.net.URLEncoder with the UTF-8 character set
      String encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);
      // Create a CloseableHttpClient, ideally any requests issued should be done
      // out-of-band from the servlet request itself (such as using a separate thread/scheduler
      system)
      try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
        // Construct the url, with the hardcoded url and only pass in the encoded value, never a
      full URL
        final HttpGet httpget = new HttpGet("https://example.com/getId?key="+encodedString);
        // Execute the request
        CloseableHttpResponse clientResponse = httpClient.execute(httpget);
        // Read the response
        byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
        // handle the response
      }
      ```
      
      For more information on SSRF see OWASP:
      https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html
    pattern-either:
      - patterns:
          - pattern-either:
              - pattern-inside: |
                  import java.net.*;
                  ...
              - pattern-inside: |
                  import java.net.URL;
                  ...
              - pattern-inside: |
                  import java.net.URI;
                  ...
          - pattern: new $TYPE(...). ... .$FUNC
          - pattern-not: new $TYPE("..."). ... .$FUNC
          - metavariable-pattern:
              metavariable: "$FUNC"
              pattern-either:
                - pattern: connect
                - pattern: GetContent
                - pattern: openConnection
                - pattern: openStream
                - pattern: getContent
          - metavariable-pattern:
              metavariable: "$TYPE"
              pattern-either:
                - pattern: URL
                - pattern: java.net.URL
                - pattern: URI
                - pattern: java.net.URI
      - patterns:
          - pattern-either:
              - pattern-inside: |
                  import java.net.*;
                  ...
              - pattern-inside: |
                  import java.net.InetSocketAddress;
                  ...
          - pattern: 'new InetSocketAddress(..., $PORT)

        '
          - pattern-not: 'new InetSocketAddress("...", $PORT)

        '
    metadata:
      shortDescription: Server-Side Request Forgery (SSRF)
      category: security
      cwe: CWE-918
      owasp:
        - A1:2017-Injection
        - A10:2021-Server-Side Request Forgery
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.URLCONNECTION_SSRF_FD-1
      secondary_identifiers:
        - name: Find Security Bugs-URLCONNECTION_SSRF_FD
          type: find_sec_bugs_type
          value: URLCONNECTION_SSRF_FD
    severity: ERROR
  - id: find_sec_bugs.BAD_HEXA_CONVERSION-1
    languages:
      - java
    message: |
      The application is using `Integer.toHexString` on a digest array buffer which
      may lead to an incorrect version of values.
      
      Consider using the `java.util.HexFormat` object introduced in Java 17. For older Java applications
      consider using the `javax.xml.bind.DatatypeConverter`.
      
      Example using `HexFormat` to create a human-readable string:
      ```
      // Create a MessageDigest using the SHA-384 algorithm
      MessageDigest sha384Digest = MessageDigest.getInstance("SHA-384");
      // Call update with your data
      sha384Digest.update("some input".getBytes(StandardCharsets.UTF_8));
      // Only call digest once all data has been fed into the update sha384digest instance
      byte[] output = sha384Digest.digest();
      // Create a JDK 17 HexFormat object
      HexFormat hex = HexFormat.of();
      // Use formatHex on the byte array to create a string (note that alphabet characters are
      lowercase)
      String hexString = hex.formatHex(output);
      ```
      
      For more information on DatatypeConverter see:
      https://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-
    patterns:
      - pattern-inside: |
          $B_ARR = (java.security.MessageDigest $MD).digest(...);
          ...
      - pattern-either:
          - pattern: |
              for(...) {
                ...
                $B = $B_ARR[...];
                ...
                Integer.toHexString($B);
              }
          - pattern: |
              for(...) {
                ...
                Integer.toHexString($B_ARR[...]);
              }
          - pattern: |
              for(byte $B :$B_ARR) {
                ...
                Integer.toHexString($B);
              }
          - pattern: |
              while(...) {
                ...
                Integer.toHexString($B_ARR[...])
              }
          - pattern: |
              do {
                ...
                Integer.toHexString($B_ARR[...])
              } while(...)
          - pattern: |
              while(...) {
                ...
                $B = $B_ARR[...];
                ...
                Integer.toHexString($B);
              }
          - pattern: |
              do {
                ...
                $B = $B_ARR[...];
                ...
                Integer.toHexString($B);
              } while(...)
    metadata:
      shortDescription: Incorrect type conversion or cast
      cwe: CWE-704
      category: security
      confidence: HIGH
      owasp:
        - A6:2017-Security Misconfiguration
        - A05:2021-Security Misconfiguration
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.BAD_HEXA_CONVERSION-1
      secondary_identifiers:
        - name: Find Security Bugs-BAD_HEXA_CONVERSION
          type: find_sec_bugs_type
          value: BAD_HEXA_CONVERSION
    severity: WARNING
  - id: find_sec_bugs.FORMAT_STRING_MANIPULATION-1
    languages:
      - java
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  String $INPUT = (HttpServletRequest $REQ).getParameter(...);
                  ...
              - pattern-inside: |
                  String $FORMAT_STR = ... + $INPUT;
                  ...
          - patterns:
              - pattern-inside: |
                  String $INPUT = (HttpServletRequest $REQ).getParameter(...);
                  ...
              - pattern-inside: |
                  String $FORMAT_STR = ... + $INPUT + ...;
                  ...
          - pattern-inside: |
              String $FORMAT_STR = ... + (HttpServletRequest $REQ).getParameter(...) + ...;
              ...
          - pattern-inside: |
              String $FORMAT_STR = ... + (HttpServletRequest $REQ).getParameter(...);
              ...
      - pattern-either:
          - pattern: String.format($FORMAT_STR, ...);
          - pattern: String.format(java.util.Locale.$LOCALE, $FORMAT_STR, ...);
          - pattern: "(java.util.Formatter $F).format($FORMAT_STR, ...);"
          - pattern: "(java.util.Formatter $F).format(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
          - pattern: "(java.io.PrintStream $F).printf($FORMAT_STR, ...);"
          - pattern: "(java.io.PrintStream $F).printf(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
          - pattern: "(java.io.PrintStream $F).format($FORMAT_STR, ...);"
          - pattern: "(java.io.PrintStream $F).format(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
          - pattern: System.out.printf($FORMAT_STR, ...);
          - pattern: System.out.printf(java.util.Locale.$LOCALE, $FORMAT_STR, ...);
          - pattern: System.out.format($FORMAT_STR, ...);
          - pattern: System.out.format(java.util.Locale.$LOCALE, $FORMAT_STR, ...);
    message: |
      The application allows user input to control format string parameters. By passing invalid
      format
      string specifiers an adversary could cause the application to throw exceptions or possibly
      leak
      internal information depending on application logic.
      
      Never allow user-supplied input to be used to create a format string. Replace all format
      string
      arguments with hardcoded format strings containing the necessary specifiers.
      
      Example of using `String.format` safely:
      ```
      // Get untrusted user input
      String userInput = request.getParameter("someInput");
      // Ensure that user input is not included in the first argument to String.format
      String.format("Hardcoded string expecting a string: %s", userInput);
      // ...
      ```
    metadata:
      shortDescription: Use of externally-controlled format string
      cwe: CWE-134
      category: security
      confidence: HIGH
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.FORMAT_STRING_MANIPULATION-1
      secondary_identifiers:
        - name: Find Security Bugs-FORMAT_STRING_MANIPULATION
          type: find_sec_bugs_type
          value: FORMAT_STRING_MANIPULATION
    severity: ERROR
  - id: find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1
    languages:
      - java
    patterns:
      - pattern: |
          (java.util.regex.Pattern $Y).matcher($VAR);
          ...
          $VAR.$METHOD(...);
      - metavariable-regex:
          metavariable: "$METHOD"
          regex: "(replace|replaceAll|replaceFirst|concat)"
    message: |+
      The application was found matching a variable during a regular expression
      pattern match, and then calling string modification functions after validation has occurred.
      This is usually indicative of a poor input validation strategy as an adversary may attempt to
      exploit the removal of characters.
      
      For example a common mistake in attempting to remove path characters to protect against path
      traversal is to match '../' and then remove any matches. However, if an adversary were to
      include in their input: '....//' then the `replace`  method would replace the first `../` but
      cause the leading `..` and trailing `/` to join into the final string of `../`, effectively
      bypassing the check.
      
      To remediate this issue always perform string modifications before any validation of a string.
      It is strongly recommended that strings be encoded instead of replaced or removed prior to
      validation.
      
      
      Example replaces `..` before validation. Do note this is still not a recommended method for
      protecting against directory traversal, always use randomly generated IDs or filenames instead:
      ```
      // This is ONLY for demonstration purpose, never use untrusted input
      // in paths, always use randomly generated filenames or IDs.
      String input = "test../....//dir";
      // Use replaceAll _not_ replace
      input = input.replaceAll("\\.\\.", "");
      // Input would be test///dir at this point
      // Create a pattern to match on
      Pattern pattern = Pattern.compile("\\.\\.");
      // Create a matcher
      Matcher match = pattern.matcher(input);
      // Call find to see if .. is still in our string
      if (match.find()) {
          throw new Exception(".. detected");
      }
      // Use the input (but do not modify the string)
      System.out.println(input + " safe");
      ```
      
      For more information see Carnegie Mellon University's Secure Coding Guide:
      https://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation

    metadata:
      shortDescription: Collapse of data into unsafe value
      category: security
      cwe: CWE-182
      confidence: HIGH
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1
      secondary_identifiers:
        - name: Find Security Bugs-MODIFICATION_AFTER_VALIDATION
          type: find_sec_bugs_type
          value: MODIFICATION_AFTER_VALIDATION
    severity: WARNING
  - id: find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1
    patterns:
      - pattern: |
          $Y = java.util.regex.Pattern.compile("[<>]");
          ...
          $Y.matcher($VAR);
          ...
          java.text.Normalizer.normalize($VAR, ...);
    languages:
      - java
    message: |
      The application was found matching a variable during a regular expression
      pattern match, and then calling a Unicode normalize function after validation has occurred.
      This is usually indicative of a poor input validation strategy as an adversary may attempt to
      exploit the normalization process.
      
      To remediate this issue, always perform Unicode normalization before any validation of a
      string.
      
      Example of normalizing a string before validation:
      ```
      // User input possibly containing malicious unicode
      String userInput = "\uFE64" + "tag" + "\uFE65";
      // Normalize the input
      userInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);
      // Compile our regex pattern looking for < or > characters
      Pattern pattern = Pattern.compile("[<>]");
      // Create a matcher from the userInput
      Matcher matcher = pattern.matcher(userInput);
      // See if the matcher matches
      if (matcher.find()) {
          // It did so throw an error
          throw new Exception("found banned characters in input");
      }
      ```
      
      For more information see Carnegie Mellon University's Secure Coding Guide:
      https://wiki.sei.cmu.edu/confluence/display/java/IDS01-J.+Normalize+strings+before+validating+them
    metadata:
      shortDescription: 'Incorrect behavior order: validate before canonicalize'
      category: security
      cwe: CWE-180
      confidence: HIGH
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1
      secondary_identifiers:
        - name: Find Security Bugs-NORMALIZATION_AFTER_VALIDATION
          type: find_sec_bugs_type
          value: NORMALIZATION_AFTER_VALIDATION
    severity: WARNING
  - id: find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1
    languages:
      - java
    message: |
      The application may allow control over a template string. Providing user input directly in the
      template by
      dynamically creating template strings may allow an adversary to execute arbitrary Java code,
      including
      OS system commands.
      
      For Velocity, never call `evaluate` with user-supplied input in the template string. Use a
      `VelocityContext`
      object instead to data-bind user-supplied information as it will be treated as an underlying
      data type and not
      template code.
      
      Example using Apache Velocity's `VelocityContext` and escape tools to pass in user-supplied
      data to a template:
      ```
      // Create a tool manager
      ToolManager manager = new ToolManager(true);
      // Create a context from the tool manager
      Context context = manager.createContext();
      // For demonstration purposes, alternatively configure from a properties file
      context.put("esc", new EscapeTool());
      // For demonstration purposes, create an output buffer
      StringWriter stringWriter = new StringWriter();
      // Get userInput
      String userInput = "potentially malicious data";
      // Use the context to pass in the userInput value
      context.put("userInput", userInput);
      // Pass in the context, the output buffer, a logtag (demo), and the template with userInput
      // making sure to escape it if in the context of HTML.
      Velocity.evaluate(context, stringWriter, "demo", "Hello $esc.html($userInput)");
      // Work with the output buffer
      // ...
      ```
      
      For other templating engines, please see your framework's documentation.
    pattern-either:
      - patterns:
          - pattern: org.apache.velocity.app.Velocity.evaluate(..., $VAR)
          - pattern-not: org.apache.velocity.app.Velocity.evaluate(..., "...")
      - patterns:
          - pattern-not-inside: |
              $C = (freemarker.template.Configuration $CFG).getTemplate("...");
              ...
          - pattern-inside: |
              $C = (freemarker.template.Configuration $CFG).getTemplate($IN);
              ...
          - pattern: "$C.process(...)"
      - patterns:
          - pattern-inside: |
              import com.mitchellbosecke.pebble.PebbleEngine;
              ...
          - pattern-inside: |
              $C = $T.getTemplate($IN);
              ...
          - pattern-not-inside: |
              $C = $T.getTemplate("...");
              ...
          - pattern: "$C.evaluate(...)"
    metadata:
      shortDescription: Improper control of generation of code ('Code Injection')
      category: security
      cwe: CWE-94
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1
      secondary_identifiers:
        - name: Find Security Bugs-TEMPLATE_INJECTION_PEBBLE
          type: find_sec_bugs_type
          value: TEMPLATE_INJECTION_PEBBLE
        - name: Find Security Bugs-TEMPLATE_INJECTION_FREEMARKER
          type: find_sec_bugs_type
          value: TEMPLATE_INJECTION_FREEMARKER
        - name: Find Security Bugs-TEMPLATE_INJECTION_VELOCITY
          type: find_sec_bugs_type
          value: TEMPLATE_INJECTION_VELOCITY
    severity: ERROR
  - id: find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1
    languages:
      - java
    patterns:
      - pattern: |
          $TAINTED = (HttpServletRequest $REQ).getParameter(...);
          ...
          (java.sql.Connection $CONN).setCatalog($TAINTED);
    message: |
      The application was found using user-supplied input in a `java.sql.Connection`'s
      `setCatalog` call. This could allow an adversary to supply a different database for the
      lifetime of the connection. Allowing external control of system settings can disrupt service
      or cause an application to behave in unexpected, and potentially malicious ways. Most likely
      this would only cause an error by providing a nonexistent catalog name.
      
      It is recommended to not use user-supplied input when selecting the database for an
      applications
      database connection.
    severity: WARNING
    metadata:
      shortDescription: External control of system or configuration setting
      category: security
      cwe: CWE-15
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1
      secondary_identifiers:
        - name: Find Security Bugs-EXTERNAL_CONFIG_CONTROL
          type: find_sec_bugs_type
          value: EXTERNAL_CONFIG_CONTROL
  - id: find_sec_bugs.SAML_IGNORE_COMMENTS-1
    languages:
      - java
    message: "SAML parses attestations as an XML document. By processing XML comments,
    comment\nfields can end up modifying the interpretation of input fields. This
    could allow\nan adversary to insert an XML comment to break up the attestation's
    username\nor other fields, allowing an attacker to bypass authorization or authentication
    checks.\n\nTo remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool`
    ensure\n`setIgnoreComments(false)` is not called.\n\nThe default value of `ignoreComments`
    is true, which is safe. \n\nRef:\n- https://javadoc.io/doc/org.opensaml/xmltooling/latest/org/opensaml/xml/parse/BasicParserPool.html#ignoreComments\n\nFor
    more information on how this issue can be exploited see:\nhttps://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability\n\nFor
    more information on SAML security see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html\n"
    metadata:
      shortDescription: Improper authentication
      cwe: CWE-287
      category: security
      owasp:
        - A5:2017-Broken Access Control
        - A01:2021-Broken Access Control
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.SAML_IGNORE_COMMENTS-1
      secondary_identifiers:
        - name: Find Security Bugs-SAML_IGNORE_COMMENTS
          type: find_sec_bugs_type
          value: SAML_IGNORE_COMMENTS
    pattern: "(org.opensaml.xml.parse.BasicParserPool $POOL).setIgnoreComments(false);"
    severity: WARNING
  - id: find_sec_bugs.XML_DECODER-1
    languages:
      - java
    message: |
      Deserialization attacks exploit the process of reading serialized data and turning it back
      into an object. By constructing malicious objects and serializing them, an adversary may
      attempt to:
      
      - Inject code that is executed upon object construction, which occurs during the
      deserialization process.
      - Exploit mass assignment by including fields that are not normally a part of the serialized
      data but are read in during deserialization.
      
      Consider safer alternatives such as serializing data in the JSON format. Ensure any format
      chosen allows
      the application to specify exactly which object types are allowed to be deserialized.
      Additionally, when
      deserializing, never deserialize to base object types like `Object` and only cast to the exact
      object
      type that is expected.
      
      To protect against mass assignment, only allow deserialization of the specific fields that are
      required. If this is not easily done, consider creating an intermediary type that
      can be serialized with only the necessary fields exposed.
      
      Do note that `XMLEncoder` and `XMLDecoder` are not recommended. If the application must
      use this serialization method, use a custom ClassLoader to prevent loading of arbitrary
      classes:
      ```
      XMLDecoder decoder = new XMLDecoder(inputStream, null, null, new ClassLoader() {
          @Override
          protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
              if (!name.equals(NameOfBeanHere.class.getName()) &&
      !name.equals(XMLDecoder.class.getName())) {
                  throw new RuntimeException("Unauthorized deserialization attempt: " + name);
              }
      
              return super.loadClass(name, resolve);
          }
      });
      ```
      
      For more information on XML security see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
      
      For more details on deserialization attacks in general, see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
      
      It should be noted that [tools exist](https://github.com/frohoff/ysoserial) to
      automatically create
      exploit code for these vulnerabilities.
    metadata:
      shortDescription: Deserialization of untrusted data
      category: security
      cwe: CWE-502
      owasp:
        - A8:2017-Insecure Deserialization
        - A08:2021-Software and Data Integrity Failures
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.XML_DECODER-1
      secondary_identifiers:
        - name: Find Security Bugs-XML_DECODER
          type: find_sec_bugs_type
          value: XML_DECODER
    patterns:
      - pattern: "(java.beans.XMLDecoder $D).readObject();\n"
      - pattern-not:
          pattern-either:
            - patterns:
                - pattern-inside: |
                    java.beans.XMLDecoder $DEC = new java.beans.XMLDecoder(..., $CL);
                    ...
                - pattern: "$DEC.readObject();"
                - metavariable-pattern:
                    metavariable: "$CL"
                    patterns:
                      - pattern: |
                          new ClassLoader(){
                            ...
                            $RET loadClass(String name, boolean resolve){
                              if($X){
                                throw ...
                              }
                              ...
                            }
                            ...
                          }
                      - metavariable-pattern:
                          metavariable: "$X"
                          pattern-either:
                            - pattern: "!name.equals(...)\n"
                            - pattern: "!$LIST.contains(name)\n"
            - patterns:
                - pattern-inside: |
                    ClassLoader $CLASS_LOADER = $CL;
                    ...
                    java.beans.XMLDecoder $DEC = new java.beans.XMLDecoder(..., $CLASS_LOADER);
                    ...
                - pattern: "$DEC.readObject();"
                - metavariable-pattern:
                    metavariable: "$CL"
                    patterns:
                      - pattern: |
                          new ClassLoader(){
                            ...
                            $RET loadClass(String name, boolean resolve){
                              if($X){
                                throw ...
                              }
                              ...
                            }
                            ...
                          }
                      - metavariable-pattern:
                          metavariable: "$X"
                          pattern-either:
                            - pattern: "!name.equals(...)\n"
                            - pattern: "!$LIST.contains(name)\n"
    severity: WARNING
  - id: find_sec_bugs.MALICIOUS_XSLT-1
    languages:
      - java
    mode: taint
    pattern-sources:
      - patterns:
          - pattern-either:
              - patterns:
                  - pattern-inside: |
                      $FUNC(...,String $VAR, ...) {
                        ...
                      }
                  - pattern-either:
                      - pattern: new FileInputStream(<... $VAR ...>);
                      - pattern: getClass().getResourceAsStream(<... $VAR ...>)
              - patterns:
                  - pattern-inside: |
                      class $CLZ {
                        String $X = "...";
                        ...
                      }
                  - pattern-inside: |
                      $FUNC(...,String $Y, ...) {
                        ...
                      }
                  - pattern-either:
                      - pattern: new FileInputStream($X + $Y);
                      - pattern: getClass().getResourceAsStream($X + $Y)
    pattern-sinks:
      - patterns:
          - pattern-either:
              - pattern-inside: "(javax.xml.transform.TransformerFactory $T).newTransformer($SRC,
          ...)"
              - pattern-inside: "(javax.xml.transform.Transformer $T).transform($SRC, ...)"
          - pattern: "$SRC"
    message: |
      The application performs XSLT translation with potentially malicious input. An adversary who
      is able to influence the
      loaded
      XSL document could call XSL functions or exploit External XML Entity (XXE) attacks that allow
      file
      retrieval or force the parser to connect to arbitrary servers to exfiltrate files. It is
      strongly
      recommended that an alternative approach is used to work with XML data.
      
      For increased security, never process user-supplied XSL style sheets. If XSLT processing is
      absolutely
      necessary, ensure that `FEATURE_SECURE_PROCESSING` is enabled prior to processing the XSLT
      file:
      ```
      // Create a new TransformerFactory instance
      TransformerFactory transformerFactory = TransformerFactory.newInstance();
      // Enable the FEATURE_SECURE_PROCESSING feature
      transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      // Read in the XML Source
      Source xmlSource = new StreamSource(new FileInputStream("hardcoded.xml"));
      // Read in the XSL template file
      Source xslSource = new StreamSource(new FileInputStream("hardcoded.xsl"));
      /// Create the transformer object to do the transformation
      Transformer transformer = transformerFactory.newTransformer(xslSource);
      // Create a Result object for output
      Result result = new StreamResult(System.out);
      // Execute the transformation process
      transformer.transform(xmlSource, result);
      ```
      
      For more information on XML security see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
      
      For more information on the secure processing feature see:
      - https://xml.apache.org/xalan-j/features.html#secureprocessing
    metadata:
      shortDescription: Improper neutralization of special elements in output used by
        a downstream component ('Injection')
      category: security
      cwe: CWE-74
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.MALICIOUS_XSLT-1
      secondary_identifiers:
        - name: Find Security Bugs-MALICIOUS_XSLT
          type: find_sec_bugs_type
          value: MALICIOUS_XSLT
    severity: WARNING
  - id: find_sec_bugs.XPATH_INJECTION-1
    languages:
      - java
    message: |
      The application processes `XPath` queries with potentially malicious input.
      An adversary who is able to control the XPath query could potentially influence the logic
      of how data is retrieved, processed or even bypass protections.
      
      To protect against XPath injection, user input should be parameterized using a variable
      resolver.
      By creating a class that implements the `XPathVariableResolver` the application can ensure
      that
      the xpath query and user-supplied input are treated separately.
      
      Example implementation of an XPathVariableResolver:
      ```
      // Create a class which implements the XPathVariableResolver interface
      public static class SimpleXPathVariableResolver implements XPathVariableResolver {
        // Use a map or lookup table to store variables for resolution
        private HashMap<QName, String> variables = new HashMap<>();
        // Allow caller to set variables
        public void setVariable(QName name, String value) {
          variables.put(name, value);
        }
        // Implement the resolveVariable to return the value
        @Override
        public Object resolveVariable(QName name) {
          return variables.getOrDefault(name, "");
        }
      }
      
      public static void xpathQuery(String userInput) throws ParseException,
      ParserConfigurationException,
        SAXException, IOException, XPathExpressionException {
      
        // Create our DocumentFactory
        DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
        // Enable namespace awareness
        domFactory.setNamespaceAware(true);
        // Enable secure processing
        domFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        // Create our DocumentBuilder
        DocumentBuilder builder = domFactory.newDocumentBuilder();
        // Parse our XML document
        Document doc = builder.parse("inventory.xml");
      
        // Create a new instance of an XPath object
        XPath xpathProcessor = XPathFactory.newInstance().newXPath();
        // Create our XPathVariableResolver
        SimpleXPathVariableResolver resolver = new SimpleXPathVariableResolver();
        // Add user input as a variable value
        resolver.setVariable(new QName("author"), userInput);
        // Configure the processor to use our variable resolver
        xpathProcessor.setXPathVariableResolver(resolver);
        // Evaluate the XPath query
            String result = xpathProcessor.compile("//author[contains(., $author)]").evaluate(doc);
        // Work with the result
        // ...
      }
      ```
      
      For more information on XPath Injection see:
      - https://owasp.org/www-community/attacks/XPATH_Injection
    metadata:
      shortDescription: Improper neutralization of data within XPath expressions ('XPath
        Injection')
      category: security
      cwe: CWE-643
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.XPATH_INJECTION-1
      secondary_identifiers:
        - name: Find Security Bugs-XPATH_INJECTION
          type: find_sec_bugs_type
          value: XPATH_INJECTION
    mode: taint
    pattern-sources:
      - patterns:
          - pattern-inside: |
              $FUNC(..., $VAR, ...) {
                ...
              }
          - pattern: "$VAR"
    pattern-sinks:
      - patterns:
          - pattern-either:
              - pattern-inside: "import javax.xml.xpath.*; \n...\n"
              - pattern-inside: "import javax.xml.xpath.XPath; \n...\n"
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern: "(XPath $X).compile($VAR)"
                      - pattern-not: (XPath $X).compile("...")
                  - patterns:
                      - pattern: "(XPath $X).evaluate($VAR, ...)"
                      - pattern-not: (XPath $X).evaluate("...", ...)
    pattern-sanitizers:
      - pattern-either:
          - pattern-inside: |
              (XPath $X).setXPathVariableResolver(...);
              ...
              (XPath $X).compile("...");
    severity: ERROR
  - id: find_sec_bugs.WICKET_XSS1-1
    languages:
      - java
    patterns:
      - pattern-inside: |
          import org.apache.wicket.$A;
          ...
      - pattern: "$OBJ.setEscapeModelStrings(false);\n"
    message: |
      The application is disabling Wicket's string escaping functionality by calling
      `setEscapeModelStrings(false)`.
      This could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an
      attack which exploits
       a web application or system to treat    user input
      as markup or script code. It is important to encode the data depending on the specific context
      it
      is used in. There are at least six context types:
      
      - Inside HTML tags `<div>context 1</div>`
      - Inside attributes: `<div class="context 2"></div>`
      - Inside event attributes `<button onclick="context 3">button</button>`
      - Inside script blocks: `<script>var x = "context 4"</script>`
      - Unsafe element HTML assignment: `element.innerHTML = "context 5"`
      - Inside URLs: `<iframe src="context 6"></iframe><a href="context 6">link</a>`
      
      Script blocks alone have multiple ways they need to be encoded. Extra care must be taken if
      user input
      is ever output inside of script tags.
      
      User input that is displayed within the application must be encoded, sanitized or validated
      to ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be
      taken
      to not mix server-side templating with client-side templating, as the server-side templating
      will
      not encode things like {{ 7*7 }} which may execute client-side templating features.
      
      It is _NOT_ advised to encode user input prior to inserting into a data store. The data will
      need to be
      encoded depending on context of where it is output. It is much safer to force the displaying
      system to
      handle the encoding and not attempt to guess how it should be encoded.
      
      Use Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`
      
      For more information on Wicket components see:
      - https://nightlies.apache.org/wicket/apidocs/9.x/org/apache/wicket/Component.html
      
      For more information on XSS see OWASP:
      - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
    metadata:
      shortDescription: Improper neutralization of input during web page generation
        ('Cross-site Scripting')
      category: security
      cwe: CWE-79
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.WICKET_XSS1-1
      secondary_identifiers:
        - name: Find Security Bugs-WICKET_XSS1
          type: find_sec_bugs_type
          value: WICKET_XSS1
    severity: WARNING
  - id: find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1
    languages:
      - java
    mode: taint
    pattern-sanitizers:
      - patterns:
          - pattern-inside: org.owasp.encoder.Encode.forHtml($TAINTED);
          - pattern: "$TAINTED"
    pattern-sinks:
      - patterns:
          - pattern-inside: "$FUNC(..., HttpServletResponse $RES, ...) {...}"
          - pattern-inside: |
              $WRITER = $RES.getWriter();
              ...
          - pattern: "$WRITER.write($DATA,...);"
          - pattern: "$DATA"
      - patterns:
          - pattern-inside: "$FUNC(..., HttpServletResponse $RES, ...) {...}"
          - pattern: "$RES.getWriter().write($DATA,...);"
          - pattern: "$DATA"
    pattern-sources:
      - patterns:
          - pattern-inside: "$FUNC(..., HttpServletRequest $REQ, ...) {...}"
          - pattern: "$REQ.getParameter(...);"
    message: |
      The application is returning user-supplied data from an HTTP request directly into an HTTP
      response output
      writer. This could lead to Cross Site Scripting (XSS) if the input were malicious
      script code and the application server is not properly validating the output.
      
      XSS is an attack which exploits a web application or system to treat user input
      as markup or script code. It is important to encode the data depending on the specific context
      it is used in. There are at least six context types:
      
      - Inside HTML tags `<div>context 1</div>`
      - Inside attributes: `<div class="context 2"></div>`
      - Inside event attributes `<button onclick="context 3">button</button>`
      - Inside script blocks: `<script>var x = "context 4"</script>`
      - Unsafe element HTML assignment: `element.innerHTML = "context 5"`
      - Inside URLs: `<iframe src="context 6"></iframe><a href="context 6">link</a>`
      
      Script blocks alone have multiple ways they need to be encoded. Extra care must be taken if
      user input
      is ever output inside of script tags.
      
      User input that is displayed within the application must be encoded, sanitized or validated
      to ensure it cannot be treated as HTML or executed as Javascript code. Care must also be
      taken
      to not mix server-side templating with client-side templating, as the server-side templating
      will
      not encode things like {{ 7*7 }} which may execute client-side templating features.
      
      It is _NOT_ advised to encode user input prior to inserting into a data store. The data will
      need to be
      encoded depending on context of where it is output. It is much safer to force the displaying
      system to
      handle the encoding and not attempt to guess how it should be encoded.
      
      If possible do not use user input directly in the output to the response writer.
      
      If the application must output user-supplied input, it will need to encode the data depending
      on
      the output context.
      
      Consider using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)
      `StringEscapeUtils` methods for various context. Please note there is no way to safely
      output script code in most circumstances, regardless of encoding. If calling the HTTP
      response writer directly, ensure that the `Content-Type` is set to `text/plain` so it will
      not be accidentally interpreted by HTML by modern browsers.
      ```
      // Get user input
      String htmlInput = request.getParameter("userInput");
      // Encode the input using the Html4 encoder
      String htmlEncoded = StringEscapeUtils.escapeHtml4(htmlInput);
      // Force the HTTP response to be content type of text/plain so it is not interpreted as HTML
      response.setContentType("text/plain");
      // Ensure UTF-8
      response.setCharacterEncoding("UTF-8");
      // Write response
      response.getWriter().write(htmlEncoded);
      ```
      
      For more information on XSS see OWASP:
      - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
    severity: WARNING
    metadata:
      shortDescription: Improper neutralization of input during web page generation
        ('Cross-site Scripting')
      category: security
      cwe: CWE-79
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      technology:
        - java
      security-severity: MEDIUM
      primary_identifier: find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1
      secondary_identifiers:
        - name: Find Security Bugs-XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER
          type: find_sec_bugs_type
          value: XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER
  - id: find_sec_bugs.XXE_SAXPARSER-1
    languages:
      - java
    message: |
      External XML entities are a feature of XML parsers that allow documents to contain references
      to
      other documents or data. This feature can be abused to read files, communicate with external
      hosts,
      exfiltrate data, or cause a Denial of Service (DoS).
      
      It is recommended that the `SAXParser` is configured to disable DTD doctypes as this protects
      against the majority of XXE attacks.
      
      Example creating a SAXParser with disallowing the doctypes feature enabled:
      ```
      // Create a SAXParserFactory
      SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
      // Enable the feature which disallows <!DOCTYPE declarations which includes referencing
      external entities.
      saxParserFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      // Create a new parser from this factory
      SAXParser parser = saxParserFactory.newSAXParser();
      // Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve
      method)
      parser.parse(new FileInputStream(new File("bad.xml")), new DefaultHandler());
      ```
      
      For more information on XML security see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
    patterns:
      - pattern-inside: |
          $SF = SAXParserFactory.newInstance();
          ...
      - pattern-not-inside: |
          $SF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
          ...
      - pattern-not-inside: |
          $SF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
          ...
      - pattern-inside: |
          $P = $SFP.newSAXParser();
          ...
      - pattern: "$P.parse(...);"
    metadata:
      shortDescription: Improper restriction of XML external entity reference ('XXE')
      category: security
      cwe: CWE-611
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.XXE_SAXPARSER-1
      secondary_identifiers:
        - name: Find Security Bugs-XXE_SAXPARSER
          type: find_sec_bugs_type
          value: XXE_SAXPARSER
    severity: ERROR
  - id: find_sec_bugs.XXE_XMLREADER-1
    languages:
      - java
    message: |
      External XML entities are a feature of XML parsers that allow documents to contain references
      to
      other documents or data. This feature can be abused to read files, communicate with external
      hosts,
      exfiltrate data, or cause a Denial of Service (DoS).
      
      The XMLReaderFactory has been deprecated. It is recommended that
      [SAXParserFactory](https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html)
      be used
      instead. Additionally when using the SAXParser it must be configured to disallow doctypes,
      which will
      protect against the majority of XXE attacks.
      
      Example creating a SAXParser with disallowing the doctypes feature enabled:
      ```
      // Create a SAXParserFactory
      SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
      // Enable the feature which disallows <!DOCTYPE declarations which includes referencing
      external entities.
      saxParserFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      // Create a new parser from this factory
      SAXParser parser = saxParserFactory.newSAXParser();
      // Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve
      method)
      parser.parse(new FileInputStream(new File("bad.xml")), new DefaultHandler());
      ```
      
      For more information on XML security see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
    patterns:
      - pattern-inside: |
          $R = XMLReaderFactory.createXMLReader();
          ...
      - pattern-not-inside: |
          $R.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
          ...
      - pattern: "$R.parse(...);"
    metadata:
      shortDescription: Improper restriction of XML external entity reference ('XXE')
      category: security
      cwe: CWE-611
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.XXE_XMLREADER-1
      secondary_identifiers:
        - name: Find Security Bugs-XXE_XMLREADER
          type: find_sec_bugs_type
          value: XXE_XMLREADER
    severity: ERROR
  - id: find_sec_bugs.XXE_XMLSTREAMREADER-1
    languages:
      - java
    message: |
      External XML entities are a feature of XML parsers that allow documents to contain references
      to
      other documents or data. This feature can be abused to read files, communicate with external
      hosts,
      exfiltrate data, or cause a Denial of Service (DoS).
      
      In most XML parsers, the recommendation to protect against XXE is to disable the doctype
      feature.
      Unfortunately use of the `XMLInputFactory` requires that the doctypes feature be enabled.
      Instead
      the application can set the `ACCESS_EXTERNAL_DTD` to an empty string and disable
      `javax.xml.stream.isSupportingExternalEntities`.
      
      
      Creates an `XMLInputFactory` stream parser, but disables accessing external DTD or entities:
      ```
      // Create an XMLInputFactory
      XMLInputFactory factory = XMLInputFactory.newFactory();
      // Set the ACCESS_EXTERNAL_DTD property to an empty string so it won't access
      // entities using protocols
      // (ref:
      https://docs.oracle.com/javase/8/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_DTD)
      factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
      // Additionally, disable support for resolving external entities
      factory.setProperty("javax.xml.stream.isSupportingExternalEntities", false);
      // Continue to work with the factory/stream parser
      ```
      
      For more information on XML security see OWASP's guide:
      https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
    patterns:
      - pattern-inside: |
          $SF = XMLInputFactory.newFactory();
          ...
      - pattern-not-inside: |
          $SF.setProperty(XMLInputFactory.SUPPORT_DTD, false);
          ...
      - pattern-not-inside: |
          $SF.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
          ...
      - pattern-not-inside: |
          $SF.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);
          ...
      - pattern-not-inside: |
          $SF.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);
          ...
      - pattern: "$SF.createXMLStreamReader(...)"
    metadata:
      shortDescription: Improper restriction of XML external entity reference ('XXE')
      category: security
      cwe: CWE-611
      owasp:
        - A1:2017-Injection
        - A03:2021-Injection
      security-severity: CRITICAL
      primary_identifier: find_sec_bugs.XXE_XMLSTREAMREADER-1
      secondary_identifiers:
        - name: Find Security Bugs-XXE_XMLSTREAMREADER
          type: find_sec_bugs_type
          value: XXE_XMLSTREAMREADER
    severity: ERROR
