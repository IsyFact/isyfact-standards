rules:
  - id: java_deserialization_rule-JacksonUnsafeDeserialization
    languages:
      - java
    severity: WARNING
    references:
      - https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba
      - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
      - https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true
      - https://github.com/FasterXML/jackson-databind/issues/2587
      - https://cowtowncoder.medium.com/jackson-2-11-features-40cdc1d2bdf3
      - https://fasterxml.github.io/jackson-databind/javadoc/2.11/com/fasterxml/jackson/databind/jsontype/impl/LaissezFaireSubTypeValidator.html
    patterns:
      - pattern-either:
          - patterns:
              - pattern-either:
                  - pattern: |
                      @JsonTypeInfo(use = com.fasterxml.jackson.annotation.JsonTypeInfo.Id.CLASS,...)
                        $TYPE $VAR;
                  - pattern: |
                      @JsonTypeInfo(use = com.fasterxml.jackson.annotation.JsonTypeInfo.Id.MINIMAL_CLASS,...)
                      $TYPE $VAR;
              - metavariable-regex:
                  metavariable: "$TYPE"
                  regex: "(Object|Serializable|Comparable|Cloneable|Closeable|AutoCloseable|Handler|Referenceable|DataSource)"
          - pattern: "(com.fasterxml.jackson.databind.ObjectMapper $OM).enableDefaultTyping(...);\n"
          - pattern: "(com.fasterxml.jackson.databind.ObjectMapper.DefaultTypeResolverBuilder
        $RB).init(com.fasterxml.jackson.annotation.JsonTypeInfo.Id.CLASS, ...);"
          - pattern: "(com.fasterxml.jackson.databind.ObjectMapper.DefaultTypeResolverBuilder
        $RB).init(com.fasterxml.jackson.annotation.JsonTypeInfo.Id.MINIMAL_CLASS,
        ...);"
          - patterns:
              - pattern: "(com.fasterxml.jackson.databind.ObjectMapper $OM).activateDefaultTyping($B.builder(...).
          ... .allowIfBaseType($TYPE.class). ... );"
              - metavariable-regex:
                  metavariable: "$TYPE"
                  regex: "(Object|Serializable|Comparable|Cloneable|Closeable|AutoCloseable|Handler|Referenceable|DataSource)"
          - pattern: "(com.fasterxml.jackson.databind.ObjectMapper $OM).activateDefaultTyping((com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator
        $LFSTV), ObjectMapper.DefaultTyping.EVERYTHING);"
      - pattern-not-inside: "(com.fasterxml.jackson.databind.ObjectMapper $OM).enable(MapperFeature.BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES);
      ...\n"
      - pattern-not-inside: 'JsonMapper.builder(...).enable(MapperFeature.BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES).build();
      ...

      '
    message: "Jackson deserialization vulnerability in Java arises when applications\nusing
    the Jackson library deserialize untrusted JSON data without proper safeguards,\npotentially
    leading to severe security risks like remote code execution (RCE).\n\n1. Avoid
    using polymorphic type handling and avoid deserializing user input.\n2. Absolutely
    avoid using Unsafe Base Types for fields. Types considered unsafe\nbase types
    include:    \n  * java.lang.Object    \n  * java.io.Closeable    \n  * java.io.Serializable\n
    \ * java.lang.AutoCloseable    \n  * java.lang.Cloneable    \n  * java.util.logging.Handler\n
    \ * javax.naming.Referenceable    \n  * javax.sql.DataSource  \nList of types
    compiled from a set of all known deserialization \"gadgets\", types they implement.\nReference
    : https://github.com/FasterXML/jackson-databind/issues/2587 \n3. For explicit
    per-type/per-property polymorphic handling (@JsonTypeInfo), don’t\nuse:    \n*
    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) annotation     \n* @JsonTypeInfo(use
    = JsonTypeInfo.Id.MINIMAL_CLASS) annotation\nInstead use:    \n* @JsonTypeInfo(use
    = JsonTypeInfo.Id.NAME) annotation where possible.\n4. Use Safe Default Typing
    feature properly. Don’t use the deprecated ‘enableDefaultTyping()’.    \n* Refer:
    https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba\n*
    Use Type Validators properly.   \n* Don’t explicitly allow unsafe base types\n5.
    Avoid using  com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator\n*
    Does not do any validation, allows all subtypes. Only used for backwards-compatibility\nreasons:
    users should usually NOT use such a permissive implementation but use\nallow-list/criteria
    - based implementation.    \n* Refer: https://fasterxml.github.io/jackson-databind/javadoc/2.11/com/fasterxml/jackson/databind/jsontype/impl/LaissezFaireSubTypeValidator.html\n6.
    Use MapperFeature.BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES where possible.    \n* Refer:
    https://cowtowncoder.medium.com/jackson-2-11-features-40cdc1d2bdf3\n7. Regularly
    update to the latest version of Jackson library.\n"
    metadata:
      shortDescription: Java Unsafe Jackson Deserialization
      category: security
      cwe: CWE-502
      technology:
        - jackson
      security-severity: MEDIUM
      primary_identifier: java_deserialization_rule-JacksonUnsafeDeserialization
      secondary_identifiers:
        - name: Github java_deserialization_rule-JacksonUnsafeDeserialization
          type: github_type
          value: java_deserialization_rule-JacksonUnsafeDeserialization
  - id: java_crypto_rule_JwtNoneAlgorithm
    message: |
      Detected use of the 'none' algorithm in a JWT token. The 'none'
      algorithm assumes the integrity of the token has already been verified.
      This would allow a malicious actor to forge a JWT token that will
      automatically be verified. Do not explicitly use the 'none' algorithm.
      Instead, use an algorithm such as 'HS256'.
      
      For more information on how to securely use JWT please see OWASP:
      - https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
    metadata:
      shortDescription: Use of a broken or risky cryptographic algorithm
      cwe: CWE-327
      owasp:
        - A03:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: 'V3: Session Management Verification Requirements'
        control_id: 3.5.3 Insecue Stateless Session Tokens
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: '4'
      category: security
      technology:
        - jwt
      confidence: LOW
      references:
        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures
      subcategory:
        - audit
      likelihood: LOW
      impact: MEDIUM
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
      vulnerability_class:
        - Cryptographic Issues
      security-severity: CRITICAL
      primary_identifier: java_crypto_rule_JwtNoneAlgorithm
      secondary_identifiers:
        - name: Github java_crypto_rule_JwtNoneAlgorithm
          type: github_type
          value: java_crypto_rule_JwtNoneAlgorithm
    languages:
      - java
    severity: ERROR
    pattern-either:
      - patterns:
          - pattern: 'io.jsonwebtoken.Jwts.builder()

        '
          - pattern-not-inside: |
              $RETURNTYPE $FUNC(...) {
                ...
                $JWTS.signWith(...);
                ...
              }
      - pattern: "$J.sign(com.auth0.jwt.algorithms.Algorithm.none())\n"
      - pattern: 'new com.nimbusds.jose.PlainHeader(...);

      '
      - pattern: 'new com.nimbusds.jose.PlainHeader.Builder(). ... .build();

      '
  - id: java_ftp_rule-FTPInsecureTransport
    message: "This rule identifies instances where the application uses FTP (File\nTransfer
    Protocol) for transferring files. FTP transmits data in clear\ntext, allowing
    usernames, passwords, and other sensitive information to be\nintercepted by attackers.
    Consider using secure alternatives like SFTP\n(SSH File Transfer Protocol) or
    FTPS (FTP Secure) that provide encryption\nto protect data in transit.\n\nRemediation
    Strategy: To mitigate the risks associated with using unencrypted\nFTP, the application
    should switch to a secure file transfer protocol like\nSFTP or FTPS. Below is
    an example of how to implement FTPS in a Java\napplication.\n\n``` \nimport org.apache.commons.net.ftp.FTPSClient;\n\npublic
    class FTPSExample {\n    public static void main(String[] args) {\n        String
    server = \"ftps.example.com\";\n        int port = 21;\n        String user =
    \"your_username\";\n        String pass = \"your_password\";\n\n        FTPSClient
    ftpsClient = new FTPSClient();\n        try {\n            ftpsClient.connect(server,
    port);\n            ftpsClient.login(user, pass);\n            // Perform file
    operations\n\n            ftpsClient.logout();\n            ftpsClient.disconnect();\n
    \       } catch (Exception e) {\n            e.printStackTrace();\n        }\n
    \   }\n} \n```\n"
    severity: WARNING
    metadata:
      shortDescription: Cleartext transmission of sensitive information
      category: security
      cwe: CWE-319
      owasp:
        - A03:2017-Sensitive Data Exposure
        - A02:2021-Cryptographic Failures
      references:
        - https://www.codejava.net/java-se/ftp/connect-and-login-to-a-ftp-server
        - https://commons.apache.org/proper/commons-net/apidocs/org/apache/commons/net/ftp/FTPClient.html
      subcategory:
        - vuln
      technology:
        - java
      vulnerability: Insecure Transport
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
      primary_identifier: java_ftp_rule-FTPInsecureTransport
      secondary_identifiers:
        - name: Gitlab java_ftp_rule-FTPInsecureTransport
          type: gitlab_type
          value: java_ftp_rule-FTPInsecureTransport
    languages:
      - java
    pattern-either:
      - pattern: "(org.apache.commons.net.ftp.FTPClient $FTPCLIENT).connect(...);\n"
      - pattern: |
          URL $URL = new URL("=~/^[fF][tT][pP]://.*/");
          ...
          URLConnection $CONN = $URL.openConnection(...);
  - id: java_password_rule-HardcodeKey
    languages:
      - java
    pattern-either:
      - patterns:
          - pattern-not-inside: |
              $FUNC(...,$TYPE $KEY_BYTES, ...) {
              ...
              }
          - pattern-not-inside: |
              $SC = (KeyGenerator $KG).generateKey();
              ...
              byte[] $KEY_BYTES = $SC.getEncoded();
              ...
          - pattern-either:
              - pattern: new DESKeySpec((byte[] $KEY_BYTES), ...);
              - pattern: new DESKeySpec($KEY_BYTES.getBytes(), ...);
              - pattern: new DESedeKeySpec((byte[] $KEY_BYTES), ...);
              - pattern: new DESedeKeySpec($KEY_BYTES.getBytes(), ...);
              - pattern: new KerberosKey(..., (byte[] $KEY_BYTES), ...);
              - pattern: new KerberosKey(..., $KEY_BYTES.getBytes(), ...);
              - pattern: new SecretKeySpec((byte[] $KEY_BYTES), ...);
              - pattern: new SecretKeySpec($KEY_BYTES.getBytes(), ...);
              - pattern: new X509EncodedKeySpec((byte[] $KEY_BYTES));
              - pattern: new X509EncodedKeySpec($KEY_BYTES.getBytes());
              - pattern: new PKCS8EncodedKeySpec((byte[] $KEY_BYTES));
              - pattern: new PKCS8EncodedKeySpec($KEY_BYTES.getBytes());
              - pattern: new KeyRep(...,(byte[] $KEY_BYTES));
              - pattern: new KeyRep(...,$KEY_BYTES.getBytes());
              - pattern: new KerberosTicket($ASN, $CLIENT, $SERVER, (byte[] $KEY_BYTES), ...);
              - pattern: new KerberosTicket($ASN, $CLIENT, $SERVER, $KEY_BYTES.getBytes(),
                  ...);
              - pattern: new HmacUtils(..., (byte[] $KEY_BYTES));
              - pattern: new HmacUtils(..., $KEY_BYTES.getBytes());
              - pattern: new HmacUtils(..., (String $KEY_BYTES));
              - pattern: new KeyParameter((byte[] $KEY_BYTES), ...);
              - pattern: new KeyParameter($KEY_BYTES.getBytes(), ...);
              - patterns:
                  - pattern-either:
                      - pattern: Algorithm.$HMAC((byte[] $KEY_BYTES));
                      - pattern: Algorithm.$HMAC($KEY_BYTES.getBytes());
                      - pattern: Algorithm.$HMAC((String $KEY_BYTES));
                  - metavariable-regex:
                      metavariable: "$HMAC"
                      regex: "(HMAC384|HMAC256|HMAC512)"
          - metavariable-pattern:
              metavariable: "$KEY_BYTES"
              patterns:
                - pattern-not-regex: "(null)"
      - patterns:
          - pattern-either:
              - patterns:
                  - pattern-either:
                      - pattern-inside: |
                          BigInteger $PRIVATE_KEY = new BigInteger(...);
                          ...
                      - pattern-inside: |
                          class $CLS{
                          ...
                          BigInteger $PRIVATE_KEY = new BigInteger(...);
                          ...
                          }
                  - pattern: 'new $METHOD($PRIVATE_KEY, ...);

            '
              - patterns:
                  - pattern-either:
                      - pattern-inside: |
                          class $CLS{
                            ...
                            $TYPE $PRIVATE_KEY = ...
                            ...
                          }
                      - pattern-inside: "$T $FUNC(...) {\n  ...\n  $TYPE $PRIVATE_KEY = ...;\n
              \ ...\n}    \n"
                  - pattern: "new $METHOD(new BigInteger($PRIVATE_KEY), ...);              \n"
          - metavariable-pattern:
              metavariable: "$PRIVATE_KEY"
              patterns:
                - pattern-not-regex: "(null)"
          - metavariable-regex:
              metavariable: "$METHOD"
              regex: "(DSAPrivateKeySpec|DHPrivateKeySpec|ECPrivateKeySpec|RSAPrivateKeySpec|RSAMultiPrimePrivateCrtKeySpec|RSAPrivateCrtKeySpec)"
    message: "A potential cryptographic key was identified in a hard-coded string.\nCryptographic
    keys should not be stored directly in code\nbut loaded from secure locations such
    as a Key Management System (KMS).\n\nThe purpose of using a Key Management System
    is to ensure that access can \nbe audited and that the keys can be easily rotated
    in the event of a breach. \nBy hardcoding passwords, it will be extremely difficult
    to determine when or \nif, a key is compromised.\n\nThe recommendation on which
    KMS to use depends on the environment the application\nis running in:\n\n- For
    Google Cloud Platform consider [Cloud Key Management]\n  (https://cloud.google.com/kms/docs)\n-
    For Amazon Web Services consider [AWS Key Management]\n  (https://aws.amazon.com/kms/)\n-
    For on premise or other alternatives to cloud providers, consider \n  [Hashicorp's
    Vault](https://www.vaultproject.io/)\n- For other cloud providers, please see
    their documentation\n"
    severity: ERROR
    metadata:
      shortDescription: Use of hard-coded cryptographic key
      category: security
      cwe: CWE-321
      owasp:
        - A2:2017-Broken Authentication
        - A07:2021-Identification and Authentication Failures
      technology:
        - java
      security-severity: CRITICAL
      primary_identifier: java_password_rule-HardcodeKey
      secondary_identifiers:
        - name: Gitlab java_password_rule-HardcodeKey
          type: gitlab_type
          value: java_password_rule-HardcodeKey

